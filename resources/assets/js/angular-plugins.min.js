/*! 12.0.1 */
!function () { function a(a, b) { window.XMLHttpRequest.prototype[a] = b(window.XMLHttpRequest.prototype[a]) } function b(a, b, c) { try { Object.defineProperty(a, b, { get: c }) } catch (d) { } } if (window.FileAPI || (window.FileAPI = {}), !window.XMLHttpRequest) throw "AJAX is not supported. XMLHttpRequest is not defined."; if (FileAPI.shouldLoad = !window.FormData || FileAPI.forceLoad, FileAPI.shouldLoad) { var c = function (a) { if (!a.__listeners) { a.upload || (a.upload = {}), a.__listeners = []; var b = a.upload.addEventListener; a.upload.addEventListener = function (c, d) { a.__listeners[c] = d, b && b.apply(this, arguments) } } }; a("open", function (a) { return function (b, d, e) { c(this), this.__url = d; try { a.apply(this, [b, d, e]) } catch (f) { f.message.indexOf("Access is denied") > -1 && (this.__origError = f, a.apply(this, [b, "_fix_for_ie_crossdomain__", e])) } } }), a("getResponseHeader", function (a) { return function (b) { return this.__fileApiXHR && this.__fileApiXHR.getResponseHeader ? this.__fileApiXHR.getResponseHeader(b) : null == a ? null : a.apply(this, [b]) } }), a("getAllResponseHeaders", function (a) { return function () { return this.__fileApiXHR && this.__fileApiXHR.getAllResponseHeaders ? this.__fileApiXHR.getAllResponseHeaders() : null == a ? null : a.apply(this) } }), a("abort", function (a) { return function () { return this.__fileApiXHR && this.__fileApiXHR.abort ? this.__fileApiXHR.abort() : null == a ? null : a.apply(this) } }), a("setRequestHeader", function (a) { return function (b, d) { if ("__setXHR_" === b) { c(this); var e = d(this); e instanceof Function && e(this) } else this.__requestHeaders = this.__requestHeaders || {}, this.__requestHeaders[b] = d, a.apply(this, arguments) } }), a("send", function (a) { return function () { var c = this; if (arguments[0] && arguments[0].__isFileAPIShim) { var d = arguments[0], e = { url: c.__url, jsonp: !1, cache: !0, complete: function (a, d) { a && angular.isString(a) && -1 !== a.indexOf("#2174") && (a = null), c.__completed = !0, !a && c.__listeners.load && c.__listeners.load({ type: "load", loaded: c.__loaded, total: c.__total, target: c, lengthComputable: !0 }), !a && c.__listeners.loadend && c.__listeners.loadend({ type: "loadend", loaded: c.__loaded, total: c.__total, target: c, lengthComputable: !0 }), "abort" === a && c.__listeners.abort && c.__listeners.abort({ type: "abort", loaded: c.__loaded, total: c.__total, target: c, lengthComputable: !0 }), void 0 !== d.status && b(c, "status", function () { return 0 === d.status && a && "abort" !== a ? 500 : d.status }), void 0 !== d.statusText && b(c, "statusText", function () { return d.statusText }), b(c, "readyState", function () { return 4 }), void 0 !== d.response && b(c, "response", function () { return d.response }); var e = d.responseText || (a && 0 === d.status && "abort" !== a ? a : void 0); b(c, "responseText", function () { return e }), b(c, "response", function () { return e }), a && b(c, "err", function () { return a }), c.__fileApiXHR = d, c.onreadystatechange && c.onreadystatechange(), c.onload && c.onload() }, progress: function (a) { if (a.target = c, c.__listeners.progress && c.__listeners.progress(a), c.__total = a.total, c.__loaded = a.loaded, a.total === a.loaded) { var b = this; setTimeout(function () { c.__completed || (c.getAllResponseHeaders = function () { }, b.complete(null, { status: 204, statusText: "No Content" })) }, FileAPI.noContentTimeout || 1e4) } }, headers: c.__requestHeaders }; e.data = {}, e.files = {}; for (var f = 0; f < d.data.length; f++) { var g = d.data[f]; null != g.val && null != g.val.name && null != g.val.size && null != g.val.type ? e.files[g.key] = g.val : e.data[g.key] = g.val } setTimeout(function () { if (!FileAPI.hasFlash) throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"'; c.__fileApiXHR = FileAPI.upload(e) }, 1) } else { if (this.__origError) throw this.__origError; a.apply(c, arguments) } } }), window.XMLHttpRequest.__isFileAPIShim = !0, window.FormData = FormData = function () { return { append: function (a, b, c) { b.__isFileAPIBlobShim && (b = b.data[0]), this.data.push({ key: a, val: b, name: c }) }, data: [], __isFileAPIShim: !0 } }, window.Blob = Blob = function (a) { return { data: a, __isFileAPIBlobShim: !0 } } } }(), function () { function a(a) { return "input" === a[0].tagName.toLowerCase() && a.attr("type") && "file" === a.attr("type").toLowerCase() } function b() { try { var a = new ActiveXObject("ShockwaveFlash.ShockwaveFlash"); if (a) return !0 } catch (b) { if (void 0 !== navigator.mimeTypes["application/x-shockwave-flash"]) return !0 } return !1 } function c(a) { var b = 0, c = 0; if (window.jQuery) return jQuery(a).offset(); if (a.offsetParent) do b += a.offsetLeft - a.scrollLeft, c += a.offsetTop - a.scrollTop, a = a.offsetParent; while (a); return { left: b, top: c } } if (FileAPI.shouldLoad) { if (FileAPI.hasFlash = b(), FileAPI.forceLoad && (FileAPI.html5 = !1), !FileAPI.upload) { var d, e, f, g, h, i = document.createElement("script"), j = document.getElementsByTagName("script"); if (window.FileAPI.jsUrl) d = window.FileAPI.jsUrl; else if (window.FileAPI.jsPath) e = window.FileAPI.jsPath; else for (f = 0; f < j.length; f++) if (h = j[f].src, g = h.search(/\/ng\-file\-upload[\-a-zA-z0-9\.]*\.js/), g > -1) { e = h.substring(0, g + 1); break } null == FileAPI.staticPath && (FileAPI.staticPath = e), i.setAttribute("src", d || e + "FileAPI.min.js"), document.getElementsByTagName("head")[0].appendChild(i) } FileAPI.ngfFixIE = function (d, e, f) { if (!b()) throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"'; var g = function () { var b = e.parent(); d.attr("disabled") ? b && b.removeClass("js-fileapi-wrapper") : (e.attr("__ngf_flash_") || (e.unbind("change"), e.unbind("click"), e.bind("change", function (a) { h.apply(this, [a]), f.apply(this, [a]) }), e.attr("__ngf_flash_", "true")), b.addClass("js-fileapi-wrapper"), a(d) || (b.css("position", "absolute").css("top", c(d[0]).top + "px").css("left", c(d[0]).left + "px").css("width", d[0].offsetWidth + "px").css("height", d[0].offsetHeight + "px").css("filter", "alpha(opacity=0)").css("display", d.css("display")).css("overflow", "hidden").css("z-index", "900000").css("visibility", "visible"), e.css("width", d[0].offsetWidth + "px").css("height", d[0].offsetHeight + "px").css("position", "absolute").css("top", "0px").css("left", "0px"))) }; d.bind("mouseenter", g); var h = function (a) { for (var b = FileAPI.getFiles(a), c = 0; c < b.length; c++) void 0 === b[c].size && (b[c].size = 0), void 0 === b[c].name && (b[c].name = "file"), void 0 === b[c].type && (b[c].type = "undefined"); a.target || (a.target = {}), a.target.files = b, a.target.files !== b && (a.__files_ = b), (a.__files_ || a.target.files).item = function (b) { return (a.__files_ || a.target.files)[b] || null } } }, FileAPI.disableFileInput = function (a, b) { b ? a.removeClass("js-fileapi-wrapper") : a.addClass("js-fileapi-wrapper") } } }(), window.FileReader || (window.FileReader = function () { var a = this, b = !1; this.listeners = {}, this.addEventListener = function (b, c) { a.listeners[b] = a.listeners[b] || [], a.listeners[b].push(c) }, this.removeEventListener = function (b, c) { a.listeners[b] && a.listeners[b].splice(a.listeners[b].indexOf(c), 1) }, this.dispatchEvent = function (b) { var c = a.listeners[b.type]; if (c) for (var d = 0; d < c.length; d++) c[d].call(a, b) }, this.onabort = this.onerror = this.onload = this.onloadstart = this.onloadend = this.onprogress = null; var c = function (b, c) { var d = { type: b, target: a, loaded: c.loaded, total: c.total, error: c.error }; return null != c.result && (d.target.result = c.result), d }, d = function (d) { b || (b = !0, a.onloadstart && a.onloadstart(c("loadstart", d))); var e; "load" === d.type ? (a.onloadend && a.onloadend(c("loadend", d)), e = c("load", d), a.onload && a.onload(e), a.dispatchEvent(e)) : "progress" === d.type ? (e = c("progress", d), a.onprogress && a.onprogress(e), a.dispatchEvent(e)) : (e = c("error", d), a.onerror && a.onerror(e), a.dispatchEvent(e)) }; this.readAsDataURL = function (a) { FileAPI.readAsDataURL(a, d) }, this.readAsText = function (a) { FileAPI.readAsText(a, d) } }), !window.XMLHttpRequest || window.FileAPI && FileAPI.shouldLoad || (window.XMLHttpRequest.prototype.setRequestHeader = function (a) { return function (b, c) { if ("__setXHR_" === b) { var d = c(this); d instanceof Function && d(this) } else a.apply(this, arguments) } }(window.XMLHttpRequest.prototype.setRequestHeader)); var ngFileUpload = angular.module("ngFileUpload", []); ngFileUpload.version = "12.0.1", ngFileUpload.service("UploadBase", ["$http", "$q", "$timeout", function (a, b, c) { function d(d) { function e(a) { j.notify && j.notify(a), k.progressFunc && c(function () { k.progressFunc(a) }) } function h(a) { return null != d._start && g ? { loaded: a.loaded + d._start, total: d._file && d._file.size || a.total, type: a.type, config: d, lengthComputable: !0, target: a.target } : a } function i() { a(d).then(function (a) { g && d._chunkSize && !d._finished && d._file ? (e({ loaded: d._end, total: d._file && d._file.size, config: d, type: "progress" }), f.upload(d, !0)) : (d._finished && delete d._finished, j.resolve(a)) }, function (a) { j.reject(a) }, function (a) { j.notify(a) }) } d.method = d.method || "POST", d.headers = d.headers || {}; var j = d._deferred = d._deferred || b.defer(), k = j.promise; return d.disableProgress || (d.headers.__setXHR_ = function () { return function (a) { a && a.upload && a.upload.addEventListener && (d.__XHR = a, d.xhrFn && d.xhrFn(a), a.upload.addEventListener("progress", function (a) { a.config = d, e(h(a)) }, !1), a.upload.addEventListener("load", function (a) { a.lengthComputable && (a.config = d, e(h(a))) }, !1)) } }), g ? d._chunkSize && d._end && !d._finished ? (d._start = d._end, d._end += d._chunkSize, i()) : d.resumeSizeUrl ? a.get(d.resumeSizeUrl).then(function (a) { d._start = d.resumeSizeResponseReader ? d.resumeSizeResponseReader(a.data) : parseInt((null == a.data.size ? a.data : a.data.size).toString()), d._chunkSize && (d._end = d._start + d._chunkSize), i() }, function (a) { throw a }) : d.resumeSize ? d.resumeSize().then(function (a) { d._start = a, i() }, function (a) { throw a }) : (d._chunkSize && (d._start = 0, d._end = d._start + d._chunkSize), i()) : i(), k.success = function (a) { return k.then(function (b) { a(b.data, b.status, b.headers, d) }), k }, k.error = function (a) { return k.then(null, function (b) { a(b.data, b.status, b.headers, d) }), k }, k.progress = function (a) { return k.progressFunc = a, k.then(null, null, function (b) { a(b) }), k }, k.abort = k.pause = function () { return d.__XHR && c(function () { d.__XHR.abort() }), k }, k.xhr = function (a) { return d.xhrFn = function (b) { return function () { b && b.apply(k, arguments), a.apply(k, arguments) } }(d.xhrFn), k }, f.promisesCount++, k["finally"](function () { f.promisesCount-- }), k } function e(a) { var b = {}; for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]); return b } var f = this; f.promisesCount = 0, this.isResumeSupported = function () { return window.Blob && window.Blob instanceof Function && window.Blob.prototype.slice }; var g = this.isResumeSupported(); this.isUploadInProgress = function () { return f.promisesCount > 0 }, this.rename = function (a, b) { return a.ngfName = b, a }, this.jsonBlob = function (a) { null == a || angular.isString(a) || (a = JSON.stringify(a)); var b = new window.Blob([a], { type: "application/json" }); return b._ngfBlob = !0, b }, this.json = function (a) { return angular.toJson(a) }, this.isFile = function (a) { return null != a && (a instanceof window.Blob || a.flashId && a.name && a.size) }, this.upload = function (a, b) { function c(b, c) { if (b._ngfBlob) return b; if (a._file = a._file || b, null != a._start && g) { a._end && a._end >= b.size && (a._finished = !0, a._end = b.size); var d = b.slice(a._start, a._end || b.size); return d.name = b.name, d.ngfName = b.ngfName, a._chunkSize && (c.append("_chunkSize", a._chunkSize), c.append("_currentChunkSize", a._end - a._start), c.append("_chunkNumber", Math.floor(a._start / a._chunkSize)), c.append("_totalSize", a._file.size)), d } return b } function h(b, d, e) { if (void 0 !== d) if (angular.isDate(d) && (d = d.toISOString()), angular.isString(d)) b.append(e, d); else if (f.isFile(d)) { var g = c(d, b), i = e.split(","); i[1] && (g.ngfName = i[1].replace(/^\s+|\s+$/g, ""), e = i[0]), a._fileKey = a._fileKey || e, b.append(e, g, g.ngfName || g.name) } else if (angular.isObject(d)) { if (d.$$ngfCircularDetection) throw "ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: " + e; d.$$ngfCircularDetection = !0; try { for (var j in d) if (d.hasOwnProperty(j) && "$$ngfCircularDetection" !== j) { var k = null == a.objectKey ? "[i]" : a.objectKey; d.length && parseInt(j) > -1 && (k = null == a.arrayKey ? k : a.arrayKey), h(b, d[j], e + k.replace(/[ik]/g, j)) } } finally { delete d.$$ngfCircularDetection } } else b.append(e, d) } function i() { a._chunkSize = f.translateScalars(a.resumeChunkSize), a._chunkSize = a._chunkSize ? parseInt(a._chunkSize.toString()) : null, a.headers = a.headers || {}, a.headers["Content-Type"] = void 0, a.transformRequest = a.transformRequest ? angular.isArray(a.transformRequest) ? a.transformRequest : [a.transformRequest] : [], a.transformRequest.push(function (b) { var c, d = new window.FormData; b = b || a.fields || {}, a.file && (b.file = a.file); for (c in b) if (b.hasOwnProperty(c)) { var e = b[c]; a.formDataAppender ? a.formDataAppender(d, c, e) : h(d, e, c) } return d }) } return b || (a = e(a)), a._isDigested || (a._isDigested = !0, i()), d(a) }, this.http = function (b) { return b = e(b), b.transformRequest = b.transformRequest || function (b) { return window.ArrayBuffer && b instanceof window.ArrayBuffer || b instanceof window.Blob ? b : a.defaults.transformRequest[0].apply(this, arguments) }, b._chunkSize = f.translateScalars(b.resumeChunkSize), b._chunkSize = b._chunkSize ? parseInt(b._chunkSize.toString()) : null, d(b) }, this.translateScalars = function (a) { if (angular.isString(a)) { if (a.search(/kb/i) === a.length - 2) return parseFloat(1024 * a.substring(0, a.length - 2)); if (a.search(/mb/i) === a.length - 2) return parseFloat(1048576 * a.substring(0, a.length - 2)); if (a.search(/gb/i) === a.length - 2) return parseFloat(1073741824 * a.substring(0, a.length - 2)); if (a.search(/b/i) === a.length - 1) return parseFloat(a.substring(0, a.length - 1)); if (a.search(/s/i) === a.length - 1) return parseFloat(a.substring(0, a.length - 1)); if (a.search(/m/i) === a.length - 1) return parseFloat(60 * a.substring(0, a.length - 1)); if (a.search(/h/i) === a.length - 1) return parseFloat(3600 * a.substring(0, a.length - 1)) } return a }, this.urlToBlob = function (c) { var d = b.defer(); return a({ url: c, method: "get", responseType: "arraybuffer" }).then(function (a) { var b = new Uint8Array(a.data), c = a.headers("content-type") || "image/WebP", e = new window.Blob([b], { type: c }); d.resolve(e) }, function (a) { d.reject(a) }), d.promise }, this.setDefaults = function (a) { this.defaults = a || {} }, this.defaults = {}, this.version = ngFileUpload.version }]), ngFileUpload.service("Upload", ["$parse", "$timeout", "$compile", "$q", "UploadExif", function (a, b, c, d, e) { function f(a, b, c) { var e = [h.emptyPromise()]; return angular.forEach(a, function (d, f) { 0 === d.type.indexOf("image/jpeg") && h.attrGetter("ngfFixOrientation", b, c, { $file: d }) && e.push(h.happyPromise(h.applyExifRotation(d), d).then(function (b) { a.splice(f, 1, b) })) }), d.all(e) } function g(a, b, c) { function e(d, e) { if (0 === d.type.indexOf("image")) { if (f.pattern && !h.validatePattern(d, f.pattern)) return; var i = h.resize(d, f.width, f.height, f.quality, f.type, f.ratio, f.centerCrop, function (a, e) { return h.attrGetter("ngfResizeIf", b, c, { $width: a, $height: e, $file: d }) }, f.restoreExif !== !1); g.push(i), i.then(function (b) { a.splice(e, 1, b) }, function (a) { d.$error = "resize", d.$errorParam = (a ? (a.message ? a.message : a) + ": " : "") + (d && d.name) }) } } var f = h.attrGetter("ngfResize", b, c); if (!(f && angular.isObject(f) && h.isResizeSupported() && a.length)) return h.emptyPromise(); for (var g = [h.emptyPromise()], i = 0; i < a.length; i++) e(a[i], i); return d.all(g) } var h = e; return h.getAttrWithDefaults = function (a, b) { if (null != a[b]) return a[b]; var c = h.defaults[b]; return null == c ? c : angular.isString(c) ? c : JSON.stringify(c) }, h.attrGetter = function (b, c, d, e) { var f = this.getAttrWithDefaults(c, b); if (!d) return f; try { return e ? a(f)(d, e) : a(f)(d) } catch (g) { if (b.search(/min|max|pattern/i)) return f; throw g } }, h.shouldUpdateOn = function (a, b, c) { var d = h.attrGetter("ngModelOptions", b, c); return d && d.updateOn ? d.updateOn.split(" ").indexOf(a) > -1 : !0 }, h.emptyPromise = function () { var a = d.defer(), c = arguments; return b(function () { a.resolve.apply(a, c) }), a.promise }, h.rejectPromise = function () { var a = d.defer(), c = arguments; return b(function () { a.reject.apply(a, c) }), a.promise }, h.happyPromise = function (a, c) { var e = d.defer(); return a.then(function (a) { e.resolve(a) }, function (a) { b(function () { throw a }), e.resolve(c) }), e.promise }, h.updateModel = function (c, d, e, i, j, k, l) { function m(f, g, j, l, m) { d.$$ngfPrevValidFiles = f, d.$$ngfPrevInvalidFiles = g; var n = f && f.length ? f[0] : null, o = g && g.length ? g[0] : null; c && (h.applyModelValidation(c, f), c.$setViewValue(m ? n : f)), i && a(i)(e, { $files: f, $file: n, $newFiles: j, $duplicateFiles: l, $invalidFiles: g, $invalidFile: o, $event: k }); var p = h.attrGetter("ngfModelInvalid", d); p && b(function () { a(p).assign(e, m ? o : g) }), b(function () { }) } function n() { function a(a, b) { return a.name === b.name && (a.$ngfOrigSize || a.size) === (b.$ngfOrigSize || b.size) && a.type === b.type } function b(b) { var c; for (c = 0; c < s.length; c++) if (a(b, s[c])) return !0; for (c = 0; c < t.length; c++) if (a(b, t[c])) return !0; return !1 } if (j) { r = [], u = []; for (var c = 0; c < j.length; c++) b(j[c]) ? u.push(j[c]) : r.push(j[c]) } } function o(a) { return angular.isArray(a) ? a : [a] } function p() { w = [], v = [], angular.forEach(r, function (a) { a.$error ? v.push(a) : w.push(a) }) } function q() { function a() { b(function () { m(x ? s.concat(w) : w, x ? t.concat(v) : v, j, u, y) }, B && B.debounce ? B.debounce.change || B.debounce : 0) } g(z ? r : w, d, e).then(function () { z ? h.validate(r, A, c, d, e).then(function () { p(), a() }) : a() }, function (a) { throw "Could not resize files " + a }) } var r, s, t, u = [], v = [], w = []; s = d.$$ngfPrevValidFiles || [], t = d.$$ngfPrevInvalidFiles || [], c && c.$modelValue && (s = o(c.$modelValue)); var x = h.attrGetter("ngfKeep", d, e); r = (j || []).slice(0), ("distinct" === x || h.attrGetter("ngfKeepDistinct", d, e) === !0) && n(d, e); var y = !x && !h.attrGetter("ngfMultiple", d, e) && !h.attrGetter("multiple", d); if (!x || r.length) { h.attrGetter("ngfBeforeModelChange", d, e, { $files: j, $file: j && j.length ? j[0] : null, $newFiles: r, $duplicateFiles: u, $event: k }); var z = h.attrGetter("ngfValidateAfterResize", d, e), A = r.length + s.length + t.length, B = h.attrGetter("ngModelOptions", d, e); h.validate(r, A, c, d, e).then(function () { l ? m(r, [], j, u, y) : (B && B.allowInvalid || z ? w = r : p(), h.attrGetter("ngfFixOrientation", d, e) && h.isExifSupported() ? f(w, d, e).then(function () { q() }) : q()) }) } }, h }]), ngFileUpload.directive("ngfSelect", ["$parse", "$timeout", "$compile", "Upload", function (a, b, c, d) { function e(a) { var b = a.match(/Android[^\d]*(\d+)\.(\d+)/); if (b && b.length > 2) { var c = d.defaults.androidFixMinorVersion || 4; return parseInt(b[1]) < 4 || parseInt(b[1]) === c && parseInt(b[2]) < c } return -1 === a.indexOf("Chrome") && /.*Windows.*Safari.*/.test(a) } function f(a, b, c, d, f, h, i, j) { function k() { return "input" === b[0].tagName.toLowerCase() && c.type && "file" === c.type.toLowerCase() } function l() { return t("ngfChange") || t("ngfSelect") } function m(b) { if (j.shouldUpdateOn("change", c, a)) { for (var e = b.__files_ || b.target && b.target.files, f = [], g = 0; g < e.length; g++) f.push(e[g]); j.updateModel(d, c, a, l(), f.length ? f : null, b) } } function n(a) { if (b !== a) for (var c = 0; c < b[0].attributes.length; c++) { var d = b[0].attributes[c]; "type" !== d.name && "class" !== d.name && "style" !== d.name && ((null == d.value || "" === d.value) && ("required" === d.name && (d.value = "required"), "multiple" === d.name && (d.value = "multiple")), a.attr(d.name, "id" === d.name ? "ngf-" + d.value : d.value)) } } function o() { if (k()) return b; var a = angular.element('<input type="file">'); n(a); var c = angular.element("<label>upload</label>"); return c.css("visibility", "hidden").css("position", "absolute").css("overflow", "hidden").css("width", "0px").css("height", "0px").css("border", "none").css("margin", "0px").css("padding", "0px").attr("tabindex", "-1"), g.push({ el: b, ref: c }), document.body.appendChild(c.append(a)[0]), a } function p(c) { if (b.attr("disabled")) return !1; if (!t("ngfSelectDisabled", a)) { var d = q(c); if (null != d) return d; r(c); try { k() || document.body.contains(w[0]) || (g.push({ el: b, ref: w.parent() }), document.body.appendChild(w.parent()[0]), w.bind("change", m)) } catch (f) { } return e(navigator.userAgent) ? setTimeout(function () { w[0].click() }, 0) : w[0].click(), !1 } } function q(a) { var b = a.changedTouches || a.originalEvent && a.originalEvent.changedTouches; if ("touchstart" === a.type) return v = b ? b[0].clientY : 0, !0; if (a.stopPropagation(), a.preventDefault(), "touchend" === a.type) { var c = b ? b[0].clientY : 0; if (Math.abs(c - v) > 20) return !1 } } function r(b) { j.shouldUpdateOn("click", c, a) && w.val() && (w.val(null), j.updateModel(d, c, a, l(), null, b, !0)) } function s(a) { if (w && !w.attr("__ngf_ie10_Fix_")) { if (!w[0].parentNode) return void (w = null); a.preventDefault(), a.stopPropagation(), w.unbind("click"); var b = w.clone(); return w.replaceWith(b), w = b, w.attr("__ngf_ie10_Fix_", "true"), w.bind("change", m), w.bind("click", s), w[0].click(), !1 } w.removeAttr("__ngf_ie10_Fix_") } var t = function (a, b) { return j.attrGetter(a, c, b) }; j.registerModelChangeValidator(d, c, a); var u = []; u.push(a.$watch(t("ngfMultiple"), function () { w.attr("multiple", t("ngfMultiple", a)) })), u.push(a.$watch(t("ngfCapture"), function () { w.attr("capture", t("ngfCapture", a)) })), u.push(a.$watch(t("ngfAccept"), function () { w.attr("accept", t("ngfAccept", a)) })), c.$observe("accept", function () { w.attr("accept", t("accept")) }), u.push(function () { c.$$observers && delete c.$$observers.accept }); var v = 0, w = b; k() || (w = o()), w.bind("change", m), k() ? b.bind("click", r) : b.bind("click touchstart touchend", p), -1 !== navigator.appVersion.indexOf("MSIE 10") && w.bind("click", s), d && d.$formatters.push(function (a) { return (null == a || 0 === a.length) && w.val() && w.val(null), a }), a.$on("$destroy", function () { k() || w.parent().remove(), angular.forEach(u, function (a) { a() }) }), h(function () { for (var a = 0; a < g.length; a++) { var b = g[a]; document.body.contains(b.el[0]) || (g.splice(a, 1), b.ref.remove()) } }), window.FileAPI && window.FileAPI.ngfFixIE && window.FileAPI.ngfFixIE(b, w, m) } var g = []; return { restrict: "AEC", require: "?ngModel", link: function (e, g, h, i) { f(e, g, h, i, a, b, c, d) } } }]), function () { function a(a) { return "img" === a.tagName.toLowerCase() ? "image" : "audio" === a.tagName.toLowerCase() ? "audio" : "video" === a.tagName.toLowerCase() ? "video" : /./ } function b(b, c, d, e, f, g, h, i) { function j(a) { var g = b.attrGetter("ngfNoObjectUrl", f, d); b.dataUrl(a, g)["finally"](function () { c(function () { var b = (g ? a.$ngfDataUrl : a.$ngfBlobUrl) || a.$ngfDataUrl; i ? e.css("background-image", "url('" + (b || "") + "')") : e.attr("src", b), b ? e.removeClass("ng-hide") : e.addClass("ng-hide") }) }) } c(function () { var c = d.$watch(f[g], function (c) { var d = h; if ("ngfThumbnail" === g && (d || (d = { width: e[0].clientWidth, height: e[0].clientHeight }), 0 === d.width && window.getComputedStyle)) { var f = getComputedStyle(e[0]); d = { width: parseInt(f.width.slice(0, -2)), height: parseInt(f.height.slice(0, -2)) } } return angular.isString(c) ? (e.removeClass("ng-hide"), i ? e.css("background-image", "url('" + c + "')") : e.attr("src", c)) : void (!c || !c.type || 0 !== c.type.search(a(e[0])) || i && 0 !== c.type.indexOf("image") ? e.addClass("ng-hide") : d && b.isResizeSupported() ? b.resize(c, d.width, d.height, d.quality).then(function (a) { j(a) }, function (a) { throw a }) : j(c)) }); d.$on("$destroy", function () { c() }) }) } ngFileUpload.service("UploadDataUrl", ["UploadBase", "$timeout", "$q", function (a, b, c) { var d = a; return d.base64DataUrl = function (a) { if (angular.isArray(a)) { var b = c.defer(), e = 0; return angular.forEach(a, function (c) { d.dataUrl(c, !0)["finally"](function () { if (e++, e === a.length) { var c = []; angular.forEach(a, function (a) { c.push(a.$ngfDataUrl) }), b.resolve(c, a) } }) }), b.promise } return d.dataUrl(a, !0) }, d.dataUrl = function (a, e) { if (!a) return d.emptyPromise(a, a); if (e && null != a.$ngfDataUrl || !e && null != a.$ngfBlobUrl) return d.emptyPromise(e ? a.$ngfDataUrl : a.$ngfBlobUrl, a); var f = e ? a.$$ngfDataUrlPromise : a.$$ngfBlobUrlPromise; if (f) return f; var g = c.defer(); return b(function () { if (window.FileReader && a && (!window.FileAPI || -1 === navigator.userAgent.indexOf("MSIE 8") || a.size < 2e4) && (!window.FileAPI || -1 === navigator.userAgent.indexOf("MSIE 9") || a.size < 4e6)) { var c = window.URL || window.webkitURL; if (c && c.createObjectURL && !e) { var f; try { f = c.createObjectURL(a) } catch (h) { return void b(function () { a.$ngfBlobUrl = "", g.reject() }) } b(function () { if (a.$ngfBlobUrl = f, f) { g.resolve(f, a), d.blobUrls = d.blobUrls || [], d.blobUrlsTotalSize = d.blobUrlsTotalSize || 0, d.blobUrls.push({ url: f, size: a.size }), d.blobUrlsTotalSize += a.size || 0; for (var b = d.defaults.blobUrlsMaxMemory || 268435456, e = d.defaults.blobUrlsMaxQueueSize || 200; (d.blobUrlsTotalSize > b || d.blobUrls.length > e) && d.blobUrls.length > 1;) { var h = d.blobUrls.splice(0, 1)[0]; c.revokeObjectURL(h.url), d.blobUrlsTotalSize -= h.size } } }) } else { var i = new FileReader; i.onload = function (c) { b(function () { a.$ngfDataUrl = c.target.result, g.resolve(c.target.result, a), b(function () { delete a.$ngfDataUrl }, 1e3) }) }, i.onerror = function () { b(function () { a.$ngfDataUrl = "", g.reject() }) }, i.readAsDataURL(a) } } else b(function () { a[e ? "$ngfDataUrl" : "$ngfBlobUrl"] = "", g.reject() }) }), f = e ? a.$$ngfDataUrlPromise = g.promise : a.$$ngfBlobUrlPromise = g.promise, f["finally"](function () { delete a[e ? "$$ngfDataUrlPromise" : "$$ngfBlobUrlPromise"] }), f }, d }]), ngFileUpload.directive("ngfSrc", ["Upload", "$timeout", function (a, c) { return { restrict: "AE", link: function (d, e, f) { b(a, c, d, e, f, "ngfSrc", a.attrGetter("ngfResize", f, d), !1) } } }]), ngFileUpload.directive("ngfBackground", ["Upload", "$timeout", function (a, c) { return { restrict: "AE", link: function (d, e, f) { b(a, c, d, e, f, "ngfBackground", a.attrGetter("ngfResize", f, d), !0) } } }]), ngFileUpload.directive("ngfThumbnail", ["Upload", "$timeout", function (a, c) { return { restrict: "AE", link: function (d, e, f) { var g = a.attrGetter("ngfSize", f, d); b(a, c, d, e, f, "ngfThumbnail", g, a.attrGetter("ngfAsBackground", f, d)) } } }]), ngFileUpload.config(["$compileProvider", function (a) { a.imgSrcSanitizationWhitelist && a.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/), a.aHrefSanitizationWhitelist && a.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/) }]), ngFileUpload.filter("ngfDataUrl", ["UploadDataUrl", "$sce", function (a, b) { return function (c, d, e) { if (angular.isString(c)) return b.trustAsResourceUrl(c); var f = c && ((d ? c.$ngfDataUrl : c.$ngfBlobUrl) || c.$ngfDataUrl); return c && !f ? (!c.$ngfDataUrlFilterInProgress && angular.isObject(c) && (c.$ngfDataUrlFilterInProgress = !0, a.dataUrl(c, d)), "") : (c && delete c.$ngfDataUrlFilterInProgress, (c && f ? e ? b.trustAsResourceUrl(f) : f : c) || "") } }]) }(), ngFileUpload.service("UploadValidate", ["UploadDataUrl", "$q", "$timeout", function (a, b, c) {
    function d(a) { var b = "", c = []; if (a.length > 2 && "/" === a[0] && "/" === a[a.length - 1]) b = a.substring(1, a.length - 1); else { var e = a.split(","); if (e.length > 1) for (var f = 0; f < e.length; f++) { var g = d(e[f]); g.regexp ? (b += "(" + g.regexp + ")", f < e.length - 1 && (b += "|")) : c = c.concat(g.excludes) } else 0 === a.indexOf("!") ? c.push("^((?!" + d(a.substring(1)).regexp + ").)*$") : (0 === a.indexOf(".") && (a = "*" + a), b = "^" + a.replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]", "g"), "\\$&") + "$", b = b.replace(/\\\*/g, ".*").replace(/\\\?/g, ".")) } return { regexp: b, excludes: c } } function e(a, b) { null == b || a.$dirty || (a.$setDirty ? a.$setDirty() : a.$dirty = !0) } var f = a; return f.validatePattern = function (a, b) { if (!b) return !0; var c = d(b), e = !0; if (c.regexp && c.regexp.length) { var f = new RegExp(c.regexp, "i"); e = null != a.type && f.test(a.type) || null != a.name && f.test(a.name) } for (var g = c.excludes.length; g--;) { var h = new RegExp(c.excludes[g], "i"); e = e && (null == a.type || h.test(a.type)) && (null == a.name || h.test(a.name)) } return e }, f.ratioToFloat = function (a) { var b = a.toString(), c = b.search(/[x:]/i); return b = c > -1 ? parseFloat(b.substring(0, c)) / parseFloat(b.substring(c + 1)) : parseFloat(b) }, f.registerModelChangeValidator = function (a, b, c) { a && a.$formatters.push(function (d) { a.$dirty && (d && !angular.isArray(d) && (d = [d]), f.validate(d, d ? d.length : 0, a, b, c).then(function () { f.applyModelValidation(a, d) })) }) }, f.applyModelValidation = function (a, b) { e(a, b), angular.forEach(a.$ngfValidations, function (b) { a.$setValidity(b.name, b.valid) }) }, f.getValidationAttr = function (a, b, c, d, e) { var g = "ngf" + c[0].toUpperCase() + c.substr(1), h = f.attrGetter(g, a, b, { $file: e }); if (null == h && (h = f.attrGetter("ngfValidate", a, b, { $file: e }))) { var i = (d || c).split("."); h = h[i[0]], i.length > 1 && (h = h && h[i[1]]) } return h }, f.validate = function (a, c, d, e, g) { function h(b, c, h) { if (a) { for (var i = a.length, j = null; i--;) { var k = a[i]; if (k) { var l = f.getValidationAttr(e, g, b, c, k); null != l && (h(k, l) || (k.$error = b, (k.$errorMessages = k.$errorMessages || {}).name = !0, k.$errorParam = l, a.splice(i, 1), j = !1)) } } null !== j && d.$ngfValidations.push({ name: b, valid: j }) } } function i(c, h, i, k, l) { function m(a, b, d) { null != d ? k(b, d).then(function (e) { l(e, d) ? a.resolve() : (b.$error = c, (b.$errorMessages = b.$errorMessages || {}).name = !0, b.$errorParam = d, a.reject()) }, function () { j("ngfValidateForce", { $file: b }) ? (b.$error = c, (b.$errorMessages = b.$errorMessages || {}).name = !0, b.$errorParam = d, a.reject()) : a.resolve() }) : a.resolve() } var n = [f.emptyPromise()]; return a ? (a = void 0 === a.length ? [a] : a, angular.forEach(a, function (a) { var d = b.defer(); return n.push(d.promise), !i || null != a.type && 0 === a.type.search(i) ? void ("dimensions" === c && null != f.attrGetter("ngfDimensions", e) ? f.imageDimensions(a).then(function (b) { m(d, a, j("ngfDimensions", { $file: a, $width: b.width, $height: b.height })) }, function () { d.reject() }) : "duration" === c && null != f.attrGetter("ngfDuration", e) ? f.mediaDuration(a).then(function (b) { m(d, a, j("ngfDuration", { $file: a, $duration: b })) }, function () { d.reject() }) : m(d, a, f.getValidationAttr(e, g, c, h, a))) : void d.resolve() }), b.all(n).then(function () { d.$ngfValidations.push({ name: c, valid: !0 }) }, function () { d.$ngfValidations.push({ name: c, valid: !1 }) })) : void 0 } d = d || {}, d.$ngfValidations = d.$ngfValidations || [], angular.forEach(d.$ngfValidations, function (a) { a.valid = !0 }); var j = function (a, b) { return f.attrGetter(a, e, g, b) }; if (null == a || 0 === a.length) return f.emptyPromise(d); a = void 0 === a.length ? [a] : a.slice(0), h("maxFiles", null, function (a, b) { return b >= c }), h("pattern", null, f.validatePattern), h("minSize", "size.min", function (a, b) { return a.size + .1 >= f.translateScalars(b) }), h("maxSize", "size.max", function (a, b) { return a.size - .1 <= f.translateScalars(b) }); var k = 0; if (h("maxTotalSize", null, function (b, c) { return k += b.size, k > f.translateScalars(c) ? (a.splice(0, a.length), !1) : !0 }), h("validateFn", null, function (a, b) { return b === !0 || null === b || "" === b }), !a.length) return f.emptyPromise(d, d.$ngfValidations); var l = b.defer(), m = []; return m.push(f.happyPromise(i("maxHeight", "height.max", /image/, this.imageDimensions, function (a, b) { return a.height <= b }))), m.push(f.happyPromise(i("minHeight", "height.min", /image/, this.imageDimensions, function (a, b) { return a.height >= b }))), m.push(f.happyPromise(i("maxWidth", "width.max", /image/, this.imageDimensions, function (a, b) { return a.width <= b }))), m.push(f.happyPromise(i("minWidth", "width.min", /image/, this.imageDimensions, function (a, b) { return a.width >= b }))), m.push(f.happyPromise(i("dimensions", null, /image/, function (a, b) { return f.emptyPromise(b) }, function (a) { return a }))), m.push(f.happyPromise(i("ratio", null, /image/, this.imageDimensions, function (a, b) { for (var c = b.toString().split(","), d = !1, e = 0; e < c.length; e++) Math.abs(a.width / a.height - f.ratioToFloat(c[e])) < 1e-4 && (d = !0); return d }))), m.push(f.happyPromise(i("maxRatio", "ratio.max", /image/, this.imageDimensions, function (a, b) { return a.width / a.height - f.ratioToFloat(b) < 1e-4 }))), m.push(f.happyPromise(i("minRatio", "ratio.min", /image/, this.imageDimensions, function (a, b) { return a.width / a.height - f.ratioToFloat(b) > -1e-4 }))), m.push(f.happyPromise(i("maxDuration", "duration.max", /audio|video/, this.mediaDuration, function (a, b) { return a <= f.translateScalars(b) }))), m.push(f.happyPromise(i("minDuration", "duration.min", /audio|video/, this.mediaDuration, function (a, b) { return a >= f.translateScalars(b) }))), m.push(f.happyPromise(i("duration", null, /audio|video/, function (a, b) { return f.emptyPromise(b) }, function (a) { return a }))), m.push(f.happyPromise(i("validateAsyncFn", null, null, function (a, b) { return b }, function (a) { return a === !0 || null === a || "" === a }))), b.all(m).then(function () { l.resolve(d, d.$ngfValidations) }) }, f.imageDimensions = function (a) { if (a.$ngfWidth && a.$ngfHeight) { var d = b.defer(); return c(function () { d.resolve({ width: a.$ngfWidth, height: a.$ngfHeight }) }), d.promise } if (a.$ngfDimensionPromise) return a.$ngfDimensionPromise; var e = b.defer(); return c(function () { return 0 !== a.type.indexOf("image") ? void e.reject("not image") : void f.dataUrl(a).then(function (b) { function d() { var b = h[0].clientWidth, c = h[0].clientHeight; h.remove(), a.$ngfWidth = b, a.$ngfHeight = c, e.resolve({ width: b, height: c }) } function f() { h.remove(), e.reject("load error") } function g() { c(function () { h[0].parentNode && (h[0].clientWidth ? d() : i > 10 ? f() : g()) }, 1e3) } var h = angular.element("<img>").attr("src", b).css("visibility", "hidden").css("position", "fixed"); h.on("load", d), h.on("error", f); var i = 0; g(), angular.element(document.getElementsByTagName("body")[0]).append(h) }, function () { e.reject("load error") }) }), a.$ngfDimensionPromise = e.promise, a.$ngfDimensionPromise["finally"](function () { delete a.$ngfDimensionPromise }), a.$ngfDimensionPromise }, f.mediaDuration = function (a) {
        if (a.$ngfDuration) { var d = b.defer(); return c(function () { d.resolve(a.$ngfDuration) }), d.promise } if (a.$ngfDurationPromise) return a.$ngfDurationPromise; var e = b.defer(); return c(function () {
            return 0 !== a.type.indexOf("audio") && 0 !== a.type.indexOf("video") ? void e.reject("not media") : void f.dataUrl(a).then(function (b) {
                function d() { var b = h[0].duration; a.$ngfDuration = b, h.remove(), e.resolve(b) } function f() { h.remove(), e.reject("load error") } function g() { c(function () { h[0].parentNode && (h[0].duration ? d() : i > 10 ? f() : g()) }, 1e3) } var h = angular.element(0 === a.type.indexOf("audio") ? "<audio>" : "<video>").attr("src", b).css("visibility", "none").css("position", "fixed");

                h.on("loadedmetadata", d), h.on("error", f); var i = 0; g(), angular.element(document.body).append(h)
            }, function () { e.reject("load error") })
        }), a.$ngfDurationPromise = e.promise, a.$ngfDurationPromise["finally"](function () { delete a.$ngfDurationPromise }), a.$ngfDurationPromise
    }, f
}]), ngFileUpload.service("UploadResize", ["UploadValidate", "$q", function (a, b) { var c = a, d = function (a, b, c, d, e) { var f = e ? Math.max(c / a, d / b) : Math.min(c / a, d / b); return { width: a * f, height: b * f, marginX: a * f - c, marginY: b * f - d } }, e = function (a, e, f, g, h, i, j, k) { var l = b.defer(), m = document.createElement("canvas"), n = document.createElement("img"); return n.onload = function () { if (null != k && k(n.width, n.height) === !1) return void l.reject("resizeIf"); try { if (i) { var a = c.ratioToFloat(i), b = n.width / n.height; a > b ? (e = n.width, f = e / a) : (f = n.height, e = f * a) } e || (e = n.width), f || (f = n.height); var o = d(n.width, n.height, e, f, j); m.width = Math.min(o.width, e), m.height = Math.min(o.height, f); var p = m.getContext("2d"); p.drawImage(n, Math.min(0, -o.marginX / 2), Math.min(0, -o.marginY / 2), o.width, o.height), l.resolve(m.toDataURL(h || "image/WebP", g || .934)) } catch (q) { l.reject(q) } }, n.onerror = function () { l.reject() }, n.src = a, l.promise }; return c.dataUrltoBlob = function (a, b, c) { for (var d = a.split(","), e = d[0].match(/:(.*?);/)[1], f = atob(d[1]), g = f.length, h = new Uint8Array(g) ; g--;) h[g] = f.charCodeAt(g); var i = new window.Blob([h], { type: e }); return i.name = b, i.$ngfOrigSize = c, i }, c.isResizeSupported = function () { var a = document.createElement("canvas"); return window.atob && a.getContext && a.getContext("2d") && window.Blob }, c.isResizeSupported() && Object.defineProperty(window.Blob.prototype, "name", { get: function () { return this.$ngfName }, set: function (a) { this.$ngfName = a }, configurable: !0 }), c.resize = function (a, d, f, g, h, i, j, k, l) { if (0 !== a.type.indexOf("image")) return c.emptyPromise(a); var m = b.defer(); return c.dataUrl(a, !0).then(function (b) { e(b, d, f, g, h || a.type, i, j, k).then(function (d) { if ("image/jpeg" === a.type && l) try { d = c.restoreExif(b, d) } catch (e) { setTimeout(function () { throw e }, 1) } m.resolve(c.dataUrltoBlob(d, a.name, a.size)) }, function (b) { "resizeIf" === b && m.resolve(a), m.reject() }) }, function () { m.reject() }), m.promise }, c }]), function () { function a(a, c, d, e, f, g, h, i, j, k) { function l() { return c.attr("disabled") || r("ngfDropDisabled", a) } function m(b, c) { i.updateModel(e, d, a, r("ngfChange") || r("ngfDrop"), b, c) } function n(b, c) { if (!i.shouldUpdateOn(b, d, a) || !c) return i.rejectPromise([]); var e = []; c.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi, function (a, b, c) { e.push(c) }); var f = [], g = []; if (e.length) { angular.forEach(e, function (a) { f.push(i.urlToBlob(a).then(function (a) { g.push(a) })) }); var h = k.defer(); return k.all(f).then(function () { h.resolve(g) }, function (a) { h.reject(a) }), h.promise } } function o(a, b, c, d) { var e = r("ngfDragOverClass", a, { $event: c }), f = "dragover"; if (angular.isString(e)) f = e; else if (e && (e.delay && (v = e.delay), e.accept || e.reject)) { var g = c.dataTransfer.items; if (null != g && g.length) for (var h = e.pattern || r("ngfPattern", a, { $event: c }), j = g.length; j--;) { if (!i.validatePattern(g[j], h)) { f = e.reject; break } f = e.accept } else f = e.accept } d(f) } function p(b, c, e, f) { function g(a, b) { var c = k.defer(); if (null != a) if (a.isDirectory) { var d = [i.emptyPromise()]; if (m) { var e = { type: "directory" }; e.name = e.path = (b || "") + a.name + a.name, n.push(e) } var f = a.createReader(), h = [], p = function () { f.readEntries(function (e) { try { e.length ? (h = h.concat(Array.prototype.slice.call(e || [], 0)), p()) : (angular.forEach(h.slice(0), function (c) { n.length <= j && l >= o && d.push(g(c, (b ? b : "") + a.name + "/")) }), k.all(d).then(function () { c.resolve() }, function (a) { c.reject(a) })) } catch (f) { c.reject(f) } }, function (a) { c.reject(a) }) }; p() } else a.file(function (a) { try { a.path = (b ? b : "") + a.name, m && (a = i.rename(a, a.path)), n.push(a), o += a.size, c.resolve() } catch (d) { c.reject(d) } }, function (a) { c.reject(a) }); return c.promise } var j = i.getValidationAttr(d, a, "maxFiles") || Number.MAX_VALUE, l = i.getValidationAttr(d, a, "maxTotalSize") || Number.MAX_VALUE, m = r("ngfIncludeDir", a), n = [], o = 0, p = [i.emptyPromise()]; if (b && b.length > 0 && "file" !== h.protocol()) for (var q = 0; q < b.length; q++) { if (b[q].webkitGetAsEntry && b[q].webkitGetAsEntry() && b[q].webkitGetAsEntry().isDirectory) { var s = b[q].webkitGetAsEntry(); if (s.isDirectory && !e) continue; null != s && p.push(g(s)) } else { var t = b[q].getAsFile(); null != t && (n.push(t), o += t.size) } if (n.length > j || o > l || !f && n.length > 0) break } else if (null != c) for (var u = 0; u < c.length; u++) { var v = c.item(u); if ((v.type || v.size > 0) && (n.push(v), o += v.size), n.length > j || o > l || !f && n.length > 0) break } var w = k.defer(); return k.all(p).then(function () { if (f || m) w.resolve(n); else { for (var a = 0; n[a] && "directory" === n[a].type;) a++; w.resolve([n[a]]) } }, function (a) { w.reject(a) }), w.promise } var q = b(), r = function (a, b, c) { return i.attrGetter(a, d, b, c) }; if (r("dropAvailable") && g(function () { a[r("dropAvailable")] ? a[r("dropAvailable")].value = q : a[r("dropAvailable")] = q }), !q) return void (r("ngfHideOnDropNotAvailable", a) === !0 && c.css("display", "none")); null == r("ngfSelect") && i.registerModelChangeValidator(e, d, a); var s, t = null, u = f(r("ngfStopPropagation")), v = 1; c[0].addEventListener("dragover", function (b) { if (!l() && i.shouldUpdateOn("drop", d, a)) { if (b.preventDefault(), u(a) && b.stopPropagation(), navigator.userAgent.indexOf("Chrome") > -1) { var e = b.dataTransfer.effectAllowed; b.dataTransfer.dropEffect = "move" === e || "linkMove" === e ? "move" : "copy" } g.cancel(t), s || (s = "C", o(a, d, b, function (d) { s = d, c.addClass(s), r("ngfDrag", a, { $isDragging: !0, $class: s, $event: b }) })) } }, !1), c[0].addEventListener("dragenter", function (b) { !l() && i.shouldUpdateOn("drop", d, a) && (b.preventDefault(), u(a) && b.stopPropagation()) }, !1), c[0].addEventListener("dragleave", function (b) { !l() && i.shouldUpdateOn("drop", d, a) && (b.preventDefault(), u(a) && b.stopPropagation(), t = g(function () { s && c.removeClass(s), s = null, r("ngfDrag", a, { $isDragging: !1, $event: b }) }, v || 100)) }, !1), c[0].addEventListener("drop", function (b) { if (!l() && i.shouldUpdateOn("drop", d, a)) { b.preventDefault(), u(a) && b.stopPropagation(), s && c.removeClass(s), s = null; var e, f = b.dataTransfer.items; try { e = b.dataTransfer && b.dataTransfer.getData && b.dataTransfer.getData("text/html") } catch (g) { } p(f, b.dataTransfer.files, r("ngfAllowDir", a) !== !1, r("multiple") || r("ngfMultiple", a)).then(function (a) { a.length ? m(a, b) : n("dropUrl", e).then(function (a) { m(a, b) }) }) } }, !1), c[0].addEventListener("paste", function (b) { if (navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && r("ngfEnableFirefoxPaste", a) && b.preventDefault(), !l() && i.shouldUpdateOn("paste", d, a)) { var c = [], e = b.clipboardData || b.originalEvent.clipboardData; if (e && e.items) for (var f = 0; f < e.items.length; f++) -1 !== e.items[f].type.indexOf("image") && c.push(e.items[f].getAsFile()); c.length ? m(c, b) : n("pasteUrl", e).then(function (a) { m(a, b) }) } }, !1), navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && r("ngfEnableFirefoxPaste", a) && (c.attr("contenteditable", !0), c.on("keypress", function (a) { a.metaKey || a.ctrlKey || a.preventDefault() })) } function b() { var a = document.createElement("div"); return "draggable" in a && "ondrop" in a && !/Edge\/12./i.test(navigator.userAgent) } ngFileUpload.directive("ngfDrop", ["$parse", "$timeout", "$location", "Upload", "$http", "$q", function (b, c, d, e, f, g) { return { restrict: "AEC", require: "?ngModel", link: function (h, i, j, k) { a(h, i, j, k, b, c, d, e, f, g) } } }]), ngFileUpload.directive("ngfNoFileDrop", function () { return function (a, c) { b() && c.css("display", "none") } }), ngFileUpload.directive("ngfDropAvailable", ["$parse", "$timeout", "Upload", function (a, c, d) { return function (e, f, g) { if (b()) { var h = a(d.attrGetter("ngfDropAvailable", g)); c(function () { h(e), h.assign && h.assign(e, !0) }) } } }]) }(), ngFileUpload.service("UploadExif", ["UploadResize", "$q", function (a, b) { function c(a, b, c, d) { switch (b) { case 2: return a.transform(-1, 0, 0, 1, c, 0); case 3: return a.transform(-1, 0, 0, -1, c, d); case 4: return a.transform(1, 0, 0, -1, 0, d); case 5: return a.transform(0, 1, 1, 0, 0, 0); case 6: return a.transform(0, 1, -1, 0, d, 0); case 7: return a.transform(0, -1, -1, 0, d, c); case 8: return a.transform(0, -1, 1, 0, 0, c) } } function d(a) { for (var b = "", c = new Uint8Array(a), d = c.byteLength, e = 0; d > e; e++) b += String.fromCharCode(c[e]); return window.btoa(b) } var e = a; return e.isExifSupported = function () { return window.FileReader && (new FileReader).readAsArrayBuffer && e.isResizeSupported() }, e.readOrientation = function (a) { var c = b.defer(), d = new FileReader, e = a.slice(0, 65536); return d.readAsArrayBuffer(e), d.onerror = function (a) { return c.reject(a) }, d.onload = function (a) { var b = { orientation: 1 }, d = new DataView(this.result); if (65496 !== d.getUint16(0, !1)) return c.resolve(b); for (var e = d.byteLength, f = 2; e > f;) { var g = d.getUint16(f, !1); if (f += 2, 65505 === g) { if (1165519206 !== d.getUint32(f += 2, !1)) return c.resolve(b); var h = 18761 === d.getUint16(f += 6, !1); f += d.getUint32(f + 4, h); var i = d.getUint16(f, h); f += 2; for (var j = 0; i > j; j++) if (274 === d.getUint16(f + 12 * j, h)) { var k = d.getUint16(f + 12 * j + 8, h); return k >= 2 && 8 >= k && (d.setUint16(f + 12 * j + 8, 1, h), b.fixedArrayBuffer = a.target.result), b.orientation = k, c.resolve(b) } } else { if (65280 !== (65280 & g)) break; f += d.getUint16(f, !1) } } return c.resolve(b) }, c.promise }, e.applyExifRotation = function (a) { if (0 !== a.type.indexOf("image/jpeg")) return e.emptyPromise(a); var f = b.defer(); return e.readOrientation(a).then(function (b) { return b.orientation < 2 || b.orientation > 8 ? f.resolve(a) : void e.dataUrl(a, !0).then(function (g) { var h = document.createElement("canvas"), i = document.createElement("img"); i.onload = function () { try { h.width = b.orientation > 4 ? i.height : i.width, h.height = b.orientation > 4 ? i.width : i.height; var g = h.getContext("2d"); c(g, b.orientation, i.width, i.height), g.drawImage(i, 0, 0); var j = h.toDataURL(a.type || "image/WebP", .934); j = e.restoreExif(d(b.fixedArrayBuffer), j); var k = e.dataUrltoBlob(j, a.name); f.resolve(k) } catch (l) { return f.reject(l) } }, i.onerror = function () { f.reject() }, i.src = g }, function (a) { f.reject(a) }) }, function (a) { f.reject(a) }), f.promise }, e.restoreExif = function (a, b) { var c = {}; return c.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", c.encode64 = function (a) { var b, c, d, e, f, g = "", h = "", i = "", j = 0; do b = a[j++], c = a[j++], h = a[j++], d = b >> 2, e = (3 & b) << 4 | c >> 4, f = (15 & c) << 2 | h >> 6, i = 63 & h, isNaN(c) ? f = i = 64 : isNaN(h) && (i = 64), g = g + this.KEY_STR.charAt(d) + this.KEY_STR.charAt(e) + this.KEY_STR.charAt(f) + this.KEY_STR.charAt(i), b = c = h = "", d = e = f = i = ""; while (j < a.length); return g }, c.restore = function (a, b) { a.match("data:image/jpeg;base64,") && (a = a.replace("data:image/jpeg;base64,", "")); var c = this.decode64(a), d = this.slice2Segments(c), e = this.exifManipulation(b, d); return "data:image/jpeg;base64," + this.encode64(e) }, c.exifManipulation = function (a, b) { var c = this.getExifArray(b), d = this.insertExif(a, c); return new Uint8Array(d) }, c.getExifArray = function (a) { for (var b, c = 0; c < a.length; c++) if (b = a[c], 255 === b[0] & 225 === b[1]) return b; return [] }, c.insertExif = function (a, b) { var c = a.replace("data:image/jpeg;base64,", ""), d = this.decode64(c), e = d.indexOf(255, 3), f = d.slice(0, e), g = d.slice(e), h = f; return h = h.concat(b), h = h.concat(g) }, c.slice2Segments = function (a) { for (var b = 0, c = []; ;) { if (255 === a[b] & 218 === a[b + 1]) break; if (255 === a[b] & 216 === a[b + 1]) b += 2; else { var d = 256 * a[b + 2] + a[b + 3], e = b + d + 2, f = a.slice(b, e); c.push(f), b = e } if (b > a.length) break } return c }, c.decode64 = function (a) { var b, c, d, e, f, g = "", h = "", i = 0, j = [], k = /[^A-Za-z0-9\+\/\=]/g; k.exec(a) && console.log("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, NaNExpect errors in decoding."), a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); do d = this.KEY_STR.indexOf(a.charAt(i++)), e = this.KEY_STR.indexOf(a.charAt(i++)), f = this.KEY_STR.indexOf(a.charAt(i++)), h = this.KEY_STR.indexOf(a.charAt(i++)), b = d << 2 | e >> 4, c = (15 & e) << 4 | f >> 2, g = (3 & f) << 6 | h, j.push(b), 64 !== f && j.push(c), 64 !== h && j.push(g), b = c = g = "", d = e = f = h = ""; while (i < a.length); return j }, c.restore(a, b) }, e }]);
/*! 12.0.1 */
!function () { function a(a, b) { window.XMLHttpRequest.prototype[a] = b(window.XMLHttpRequest.prototype[a]) } function b(a, b, c) { try { Object.defineProperty(a, b, { get: c }) } catch (d) { } } if (window.FileAPI || (window.FileAPI = {}), !window.XMLHttpRequest) throw "AJAX is not supported. XMLHttpRequest is not defined."; if (FileAPI.shouldLoad = !window.FormData || FileAPI.forceLoad, FileAPI.shouldLoad) { var c = function (a) { if (!a.__listeners) { a.upload || (a.upload = {}), a.__listeners = []; var b = a.upload.addEventListener; a.upload.addEventListener = function (c, d) { a.__listeners[c] = d, b && b.apply(this, arguments) } } }; a("open", function (a) { return function (b, d, e) { c(this), this.__url = d; try { a.apply(this, [b, d, e]) } catch (f) { f.message.indexOf("Access is denied") > -1 && (this.__origError = f, a.apply(this, [b, "_fix_for_ie_crossdomain__", e])) } } }), a("getResponseHeader", function (a) { return function (b) { return this.__fileApiXHR && this.__fileApiXHR.getResponseHeader ? this.__fileApiXHR.getResponseHeader(b) : null == a ? null : a.apply(this, [b]) } }), a("getAllResponseHeaders", function (a) { return function () { return this.__fileApiXHR && this.__fileApiXHR.getAllResponseHeaders ? this.__fileApiXHR.getAllResponseHeaders() : null == a ? null : a.apply(this) } }), a("abort", function (a) { return function () { return this.__fileApiXHR && this.__fileApiXHR.abort ? this.__fileApiXHR.abort() : null == a ? null : a.apply(this) } }), a("setRequestHeader", function (a) { return function (b, d) { if ("__setXHR_" === b) { c(this); var e = d(this); e instanceof Function && e(this) } else this.__requestHeaders = this.__requestHeaders || {}, this.__requestHeaders[b] = d, a.apply(this, arguments) } }), a("send", function (a) { return function () { var c = this; if (arguments[0] && arguments[0].__isFileAPIShim) { var d = arguments[0], e = { url: c.__url, jsonp: !1, cache: !0, complete: function (a, d) { a && angular.isString(a) && -1 !== a.indexOf("#2174") && (a = null), c.__completed = !0, !a && c.__listeners.load && c.__listeners.load({ type: "load", loaded: c.__loaded, total: c.__total, target: c, lengthComputable: !0 }), !a && c.__listeners.loadend && c.__listeners.loadend({ type: "loadend", loaded: c.__loaded, total: c.__total, target: c, lengthComputable: !0 }), "abort" === a && c.__listeners.abort && c.__listeners.abort({ type: "abort", loaded: c.__loaded, total: c.__total, target: c, lengthComputable: !0 }), void 0 !== d.status && b(c, "status", function () { return 0 === d.status && a && "abort" !== a ? 500 : d.status }), void 0 !== d.statusText && b(c, "statusText", function () { return d.statusText }), b(c, "readyState", function () { return 4 }), void 0 !== d.response && b(c, "response", function () { return d.response }); var e = d.responseText || (a && 0 === d.status && "abort" !== a ? a : void 0); b(c, "responseText", function () { return e }), b(c, "response", function () { return e }), a && b(c, "err", function () { return a }), c.__fileApiXHR = d, c.onreadystatechange && c.onreadystatechange(), c.onload && c.onload() }, progress: function (a) { if (a.target = c, c.__listeners.progress && c.__listeners.progress(a), c.__total = a.total, c.__loaded = a.loaded, a.total === a.loaded) { var b = this; setTimeout(function () { c.__completed || (c.getAllResponseHeaders = function () { }, b.complete(null, { status: 204, statusText: "No Content" })) }, FileAPI.noContentTimeout || 1e4) } }, headers: c.__requestHeaders }; e.data = {}, e.files = {}; for (var f = 0; f < d.data.length; f++) { var g = d.data[f]; null != g.val && null != g.val.name && null != g.val.size && null != g.val.type ? e.files[g.key] = g.val : e.data[g.key] = g.val } setTimeout(function () { if (!FileAPI.hasFlash) throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"'; c.__fileApiXHR = FileAPI.upload(e) }, 1) } else { if (this.__origError) throw this.__origError; a.apply(c, arguments) } } }), window.XMLHttpRequest.__isFileAPIShim = !0, window.FormData = FormData = function () { return { append: function (a, b, c) { b.__isFileAPIBlobShim && (b = b.data[0]), this.data.push({ key: a, val: b, name: c }) }, data: [], __isFileAPIShim: !0 } }, window.Blob = Blob = function (a) { return { data: a, __isFileAPIBlobShim: !0 } } } }(), function () { function a(a) { return "input" === a[0].tagName.toLowerCase() && a.attr("type") && "file" === a.attr("type").toLowerCase() } function b() { try { var a = new ActiveXObject("ShockwaveFlash.ShockwaveFlash"); if (a) return !0 } catch (b) { if (void 0 !== navigator.mimeTypes["application/x-shockwave-flash"]) return !0 } return !1 } function c(a) { var b = 0, c = 0; if (window.jQuery) return jQuery(a).offset(); if (a.offsetParent) do b += a.offsetLeft - a.scrollLeft, c += a.offsetTop - a.scrollTop, a = a.offsetParent; while (a); return { left: b, top: c } } if (FileAPI.shouldLoad) { if (FileAPI.hasFlash = b(), FileAPI.forceLoad && (FileAPI.html5 = !1), !FileAPI.upload) { var d, e, f, g, h, i = document.createElement("script"), j = document.getElementsByTagName("script"); if (window.FileAPI.jsUrl) d = window.FileAPI.jsUrl; else if (window.FileAPI.jsPath) e = window.FileAPI.jsPath; else for (f = 0; f < j.length; f++) if (h = j[f].src, g = h.search(/\/ng\-file\-upload[\-a-zA-z0-9\.]*\.js/), g > -1) { e = h.substring(0, g + 1); break } null == FileAPI.staticPath && (FileAPI.staticPath = e), i.setAttribute("src", d || e + "FileAPI.min.js"), document.getElementsByTagName("head")[0].appendChild(i) } FileAPI.ngfFixIE = function (d, e, f) { if (!b()) throw 'Adode Flash Player need to be installed. To check ahead use "FileAPI.hasFlash"'; var g = function () { var b = e.parent(); d.attr("disabled") ? b && b.removeClass("js-fileapi-wrapper") : (e.attr("__ngf_flash_") || (e.unbind("change"), e.unbind("click"), e.bind("change", function (a) { h.apply(this, [a]), f.apply(this, [a]) }), e.attr("__ngf_flash_", "true")), b.addClass("js-fileapi-wrapper"), a(d) || (b.css("position", "absolute").css("top", c(d[0]).top + "px").css("left", c(d[0]).left + "px").css("width", d[0].offsetWidth + "px").css("height", d[0].offsetHeight + "px").css("filter", "alpha(opacity=0)").css("display", d.css("display")).css("overflow", "hidden").css("z-index", "900000").css("visibility", "visible"), e.css("width", d[0].offsetWidth + "px").css("height", d[0].offsetHeight + "px").css("position", "absolute").css("top", "0px").css("left", "0px"))) }; d.bind("mouseenter", g); var h = function (a) { for (var b = FileAPI.getFiles(a), c = 0; c < b.length; c++) void 0 === b[c].size && (b[c].size = 0), void 0 === b[c].name && (b[c].name = "file"), void 0 === b[c].type && (b[c].type = "undefined"); a.target || (a.target = {}), a.target.files = b, a.target.files !== b && (a.__files_ = b), (a.__files_ || a.target.files).item = function (b) { return (a.__files_ || a.target.files)[b] || null } } }, FileAPI.disableFileInput = function (a, b) { b ? a.removeClass("js-fileapi-wrapper") : a.addClass("js-fileapi-wrapper") } } }(), window.FileReader || (window.FileReader = function () { var a = this, b = !1; this.listeners = {}, this.addEventListener = function (b, c) { a.listeners[b] = a.listeners[b] || [], a.listeners[b].push(c) }, this.removeEventListener = function (b, c) { a.listeners[b] && a.listeners[b].splice(a.listeners[b].indexOf(c), 1) }, this.dispatchEvent = function (b) { var c = a.listeners[b.type]; if (c) for (var d = 0; d < c.length; d++) c[d].call(a, b) }, this.onabort = this.onerror = this.onload = this.onloadstart = this.onloadend = this.onprogress = null; var c = function (b, c) { var d = { type: b, target: a, loaded: c.loaded, total: c.total, error: c.error }; return null != c.result && (d.target.result = c.result), d }, d = function (d) { b || (b = !0, a.onloadstart && a.onloadstart(c("loadstart", d))); var e; "load" === d.type ? (a.onloadend && a.onloadend(c("loadend", d)), e = c("load", d), a.onload && a.onload(e), a.dispatchEvent(e)) : "progress" === d.type ? (e = c("progress", d), a.onprogress && a.onprogress(e), a.dispatchEvent(e)) : (e = c("error", d), a.onerror && a.onerror(e), a.dispatchEvent(e)) }; this.readAsDataURL = function (a) { FileAPI.readAsDataURL(a, d) }, this.readAsText = function (a) { FileAPI.readAsText(a, d) } });
/*! 12.0.1 */
!window.XMLHttpRequest || window.FileAPI && FileAPI.shouldLoad || (window.XMLHttpRequest.prototype.setRequestHeader = function (a) { return function (b, c) { if ("__setXHR_" === b) { var d = c(this); d instanceof Function && d(this) } else a.apply(this, arguments) } }(window.XMLHttpRequest.prototype.setRequestHeader)); var ngFileUpload = angular.module("ngFileUpload", []); ngFileUpload.version = "12.0.1", ngFileUpload.service("UploadBase", ["$http", "$q", "$timeout", function (a, b, c) { function d(d) { function e(a) { j.notify && j.notify(a), k.progressFunc && c(function () { k.progressFunc(a) }) } function h(a) { return null != d._start && g ? { loaded: a.loaded + d._start, total: d._file && d._file.size || a.total, type: a.type, config: d, lengthComputable: !0, target: a.target } : a } function i() { a(d).then(function (a) { g && d._chunkSize && !d._finished && d._file ? (e({ loaded: d._end, total: d._file && d._file.size, config: d, type: "progress" }), f.upload(d, !0)) : (d._finished && delete d._finished, j.resolve(a)) }, function (a) { j.reject(a) }, function (a) { j.notify(a) }) } d.method = d.method || "POST", d.headers = d.headers || {}; var j = d._deferred = d._deferred || b.defer(), k = j.promise; return d.disableProgress || (d.headers.__setXHR_ = function () { return function (a) { a && a.upload && a.upload.addEventListener && (d.__XHR = a, d.xhrFn && d.xhrFn(a), a.upload.addEventListener("progress", function (a) { a.config = d, e(h(a)) }, !1), a.upload.addEventListener("load", function (a) { a.lengthComputable && (a.config = d, e(h(a))) }, !1)) } }), g ? d._chunkSize && d._end && !d._finished ? (d._start = d._end, d._end += d._chunkSize, i()) : d.resumeSizeUrl ? a.get(d.resumeSizeUrl).then(function (a) { d._start = d.resumeSizeResponseReader ? d.resumeSizeResponseReader(a.data) : parseInt((null == a.data.size ? a.data : a.data.size).toString()), d._chunkSize && (d._end = d._start + d._chunkSize), i() }, function (a) { throw a }) : d.resumeSize ? d.resumeSize().then(function (a) { d._start = a, i() }, function (a) { throw a }) : (d._chunkSize && (d._start = 0, d._end = d._start + d._chunkSize), i()) : i(), k.success = function (a) { return k.then(function (b) { a(b.data, b.status, b.headers, d) }), k }, k.error = function (a) { return k.then(null, function (b) { a(b.data, b.status, b.headers, d) }), k }, k.progress = function (a) { return k.progressFunc = a, k.then(null, null, function (b) { a(b) }), k }, k.abort = k.pause = function () { return d.__XHR && c(function () { d.__XHR.abort() }), k }, k.xhr = function (a) { return d.xhrFn = function (b) { return function () { b && b.apply(k, arguments), a.apply(k, arguments) } }(d.xhrFn), k }, f.promisesCount++, k["finally"](function () { f.promisesCount-- }), k } function e(a) { var b = {}; for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]); return b } var f = this; f.promisesCount = 0, this.isResumeSupported = function () { return window.Blob && window.Blob instanceof Function && window.Blob.prototype.slice }; var g = this.isResumeSupported(); this.isUploadInProgress = function () { return f.promisesCount > 0 }, this.rename = function (a, b) { return a.ngfName = b, a }, this.jsonBlob = function (a) { null == a || angular.isString(a) || (a = JSON.stringify(a)); var b = new window.Blob([a], { type: "application/json" }); return b._ngfBlob = !0, b }, this.json = function (a) { return angular.toJson(a) }, this.isFile = function (a) { return null != a && (a instanceof window.Blob || a.flashId && a.name && a.size) }, this.upload = function (a, b) { function c(b, c) { if (b._ngfBlob) return b; if (a._file = a._file || b, null != a._start && g) { a._end && a._end >= b.size && (a._finished = !0, a._end = b.size); var d = b.slice(a._start, a._end || b.size); return d.name = b.name, d.ngfName = b.ngfName, a._chunkSize && (c.append("_chunkSize", a._chunkSize), c.append("_currentChunkSize", a._end - a._start), c.append("_chunkNumber", Math.floor(a._start / a._chunkSize)), c.append("_totalSize", a._file.size)), d } return b } function h(b, d, e) { if (void 0 !== d) if (angular.isDate(d) && (d = d.toISOString()), angular.isString(d)) b.append(e, d); else if (f.isFile(d)) { var g = c(d, b), i = e.split(","); i[1] && (g.ngfName = i[1].replace(/^\s+|\s+$/g, ""), e = i[0]), a._fileKey = a._fileKey || e, b.append(e, g, g.ngfName || g.name) } else if (angular.isObject(d)) { if (d.$$ngfCircularDetection) throw "ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: " + e; d.$$ngfCircularDetection = !0; try { for (var j in d) if (d.hasOwnProperty(j) && "$$ngfCircularDetection" !== j) { var k = null == a.objectKey ? "[i]" : a.objectKey; d.length && parseInt(j) > -1 && (k = null == a.arrayKey ? k : a.arrayKey), h(b, d[j], e + k.replace(/[ik]/g, j)) } } finally { delete d.$$ngfCircularDetection } } else b.append(e, d) } function i() { a._chunkSize = f.translateScalars(a.resumeChunkSize), a._chunkSize = a._chunkSize ? parseInt(a._chunkSize.toString()) : null, a.headers = a.headers || {}, a.headers["Content-Type"] = void 0, a.transformRequest = a.transformRequest ? angular.isArray(a.transformRequest) ? a.transformRequest : [a.transformRequest] : [], a.transformRequest.push(function (b) { var c, d = new window.FormData; b = b || a.fields || {}, a.file && (b.file = a.file); for (c in b) if (b.hasOwnProperty(c)) { var e = b[c]; a.formDataAppender ? a.formDataAppender(d, c, e) : h(d, e, c) } return d }) } return b || (a = e(a)), a._isDigested || (a._isDigested = !0, i()), d(a) }, this.http = function (b) { return b = e(b), b.transformRequest = b.transformRequest || function (b) { return window.ArrayBuffer && b instanceof window.ArrayBuffer || b instanceof window.Blob ? b : a.defaults.transformRequest[0].apply(this, arguments) }, b._chunkSize = f.translateScalars(b.resumeChunkSize), b._chunkSize = b._chunkSize ? parseInt(b._chunkSize.toString()) : null, d(b) }, this.translateScalars = function (a) { if (angular.isString(a)) { if (a.search(/kb/i) === a.length - 2) return parseFloat(1024 * a.substring(0, a.length - 2)); if (a.search(/mb/i) === a.length - 2) return parseFloat(1048576 * a.substring(0, a.length - 2)); if (a.search(/gb/i) === a.length - 2) return parseFloat(1073741824 * a.substring(0, a.length - 2)); if (a.search(/b/i) === a.length - 1) return parseFloat(a.substring(0, a.length - 1)); if (a.search(/s/i) === a.length - 1) return parseFloat(a.substring(0, a.length - 1)); if (a.search(/m/i) === a.length - 1) return parseFloat(60 * a.substring(0, a.length - 1)); if (a.search(/h/i) === a.length - 1) return parseFloat(3600 * a.substring(0, a.length - 1)) } return a }, this.urlToBlob = function (c) { var d = b.defer(); return a({ url: c, method: "get", responseType: "arraybuffer" }).then(function (a) { var b = new Uint8Array(a.data), c = a.headers("content-type") || "image/WebP", e = new window.Blob([b], { type: c }); d.resolve(e) }, function (a) { d.reject(a) }), d.promise }, this.setDefaults = function (a) { this.defaults = a || {} }, this.defaults = {}, this.version = ngFileUpload.version }]), ngFileUpload.service("Upload", ["$parse", "$timeout", "$compile", "$q", "UploadExif", function (a, b, c, d, e) { function f(a, b, c) { var e = [h.emptyPromise()]; return angular.forEach(a, function (d, f) { 0 === d.type.indexOf("image/jpeg") && h.attrGetter("ngfFixOrientation", b, c, { $file: d }) && e.push(h.happyPromise(h.applyExifRotation(d), d).then(function (b) { a.splice(f, 1, b) })) }), d.all(e) } function g(a, b, c) { function e(d, e) { if (0 === d.type.indexOf("image")) { if (f.pattern && !h.validatePattern(d, f.pattern)) return; var i = h.resize(d, f.width, f.height, f.quality, f.type, f.ratio, f.centerCrop, function (a, e) { return h.attrGetter("ngfResizeIf", b, c, { $width: a, $height: e, $file: d }) }, f.restoreExif !== !1); g.push(i), i.then(function (b) { a.splice(e, 1, b) }, function (a) { d.$error = "resize", d.$errorParam = (a ? (a.message ? a.message : a) + ": " : "") + (d && d.name) }) } } var f = h.attrGetter("ngfResize", b, c); if (!(f && angular.isObject(f) && h.isResizeSupported() && a.length)) return h.emptyPromise(); for (var g = [h.emptyPromise()], i = 0; i < a.length; i++) e(a[i], i); return d.all(g) } var h = e; return h.getAttrWithDefaults = function (a, b) { if (null != a[b]) return a[b]; var c = h.defaults[b]; return null == c ? c : angular.isString(c) ? c : JSON.stringify(c) }, h.attrGetter = function (b, c, d, e) { var f = this.getAttrWithDefaults(c, b); if (!d) return f; try { return e ? a(f)(d, e) : a(f)(d) } catch (g) { if (b.search(/min|max|pattern/i)) return f; throw g } }, h.shouldUpdateOn = function (a, b, c) { var d = h.attrGetter("ngModelOptions", b, c); return d && d.updateOn ? d.updateOn.split(" ").indexOf(a) > -1 : !0 }, h.emptyPromise = function () { var a = d.defer(), c = arguments; return b(function () { a.resolve.apply(a, c) }), a.promise }, h.rejectPromise = function () { var a = d.defer(), c = arguments; return b(function () { a.reject.apply(a, c) }), a.promise }, h.happyPromise = function (a, c) { var e = d.defer(); return a.then(function (a) { e.resolve(a) }, function (a) { b(function () { throw a }), e.resolve(c) }), e.promise }, h.updateModel = function (c, d, e, i, j, k, l) { function m(f, g, j, l, m) { d.$$ngfPrevValidFiles = f, d.$$ngfPrevInvalidFiles = g; var n = f && f.length ? f[0] : null, o = g && g.length ? g[0] : null; c && (h.applyModelValidation(c, f), c.$setViewValue(m ? n : f)), i && a(i)(e, { $files: f, $file: n, $newFiles: j, $duplicateFiles: l, $invalidFiles: g, $invalidFile: o, $event: k }); var p = h.attrGetter("ngfModelInvalid", d); p && b(function () { a(p).assign(e, m ? o : g) }), b(function () { }) } function n() { function a(a, b) { return a.name === b.name && (a.$ngfOrigSize || a.size) === (b.$ngfOrigSize || b.size) && a.type === b.type } function b(b) { var c; for (c = 0; c < s.length; c++) if (a(b, s[c])) return !0; for (c = 0; c < t.length; c++) if (a(b, t[c])) return !0; return !1 } if (j) { r = [], u = []; for (var c = 0; c < j.length; c++) b(j[c]) ? u.push(j[c]) : r.push(j[c]) } } function o(a) { return angular.isArray(a) ? a : [a] } function p() { w = [], v = [], angular.forEach(r, function (a) { a.$error ? v.push(a) : w.push(a) }) } function q() { function a() { b(function () { m(x ? s.concat(w) : w, x ? t.concat(v) : v, j, u, y) }, B && B.debounce ? B.debounce.change || B.debounce : 0) } g(z ? r : w, d, e).then(function () { z ? h.validate(r, A, c, d, e).then(function () { p(), a() }) : a() }, function (a) { throw "Could not resize files " + a }) } var r, s, t, u = [], v = [], w = []; s = d.$$ngfPrevValidFiles || [], t = d.$$ngfPrevInvalidFiles || [], c && c.$modelValue && (s = o(c.$modelValue)); var x = h.attrGetter("ngfKeep", d, e); r = (j || []).slice(0), ("distinct" === x || h.attrGetter("ngfKeepDistinct", d, e) === !0) && n(d, e); var y = !x && !h.attrGetter("ngfMultiple", d, e) && !h.attrGetter("multiple", d); if (!x || r.length) { h.attrGetter("ngfBeforeModelChange", d, e, { $files: j, $file: j && j.length ? j[0] : null, $newFiles: r, $duplicateFiles: u, $event: k }); var z = h.attrGetter("ngfValidateAfterResize", d, e), A = r.length + s.length + t.length, B = h.attrGetter("ngModelOptions", d, e); h.validate(r, A, c, d, e).then(function () { l ? m(r, [], j, u, y) : (B && B.allowInvalid || z ? w = r : p(), h.attrGetter("ngfFixOrientation", d, e) && h.isExifSupported() ? f(w, d, e).then(function () { q() }) : q()) }) } }, h }]), ngFileUpload.directive("ngfSelect", ["$parse", "$timeout", "$compile", "Upload", function (a, b, c, d) { function e(a) { var b = a.match(/Android[^\d]*(\d+)\.(\d+)/); if (b && b.length > 2) { var c = d.defaults.androidFixMinorVersion || 4; return parseInt(b[1]) < 4 || parseInt(b[1]) === c && parseInt(b[2]) < c } return -1 === a.indexOf("Chrome") && /.*Windows.*Safari.*/.test(a) } function f(a, b, c, d, f, h, i, j) { function k() { return "input" === b[0].tagName.toLowerCase() && c.type && "file" === c.type.toLowerCase() } function l() { return t("ngfChange") || t("ngfSelect") } function m(b) { if (j.shouldUpdateOn("change", c, a)) { for (var e = b.__files_ || b.target && b.target.files, f = [], g = 0; g < e.length; g++) f.push(e[g]); j.updateModel(d, c, a, l(), f.length ? f : null, b) } } function n(a) { if (b !== a) for (var c = 0; c < b[0].attributes.length; c++) { var d = b[0].attributes[c]; "type" !== d.name && "class" !== d.name && "style" !== d.name && ((null == d.value || "" === d.value) && ("required" === d.name && (d.value = "required"), "multiple" === d.name && (d.value = "multiple")), a.attr(d.name, "id" === d.name ? "ngf-" + d.value : d.value)) } } function o() { if (k()) return b; var a = angular.element('<input type="file">'); n(a); var c = angular.element("<label>upload</label>"); return c.css("visibility", "hidden").css("position", "absolute").css("overflow", "hidden").css("width", "0px").css("height", "0px").css("border", "none").css("margin", "0px").css("padding", "0px").attr("tabindex", "-1"), g.push({ el: b, ref: c }), document.body.appendChild(c.append(a)[0]), a } function p(c) { if (b.attr("disabled")) return !1; if (!t("ngfSelectDisabled", a)) { var d = q(c); if (null != d) return d; r(c); try { k() || document.body.contains(w[0]) || (g.push({ el: b, ref: w.parent() }), document.body.appendChild(w.parent()[0]), w.bind("change", m)) } catch (f) { } return e(navigator.userAgent) ? setTimeout(function () { w[0].click() }, 0) : w[0].click(), !1 } } function q(a) { var b = a.changedTouches || a.originalEvent && a.originalEvent.changedTouches; if ("touchstart" === a.type) return v = b ? b[0].clientY : 0, !0; if (a.stopPropagation(), a.preventDefault(), "touchend" === a.type) { var c = b ? b[0].clientY : 0; if (Math.abs(c - v) > 20) return !1 } } function r(b) { j.shouldUpdateOn("click", c, a) && w.val() && (w.val(null), j.updateModel(d, c, a, l(), null, b, !0)) } function s(a) { if (w && !w.attr("__ngf_ie10_Fix_")) { if (!w[0].parentNode) return void (w = null); a.preventDefault(), a.stopPropagation(), w.unbind("click"); var b = w.clone(); return w.replaceWith(b), w = b, w.attr("__ngf_ie10_Fix_", "true"), w.bind("change", m), w.bind("click", s), w[0].click(), !1 } w.removeAttr("__ngf_ie10_Fix_") } var t = function (a, b) { return j.attrGetter(a, c, b) }; j.registerModelChangeValidator(d, c, a); var u = []; u.push(a.$watch(t("ngfMultiple"), function () { w.attr("multiple", t("ngfMultiple", a)) })), u.push(a.$watch(t("ngfCapture"), function () { w.attr("capture", t("ngfCapture", a)) })), u.push(a.$watch(t("ngfAccept"), function () { w.attr("accept", t("ngfAccept", a)) })), c.$observe("accept", function () { w.attr("accept", t("accept")) }), u.push(function () { c.$$observers && delete c.$$observers.accept }); var v = 0, w = b; k() || (w = o()), w.bind("change", m), k() ? b.bind("click", r) : b.bind("click touchstart touchend", p), -1 !== navigator.appVersion.indexOf("MSIE 10") && w.bind("click", s), d && d.$formatters.push(function (a) { return (null == a || 0 === a.length) && w.val() && w.val(null), a }), a.$on("$destroy", function () { k() || w.parent().remove(), angular.forEach(u, function (a) { a() }) }), h(function () { for (var a = 0; a < g.length; a++) { var b = g[a]; document.body.contains(b.el[0]) || (g.splice(a, 1), b.ref.remove()) } }), window.FileAPI && window.FileAPI.ngfFixIE && window.FileAPI.ngfFixIE(b, w, m) } var g = []; return { restrict: "AEC", require: "?ngModel", link: function (e, g, h, i) { f(e, g, h, i, a, b, c, d) } } }]), function () { function a(a) { return "img" === a.tagName.toLowerCase() ? "image" : "audio" === a.tagName.toLowerCase() ? "audio" : "video" === a.tagName.toLowerCase() ? "video" : /./ } function b(b, c, d, e, f, g, h, i) { function j(a) { var g = b.attrGetter("ngfNoObjectUrl", f, d); b.dataUrl(a, g)["finally"](function () { c(function () { var b = (g ? a.$ngfDataUrl : a.$ngfBlobUrl) || a.$ngfDataUrl; i ? e.css("background-image", "url('" + (b || "") + "')") : e.attr("src", b), b ? e.removeClass("ng-hide") : e.addClass("ng-hide") }) }) } c(function () { var c = d.$watch(f[g], function (c) { var d = h; if ("ngfThumbnail" === g && (d || (d = { width: e[0].clientWidth, height: e[0].clientHeight }), 0 === d.width && window.getComputedStyle)) { var f = getComputedStyle(e[0]); d = { width: parseInt(f.width.slice(0, -2)), height: parseInt(f.height.slice(0, -2)) } } return angular.isString(c) ? (e.removeClass("ng-hide"), i ? e.css("background-image", "url('" + c + "')") : e.attr("src", c)) : void (!c || !c.type || 0 !== c.type.search(a(e[0])) || i && 0 !== c.type.indexOf("image") ? e.addClass("ng-hide") : d && b.isResizeSupported() ? b.resize(c, d.width, d.height, d.quality).then(function (a) { j(a) }, function (a) { throw a }) : j(c)) }); d.$on("$destroy", function () { c() }) }) } ngFileUpload.service("UploadDataUrl", ["UploadBase", "$timeout", "$q", function (a, b, c) { var d = a; return d.base64DataUrl = function (a) { if (angular.isArray(a)) { var b = c.defer(), e = 0; return angular.forEach(a, function (c) { d.dataUrl(c, !0)["finally"](function () { if (e++, e === a.length) { var c = []; angular.forEach(a, function (a) { c.push(a.$ngfDataUrl) }), b.resolve(c, a) } }) }), b.promise } return d.dataUrl(a, !0) }, d.dataUrl = function (a, e) { if (!a) return d.emptyPromise(a, a); if (e && null != a.$ngfDataUrl || !e && null != a.$ngfBlobUrl) return d.emptyPromise(e ? a.$ngfDataUrl : a.$ngfBlobUrl, a); var f = e ? a.$$ngfDataUrlPromise : a.$$ngfBlobUrlPromise; if (f) return f; var g = c.defer(); return b(function () { if (window.FileReader && a && (!window.FileAPI || -1 === navigator.userAgent.indexOf("MSIE 8") || a.size < 2e4) && (!window.FileAPI || -1 === navigator.userAgent.indexOf("MSIE 9") || a.size < 4e6)) { var c = window.URL || window.webkitURL; if (c && c.createObjectURL && !e) { var f; try { f = c.createObjectURL(a) } catch (h) { return void b(function () { a.$ngfBlobUrl = "", g.reject() }) } b(function () { if (a.$ngfBlobUrl = f, f) { g.resolve(f, a), d.blobUrls = d.blobUrls || [], d.blobUrlsTotalSize = d.blobUrlsTotalSize || 0, d.blobUrls.push({ url: f, size: a.size }), d.blobUrlsTotalSize += a.size || 0; for (var b = d.defaults.blobUrlsMaxMemory || 268435456, e = d.defaults.blobUrlsMaxQueueSize || 200; (d.blobUrlsTotalSize > b || d.blobUrls.length > e) && d.blobUrls.length > 1;) { var h = d.blobUrls.splice(0, 1)[0]; c.revokeObjectURL(h.url), d.blobUrlsTotalSize -= h.size } } }) } else { var i = new FileReader; i.onload = function (c) { b(function () { a.$ngfDataUrl = c.target.result, g.resolve(c.target.result, a), b(function () { delete a.$ngfDataUrl }, 1e3) }) }, i.onerror = function () { b(function () { a.$ngfDataUrl = "", g.reject() }) }, i.readAsDataURL(a) } } else b(function () { a[e ? "$ngfDataUrl" : "$ngfBlobUrl"] = "", g.reject() }) }), f = e ? a.$$ngfDataUrlPromise = g.promise : a.$$ngfBlobUrlPromise = g.promise, f["finally"](function () { delete a[e ? "$$ngfDataUrlPromise" : "$$ngfBlobUrlPromise"] }), f }, d }]), ngFileUpload.directive("ngfSrc", ["Upload", "$timeout", function (a, c) { return { restrict: "AE", link: function (d, e, f) { b(a, c, d, e, f, "ngfSrc", a.attrGetter("ngfResize", f, d), !1) } } }]), ngFileUpload.directive("ngfBackground", ["Upload", "$timeout", function (a, c) { return { restrict: "AE", link: function (d, e, f) { b(a, c, d, e, f, "ngfBackground", a.attrGetter("ngfResize", f, d), !0) } } }]), ngFileUpload.directive("ngfThumbnail", ["Upload", "$timeout", function (a, c) { return { restrict: "AE", link: function (d, e, f) { var g = a.attrGetter("ngfSize", f, d); b(a, c, d, e, f, "ngfThumbnail", g, a.attrGetter("ngfAsBackground", f, d)) } } }]), ngFileUpload.config(["$compileProvider", function (a) { a.imgSrcSanitizationWhitelist && a.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/), a.aHrefSanitizationWhitelist && a.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/) }]), ngFileUpload.filter("ngfDataUrl", ["UploadDataUrl", "$sce", function (a, b) { return function (c, d, e) { if (angular.isString(c)) return b.trustAsResourceUrl(c); var f = c && ((d ? c.$ngfDataUrl : c.$ngfBlobUrl) || c.$ngfDataUrl); return c && !f ? (!c.$ngfDataUrlFilterInProgress && angular.isObject(c) && (c.$ngfDataUrlFilterInProgress = !0, a.dataUrl(c, d)), "") : (c && delete c.$ngfDataUrlFilterInProgress, (c && f ? e ? b.trustAsResourceUrl(f) : f : c) || "") } }]) }(), ngFileUpload.service("UploadValidate", ["UploadDataUrl", "$q", "$timeout", function (a, b, c) { function d(a) { var b = "", c = []; if (a.length > 2 && "/" === a[0] && "/" === a[a.length - 1]) b = a.substring(1, a.length - 1); else { var e = a.split(","); if (e.length > 1) for (var f = 0; f < e.length; f++) { var g = d(e[f]); g.regexp ? (b += "(" + g.regexp + ")", f < e.length - 1 && (b += "|")) : c = c.concat(g.excludes) } else 0 === a.indexOf("!") ? c.push("^((?!" + d(a.substring(1)).regexp + ").)*$") : (0 === a.indexOf(".") && (a = "*" + a), b = "^" + a.replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]", "g"), "\\$&") + "$", b = b.replace(/\\\*/g, ".*").replace(/\\\?/g, ".")) } return { regexp: b, excludes: c } } function e(a, b) { null == b || a.$dirty || (a.$setDirty ? a.$setDirty() : a.$dirty = !0) } var f = a; return f.validatePattern = function (a, b) { if (!b) return !0; var c = d(b), e = !0; if (c.regexp && c.regexp.length) { var f = new RegExp(c.regexp, "i"); e = null != a.type && f.test(a.type) || null != a.name && f.test(a.name) } for (var g = c.excludes.length; g--;) { var h = new RegExp(c.excludes[g], "i"); e = e && (null == a.type || h.test(a.type)) && (null == a.name || h.test(a.name)) } return e }, f.ratioToFloat = function (a) { var b = a.toString(), c = b.search(/[x:]/i); return b = c > -1 ? parseFloat(b.substring(0, c)) / parseFloat(b.substring(c + 1)) : parseFloat(b) }, f.registerModelChangeValidator = function (a, b, c) { a && a.$formatters.push(function (d) { a.$dirty && (d && !angular.isArray(d) && (d = [d]), f.validate(d, d ? d.length : 0, a, b, c).then(function () { f.applyModelValidation(a, d) })) }) }, f.applyModelValidation = function (a, b) { e(a, b), angular.forEach(a.$ngfValidations, function (b) { a.$setValidity(b.name, b.valid) }) }, f.getValidationAttr = function (a, b, c, d, e) { var g = "ngf" + c[0].toUpperCase() + c.substr(1), h = f.attrGetter(g, a, b, { $file: e }); if (null == h && (h = f.attrGetter("ngfValidate", a, b, { $file: e }))) { var i = (d || c).split("."); h = h[i[0]], i.length > 1 && (h = h && h[i[1]]) } return h }, f.validate = function (a, c, d, e, g) { function h(b, c, h) { if (a) { for (var i = a.length, j = null; i--;) { var k = a[i]; if (k) { var l = f.getValidationAttr(e, g, b, c, k); null != l && (h(k, l) || (k.$error = b, (k.$errorMessages = k.$errorMessages || {}).name = !0, k.$errorParam = l, a.splice(i, 1), j = !1)) } } null !== j && d.$ngfValidations.push({ name: b, valid: j }) } } function i(c, h, i, k, l) { function m(a, b, d) { null != d ? k(b, d).then(function (e) { l(e, d) ? a.resolve() : (b.$error = c, (b.$errorMessages = b.$errorMessages || {}).name = !0, b.$errorParam = d, a.reject()) }, function () { j("ngfValidateForce", { $file: b }) ? (b.$error = c, (b.$errorMessages = b.$errorMessages || {}).name = !0, b.$errorParam = d, a.reject()) : a.resolve() }) : a.resolve() } var n = [f.emptyPromise()]; return a ? (a = void 0 === a.length ? [a] : a, angular.forEach(a, function (a) { var d = b.defer(); return n.push(d.promise), !i || null != a.type && 0 === a.type.search(i) ? void ("dimensions" === c && null != f.attrGetter("ngfDimensions", e) ? f.imageDimensions(a).then(function (b) { m(d, a, j("ngfDimensions", { $file: a, $width: b.width, $height: b.height })) }, function () { d.reject() }) : "duration" === c && null != f.attrGetter("ngfDuration", e) ? f.mediaDuration(a).then(function (b) { m(d, a, j("ngfDuration", { $file: a, $duration: b })) }, function () { d.reject() }) : m(d, a, f.getValidationAttr(e, g, c, h, a))) : void d.resolve() }), b.all(n).then(function () { d.$ngfValidations.push({ name: c, valid: !0 }) }, function () { d.$ngfValidations.push({ name: c, valid: !1 }) })) : void 0 } d = d || {}, d.$ngfValidations = d.$ngfValidations || [], angular.forEach(d.$ngfValidations, function (a) { a.valid = !0 }); var j = function (a, b) { return f.attrGetter(a, e, g, b) }; if (null == a || 0 === a.length) return f.emptyPromise(d); a = void 0 === a.length ? [a] : a.slice(0), h("maxFiles", null, function (a, b) { return b >= c }), h("pattern", null, f.validatePattern), h("minSize", "size.min", function (a, b) { return a.size + .1 >= f.translateScalars(b) }), h("maxSize", "size.max", function (a, b) { return a.size - .1 <= f.translateScalars(b) }); var k = 0; if (h("maxTotalSize", null, function (b, c) { return k += b.size, k > f.translateScalars(c) ? (a.splice(0, a.length), !1) : !0 }), h("validateFn", null, function (a, b) { return b === !0 || null === b || "" === b }), !a.length) return f.emptyPromise(d, d.$ngfValidations); var l = b.defer(), m = []; return m.push(f.happyPromise(i("maxHeight", "height.max", /image/, this.imageDimensions, function (a, b) { return a.height <= b }))), m.push(f.happyPromise(i("minHeight", "height.min", /image/, this.imageDimensions, function (a, b) { return a.height >= b }))), m.push(f.happyPromise(i("maxWidth", "width.max", /image/, this.imageDimensions, function (a, b) { return a.width <= b }))), m.push(f.happyPromise(i("minWidth", "width.min", /image/, this.imageDimensions, function (a, b) { return a.width >= b }))), m.push(f.happyPromise(i("dimensions", null, /image/, function (a, b) { return f.emptyPromise(b) }, function (a) { return a }))), m.push(f.happyPromise(i("ratio", null, /image/, this.imageDimensions, function (a, b) { for (var c = b.toString().split(","), d = !1, e = 0; e < c.length; e++) Math.abs(a.width / a.height - f.ratioToFloat(c[e])) < 1e-4 && (d = !0); return d }))), m.push(f.happyPromise(i("maxRatio", "ratio.max", /image/, this.imageDimensions, function (a, b) { return a.width / a.height - f.ratioToFloat(b) < 1e-4 }))), m.push(f.happyPromise(i("minRatio", "ratio.min", /image/, this.imageDimensions, function (a, b) { return a.width / a.height - f.ratioToFloat(b) > -1e-4 }))), m.push(f.happyPromise(i("maxDuration", "duration.max", /audio|video/, this.mediaDuration, function (a, b) { return a <= f.translateScalars(b) }))), m.push(f.happyPromise(i("minDuration", "duration.min", /audio|video/, this.mediaDuration, function (a, b) { return a >= f.translateScalars(b) }))), m.push(f.happyPromise(i("duration", null, /audio|video/, function (a, b) { return f.emptyPromise(b) }, function (a) { return a }))), m.push(f.happyPromise(i("validateAsyncFn", null, null, function (a, b) { return b }, function (a) { return a === !0 || null === a || "" === a }))), b.all(m).then(function () { l.resolve(d, d.$ngfValidations) }) }, f.imageDimensions = function (a) { if (a.$ngfWidth && a.$ngfHeight) { var d = b.defer(); return c(function () { d.resolve({ width: a.$ngfWidth, height: a.$ngfHeight }) }), d.promise } if (a.$ngfDimensionPromise) return a.$ngfDimensionPromise; var e = b.defer(); return c(function () { return 0 !== a.type.indexOf("image") ? void e.reject("not image") : void f.dataUrl(a).then(function (b) { function d() { var b = h[0].clientWidth, c = h[0].clientHeight; h.remove(), a.$ngfWidth = b, a.$ngfHeight = c, e.resolve({ width: b, height: c }) } function f() { h.remove(), e.reject("load error") } function g() { c(function () { h[0].parentNode && (h[0].clientWidth ? d() : i > 10 ? f() : g()) }, 1e3) } var h = angular.element("<img>").attr("src", b).css("visibility", "hidden").css("position", "fixed"); h.on("load", d), h.on("error", f); var i = 0; g(), angular.element(document.getElementsByTagName("body")[0]).append(h) }, function () { e.reject("load error") }) }), a.$ngfDimensionPromise = e.promise, a.$ngfDimensionPromise["finally"](function () { delete a.$ngfDimensionPromise }), a.$ngfDimensionPromise }, f.mediaDuration = function (a) { if (a.$ngfDuration) { var d = b.defer(); return c(function () { d.resolve(a.$ngfDuration) }), d.promise } if (a.$ngfDurationPromise) return a.$ngfDurationPromise; var e = b.defer(); return c(function () { return 0 !== a.type.indexOf("audio") && 0 !== a.type.indexOf("video") ? void e.reject("not media") : void f.dataUrl(a).then(function (b) { function d() { var b = h[0].duration; a.$ngfDuration = b, h.remove(), e.resolve(b) } function f() { h.remove(), e.reject("load error") } function g() { c(function () { h[0].parentNode && (h[0].duration ? d() : i > 10 ? f() : g()) }, 1e3) } var h = angular.element(0 === a.type.indexOf("audio") ? "<audio>" : "<video>").attr("src", b).css("visibility", "none").css("position", "fixed"); h.on("loadedmetadata", d), h.on("error", f); var i = 0; g(), angular.element(document.body).append(h) }, function () { e.reject("load error") }) }), a.$ngfDurationPromise = e.promise, a.$ngfDurationPromise["finally"](function () { delete a.$ngfDurationPromise }), a.$ngfDurationPromise }, f }]), ngFileUpload.service("UploadResize", ["UploadValidate", "$q", function (a, b) { var c = a, d = function (a, b, c, d, e) { var f = e ? Math.max(c / a, d / b) : Math.min(c / a, d / b); return { width: a * f, height: b * f, marginX: a * f - c, marginY: b * f - d } }, e = function (a, e, f, g, h, i, j, k) { var l = b.defer(), m = document.createElement("canvas"), n = document.createElement("img"); return n.onload = function () { if (null != k && k(n.width, n.height) === !1) return void l.reject("resizeIf"); try { if (i) { var a = c.ratioToFloat(i), b = n.width / n.height; a > b ? (e = n.width, f = e / a) : (f = n.height, e = f * a) } e || (e = n.width), f || (f = n.height); var o = d(n.width, n.height, e, f, j); m.width = Math.min(o.width, e), m.height = Math.min(o.height, f); var p = m.getContext("2d"); p.drawImage(n, Math.min(0, -o.marginX / 2), Math.min(0, -o.marginY / 2), o.width, o.height), l.resolve(m.toDataURL(h || "image/WebP", g || .934)) } catch (q) { l.reject(q) } }, n.onerror = function () { l.reject() }, n.src = a, l.promise }; return c.dataUrltoBlob = function (a, b, c) { for (var d = a.split(","), e = d[0].match(/:(.*?);/)[1], f = atob(d[1]), g = f.length, h = new Uint8Array(g) ; g--;) h[g] = f.charCodeAt(g); var i = new window.Blob([h], { type: e }); return i.name = b, i.$ngfOrigSize = c, i }, c.isResizeSupported = function () { var a = document.createElement("canvas"); return window.atob && a.getContext && a.getContext("2d") && window.Blob }, c.isResizeSupported() && Object.defineProperty(window.Blob.prototype, "name", { get: function () { return this.$ngfName }, set: function (a) { this.$ngfName = a }, configurable: !0 }), c.resize = function (a, d, f, g, h, i, j, k, l) { if (0 !== a.type.indexOf("image")) return c.emptyPromise(a); var m = b.defer(); return c.dataUrl(a, !0).then(function (b) { e(b, d, f, g, h || a.type, i, j, k).then(function (d) { if ("image/jpeg" === a.type && l) try { d = c.restoreExif(b, d) } catch (e) { setTimeout(function () { throw e }, 1) } m.resolve(c.dataUrltoBlob(d, a.name, a.size)) }, function (b) { "resizeIf" === b && m.resolve(a), m.reject() }) }, function () { m.reject() }), m.promise }, c }]), function () {
    function a(a, c, d, e, f, g, h, i, j, k) { function l() { return c.attr("disabled") || r("ngfDropDisabled", a) } function m(b, c) { i.updateModel(e, d, a, r("ngfChange") || r("ngfDrop"), b, c) } function n(b, c) { if (!i.shouldUpdateOn(b, d, a) || !c) return i.rejectPromise([]); var e = []; c.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi, function (a, b, c) { e.push(c) }); var f = [], g = []; if (e.length) { angular.forEach(e, function (a) { f.push(i.urlToBlob(a).then(function (a) { g.push(a) })) }); var h = k.defer(); return k.all(f).then(function () { h.resolve(g) }, function (a) { h.reject(a) }), h.promise } } function o(a, b, c, d) { var e = r("ngfDragOverClass", a, { $event: c }), f = "dragover"; if (angular.isString(e)) f = e; else if (e && (e.delay && (v = e.delay), e.accept || e.reject)) { var g = c.dataTransfer.items; if (null != g && g.length) for (var h = e.pattern || r("ngfPattern", a, { $event: c }), j = g.length; j--;) { if (!i.validatePattern(g[j], h)) { f = e.reject; break } f = e.accept } else f = e.accept } d(f) } function p(b, c, e, f) { function g(a, b) { var c = k.defer(); if (null != a) if (a.isDirectory) { var d = [i.emptyPromise()]; if (m) { var e = { type: "directory" }; e.name = e.path = (b || "") + a.name + a.name, n.push(e) } var f = a.createReader(), h = [], p = function () { f.readEntries(function (e) { try { e.length ? (h = h.concat(Array.prototype.slice.call(e || [], 0)), p()) : (angular.forEach(h.slice(0), function (c) { n.length <= j && l >= o && d.push(g(c, (b ? b : "") + a.name + "/")) }), k.all(d).then(function () { c.resolve() }, function (a) { c.reject(a) })) } catch (f) { c.reject(f) } }, function (a) { c.reject(a) }) }; p() } else a.file(function (a) { try { a.path = (b ? b : "") + a.name, m && (a = i.rename(a, a.path)), n.push(a), o += a.size, c.resolve() } catch (d) { c.reject(d) } }, function (a) { c.reject(a) }); return c.promise } var j = i.getValidationAttr(d, a, "maxFiles") || Number.MAX_VALUE, l = i.getValidationAttr(d, a, "maxTotalSize") || Number.MAX_VALUE, m = r("ngfIncludeDir", a), n = [], o = 0, p = [i.emptyPromise()]; if (b && b.length > 0 && "file" !== h.protocol()) for (var q = 0; q < b.length; q++) { if (b[q].webkitGetAsEntry && b[q].webkitGetAsEntry() && b[q].webkitGetAsEntry().isDirectory) { var s = b[q].webkitGetAsEntry(); if (s.isDirectory && !e) continue; null != s && p.push(g(s)) } else { var t = b[q].getAsFile(); null != t && (n.push(t), o += t.size) } if (n.length > j || o > l || !f && n.length > 0) break } else if (null != c) for (var u = 0; u < c.length; u++) { var v = c.item(u); if ((v.type || v.size > 0) && (n.push(v), o += v.size), n.length > j || o > l || !f && n.length > 0) break } var w = k.defer(); return k.all(p).then(function () { if (f || m) w.resolve(n); else { for (var a = 0; n[a] && "directory" === n[a].type;) a++; w.resolve([n[a]]) } }, function (a) { w.reject(a) }), w.promise } var q = b(), r = function (a, b, c) { return i.attrGetter(a, d, b, c) }; if (r("dropAvailable") && g(function () { a[r("dropAvailable")] ? a[r("dropAvailable")].value = q : a[r("dropAvailable")] = q }), !q) return void (r("ngfHideOnDropNotAvailable", a) === !0 && c.css("display", "none")); null == r("ngfSelect") && i.registerModelChangeValidator(e, d, a); var s, t = null, u = f(r("ngfStopPropagation")), v = 1; c[0].addEventListener("dragover", function (b) { if (!l() && i.shouldUpdateOn("drop", d, a)) { if (b.preventDefault(), u(a) && b.stopPropagation(), navigator.userAgent.indexOf("Chrome") > -1) { var e = b.dataTransfer.effectAllowed; b.dataTransfer.dropEffect = "move" === e || "linkMove" === e ? "move" : "copy" } g.cancel(t), s || (s = "C", o(a, d, b, function (d) { s = d, c.addClass(s), r("ngfDrag", a, { $isDragging: !0, $class: s, $event: b }) })) } }, !1), c[0].addEventListener("dragenter", function (b) { !l() && i.shouldUpdateOn("drop", d, a) && (b.preventDefault(), u(a) && b.stopPropagation()) }, !1), c[0].addEventListener("dragleave", function (b) { !l() && i.shouldUpdateOn("drop", d, a) && (b.preventDefault(), u(a) && b.stopPropagation(), t = g(function () { s && c.removeClass(s), s = null, r("ngfDrag", a, { $isDragging: !1, $event: b }) }, v || 100)) }, !1), c[0].addEventListener("drop", function (b) { if (!l() && i.shouldUpdateOn("drop", d, a)) { b.preventDefault(), u(a) && b.stopPropagation(), s && c.removeClass(s), s = null; var e, f = b.dataTransfer.items; try { e = b.dataTransfer && b.dataTransfer.getData && b.dataTransfer.getData("text/html") } catch (g) { } p(f, b.dataTransfer.files, r("ngfAllowDir", a) !== !1, r("multiple") || r("ngfMultiple", a)).then(function (a) { a.length ? m(a, b) : n("dropUrl", e).then(function (a) { m(a, b) }) }) } }, !1), c[0].addEventListener("paste", function (b) { if (navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && r("ngfEnableFirefoxPaste", a) && b.preventDefault(), !l() && i.shouldUpdateOn("paste", d, a)) { var c = [], e = b.clipboardData || b.originalEvent.clipboardData; if (e && e.items) for (var f = 0; f < e.items.length; f++) -1 !== e.items[f].type.indexOf("image") && c.push(e.items[f].getAsFile()); c.length ? m(c, b) : n("pasteUrl", e).then(function (a) { m(a, b) }) } }, !1), navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && r("ngfEnableFirefoxPaste", a) && (c.attr("contenteditable", !0), c.on("keypress", function (a) { a.metaKey || a.ctrlKey || a.preventDefault() })) } function b() { var a = document.createElement("div"); return "draggable" in a && "ondrop" in a && !/Edge\/12./i.test(navigator.userAgent) } ngFileUpload.directive("ngfDrop", ["$parse", "$timeout", "$location", "Upload", "$http", "$q", function (b, c, d, e, f, g) { return { restrict: "AEC", require: "?ngModel", link: function (h, i, j, k) { a(h, i, j, k, b, c, d, e, f, g) } } }]), ngFileUpload.directive("ngfNoFileDrop", function () { return function (a, c) { b() && c.css("display", "none") } }), ngFileUpload.directive("ngfDropAvailable", ["$parse", "$timeout", "Upload", function (a, c, d) {
        return function (e, f, g) { if (b()) { var h = a(d.attrGetter("ngfDropAvailable", g)); c(function () { h(e), h.assign && h.assign(e, !0) }) } }
    }])
}(), ngFileUpload.service("UploadExif", ["UploadResize", "$q", function (a, b) { function c(a, b, c, d) { switch (b) { case 2: return a.transform(-1, 0, 0, 1, c, 0); case 3: return a.transform(-1, 0, 0, -1, c, d); case 4: return a.transform(1, 0, 0, -1, 0, d); case 5: return a.transform(0, 1, 1, 0, 0, 0); case 6: return a.transform(0, 1, -1, 0, d, 0); case 7: return a.transform(0, -1, -1, 0, d, c); case 8: return a.transform(0, -1, 1, 0, 0, c) } } function d(a) { for (var b = "", c = new Uint8Array(a), d = c.byteLength, e = 0; d > e; e++) b += String.fromCharCode(c[e]); return window.btoa(b) } var e = a; return e.isExifSupported = function () { return window.FileReader && (new FileReader).readAsArrayBuffer && e.isResizeSupported() }, e.readOrientation = function (a) { var c = b.defer(), d = new FileReader, e = a.slice(0, 65536); return d.readAsArrayBuffer(e), d.onerror = function (a) { return c.reject(a) }, d.onload = function (a) { var b = { orientation: 1 }, d = new DataView(this.result); if (65496 !== d.getUint16(0, !1)) return c.resolve(b); for (var e = d.byteLength, f = 2; e > f;) { var g = d.getUint16(f, !1); if (f += 2, 65505 === g) { if (1165519206 !== d.getUint32(f += 2, !1)) return c.resolve(b); var h = 18761 === d.getUint16(f += 6, !1); f += d.getUint32(f + 4, h); var i = d.getUint16(f, h); f += 2; for (var j = 0; i > j; j++) if (274 === d.getUint16(f + 12 * j, h)) { var k = d.getUint16(f + 12 * j + 8, h); return k >= 2 && 8 >= k && (d.setUint16(f + 12 * j + 8, 1, h), b.fixedArrayBuffer = a.target.result), b.orientation = k, c.resolve(b) } } else { if (65280 !== (65280 & g)) break; f += d.getUint16(f, !1) } } return c.resolve(b) }, c.promise }, e.applyExifRotation = function (a) { if (0 !== a.type.indexOf("image/jpeg")) return e.emptyPromise(a); var f = b.defer(); return e.readOrientation(a).then(function (b) { return b.orientation < 2 || b.orientation > 8 ? f.resolve(a) : void e.dataUrl(a, !0).then(function (g) { var h = document.createElement("canvas"), i = document.createElement("img"); i.onload = function () { try { h.width = b.orientation > 4 ? i.height : i.width, h.height = b.orientation > 4 ? i.width : i.height; var g = h.getContext("2d"); c(g, b.orientation, i.width, i.height), g.drawImage(i, 0, 0); var j = h.toDataURL(a.type || "image/WebP", .934); j = e.restoreExif(d(b.fixedArrayBuffer), j); var k = e.dataUrltoBlob(j, a.name); f.resolve(k) } catch (l) { return f.reject(l) } }, i.onerror = function () { f.reject() }, i.src = g }, function (a) { f.reject(a) }) }, function (a) { f.reject(a) }), f.promise }, e.restoreExif = function (a, b) { var c = {}; return c.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", c.encode64 = function (a) { var b, c, d, e, f, g = "", h = "", i = "", j = 0; do b = a[j++], c = a[j++], h = a[j++], d = b >> 2, e = (3 & b) << 4 | c >> 4, f = (15 & c) << 2 | h >> 6, i = 63 & h, isNaN(c) ? f = i = 64 : isNaN(h) && (i = 64), g = g + this.KEY_STR.charAt(d) + this.KEY_STR.charAt(e) + this.KEY_STR.charAt(f) + this.KEY_STR.charAt(i), b = c = h = "", d = e = f = i = ""; while (j < a.length); return g }, c.restore = function (a, b) { a.match("data:image/jpeg;base64,") && (a = a.replace("data:image/jpeg;base64,", "")); var c = this.decode64(a), d = this.slice2Segments(c), e = this.exifManipulation(b, d); return "data:image/jpeg;base64," + this.encode64(e) }, c.exifManipulation = function (a, b) { var c = this.getExifArray(b), d = this.insertExif(a, c); return new Uint8Array(d) }, c.getExifArray = function (a) { for (var b, c = 0; c < a.length; c++) if (b = a[c], 255 === b[0] & 225 === b[1]) return b; return [] }, c.insertExif = function (a, b) { var c = a.replace("data:image/jpeg;base64,", ""), d = this.decode64(c), e = d.indexOf(255, 3), f = d.slice(0, e), g = d.slice(e), h = f; return h = h.concat(b), h = h.concat(g) }, c.slice2Segments = function (a) { for (var b = 0, c = []; ;) { if (255 === a[b] & 218 === a[b + 1]) break; if (255 === a[b] & 216 === a[b + 1]) b += 2; else { var d = 256 * a[b + 2] + a[b + 3], e = b + d + 2, f = a.slice(b, e); c.push(f), b = e } if (b > a.length) break } return c }, c.decode64 = function (a) { var b, c, d, e, f, g = "", h = "", i = 0, j = [], k = /[^A-Za-z0-9\+\/\=]/g; k.exec(a) && console.log("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, NaNExpect errors in decoding."), a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); do d = this.KEY_STR.indexOf(a.charAt(i++)), e = this.KEY_STR.indexOf(a.charAt(i++)), f = this.KEY_STR.indexOf(a.charAt(i++)), h = this.KEY_STR.indexOf(a.charAt(i++)), b = d << 2 | e >> 4, c = (15 & e) << 4 | f >> 2, g = (3 & f) << 6 | h, j.push(b), 64 !== f && j.push(c), 64 !== h && j.push(g), b = c = g = "", d = e = f = h = ""; while (i < a.length); return j }, c.restore(a, b) }, e }]);/*! 12.0.1 */
!window.XMLHttpRequest||window.FileAPI&&FileAPI.shouldLoad||(window.XMLHttpRequest.prototype.setRequestHeader=function(a){return function(b,c){if("__setXHR_"===b){var d=c(this);d instanceof Function&&d(this)}else a.apply(this,arguments)}}(window.XMLHttpRequest.prototype.setRequestHeader));var ngFileUpload=angular.module("ngFileUpload",[]);ngFileUpload.version="12.0.1",ngFileUpload.service("UploadBase",["$http","$q","$timeout",function(a,b,c){function d(d){function e(a){j.notify&&j.notify(a),k.progressFunc&&c(function(){k.progressFunc(a)})}function h(a){return null!=d._start&&g?{loaded:a.loaded+d._start,total:d._file&&d._file.size||a.total,type:a.type,config:d,lengthComputable:!0,target:a.target}:a}function i(){a(d).then(function(a){g&&d._chunkSize&&!d._finished&&d._file?(e({loaded:d._end,total:d._file&&d._file.size,config:d,type:"progress"}),f.upload(d,!0)):(d._finished&&delete d._finished,j.resolve(a))},function(a){j.reject(a)},function(a){j.notify(a)})}d.method=d.method||"POST",d.headers=d.headers||{};var j=d._deferred=d._deferred||b.defer(),k=j.promise;return d.disableProgress||(d.headers.__setXHR_=function(){return function(a){a&&a.upload&&a.upload.addEventListener&&(d.__XHR=a,d.xhrFn&&d.xhrFn(a),a.upload.addEventListener("progress",function(a){a.config=d,e(h(a))},!1),a.upload.addEventListener("load",function(a){a.lengthComputable&&(a.config=d,e(h(a)))},!1))}}),g?d._chunkSize&&d._end&&!d._finished?(d._start=d._end,d._end+=d._chunkSize,i()):d.resumeSizeUrl?a.get(d.resumeSizeUrl).then(function(a){d._start=d.resumeSizeResponseReader?d.resumeSizeResponseReader(a.data):parseInt((null==a.data.size?a.data:a.data.size).toString()),d._chunkSize&&(d._end=d._start+d._chunkSize),i()},function(a){throw a}):d.resumeSize?d.resumeSize().then(function(a){d._start=a,i()},function(a){throw a}):(d._chunkSize&&(d._start=0,d._end=d._start+d._chunkSize),i()):i(),k.success=function(a){return k.then(function(b){a(b.data,b.status,b.headers,d)}),k},k.error=function(a){return k.then(null,function(b){a(b.data,b.status,b.headers,d)}),k},k.progress=function(a){return k.progressFunc=a,k.then(null,null,function(b){a(b)}),k},k.abort=k.pause=function(){return d.__XHR&&c(function(){d.__XHR.abort()}),k},k.xhr=function(a){return d.xhrFn=function(b){return function(){b&&b.apply(k,arguments),a.apply(k,arguments)}}(d.xhrFn),k},f.promisesCount++,k["finally"](function(){f.promisesCount--}),k}function e(a){var b={};for(var c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b}var f=this;f.promisesCount=0,this.isResumeSupported=function(){return window.Blob&&window.Blob instanceof Function&&window.Blob.prototype.slice};var g=this.isResumeSupported();this.isUploadInProgress=function(){return f.promisesCount>0},this.rename=function(a,b){return a.ngfName=b,a},this.jsonBlob=function(a){null==a||angular.isString(a)||(a=JSON.stringify(a));var b=new window.Blob([a],{type:"application/json"});return b._ngfBlob=!0,b},this.json=function(a){return angular.toJson(a)},this.isFile=function(a){return null!=a&&(a instanceof window.Blob||a.flashId&&a.name&&a.size)},this.upload=function(a,b){function c(b,c){if(b._ngfBlob)return b;if(a._file=a._file||b,null!=a._start&&g){a._end&&a._end>=b.size&&(a._finished=!0,a._end=b.size);var d=b.slice(a._start,a._end||b.size);return d.name=b.name,d.ngfName=b.ngfName,a._chunkSize&&(c.append("_chunkSize",a._chunkSize),c.append("_currentChunkSize",a._end-a._start),c.append("_chunkNumber",Math.floor(a._start/a._chunkSize)),c.append("_totalSize",a._file.size)),d}return b}function h(b,d,e){if(void 0!==d)if(angular.isDate(d)&&(d=d.toISOString()),angular.isString(d))b.append(e,d);else if(f.isFile(d)){var g=c(d,b),i=e.split(",");i[1]&&(g.ngfName=i[1].replace(/^\s+|\s+$/g,""),e=i[0]),a._fileKey=a._fileKey||e,b.append(e,g,g.ngfName||g.name)}else if(angular.isObject(d)){if(d.$$ngfCircularDetection)throw"ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: "+e;d.$$ngfCircularDetection=!0;try{for(var j in d)if(d.hasOwnProperty(j)&&"$$ngfCircularDetection"!==j){var k=null==a.objectKey?"[i]":a.objectKey;d.length&&parseInt(j)>-1&&(k=null==a.arrayKey?k:a.arrayKey),h(b,d[j],e+k.replace(/[ik]/g,j))}}finally{delete d.$$ngfCircularDetection}}else b.append(e,d)}function i(){a._chunkSize=f.translateScalars(a.resumeChunkSize),a._chunkSize=a._chunkSize?parseInt(a._chunkSize.toString()):null,a.headers=a.headers||{},a.headers["Content-Type"]=void 0,a.transformRequest=a.transformRequest?angular.isArray(a.transformRequest)?a.transformRequest:[a.transformRequest]:[],a.transformRequest.push(function(b){var c,d=new window.FormData;b=b||a.fields||{},a.file&&(b.file=a.file);for(c in b)if(b.hasOwnProperty(c)){var e=b[c];a.formDataAppender?a.formDataAppender(d,c,e):h(d,e,c)}return d})}return b||(a=e(a)),a._isDigested||(a._isDigested=!0,i()),d(a)},this.http=function(b){return b=e(b),b.transformRequest=b.transformRequest||function(b){return window.ArrayBuffer&&b instanceof window.ArrayBuffer||b instanceof window.Blob?b:a.defaults.transformRequest[0].apply(this,arguments)},b._chunkSize=f.translateScalars(b.resumeChunkSize),b._chunkSize=b._chunkSize?parseInt(b._chunkSize.toString()):null,d(b)},this.translateScalars=function(a){if(angular.isString(a)){if(a.search(/kb/i)===a.length-2)return parseFloat(1024*a.substring(0,a.length-2));if(a.search(/mb/i)===a.length-2)return parseFloat(1048576*a.substring(0,a.length-2));if(a.search(/gb/i)===a.length-2)return parseFloat(1073741824*a.substring(0,a.length-2));if(a.search(/b/i)===a.length-1)return parseFloat(a.substring(0,a.length-1));if(a.search(/s/i)===a.length-1)return parseFloat(a.substring(0,a.length-1));if(a.search(/m/i)===a.length-1)return parseFloat(60*a.substring(0,a.length-1));if(a.search(/h/i)===a.length-1)return parseFloat(3600*a.substring(0,a.length-1))}return a},this.urlToBlob=function(c){var d=b.defer();return a({url:c,method:"get",responseType:"arraybuffer"}).then(function(a){var b=new Uint8Array(a.data),c=a.headers("content-type")||"image/WebP",e=new window.Blob([b],{type:c});d.resolve(e)},function(a){d.reject(a)}),d.promise},this.setDefaults=function(a){this.defaults=a||{}},this.defaults={},this.version=ngFileUpload.version}]),ngFileUpload.service("Upload",["$parse","$timeout","$compile","$q","UploadExif",function(a,b,c,d,e){function f(a,b,c){var e=[h.emptyPromise()];return angular.forEach(a,function(d,f){0===d.type.indexOf("image/jpeg")&&h.attrGetter("ngfFixOrientation",b,c,{$file:d})&&e.push(h.happyPromise(h.applyExifRotation(d),d).then(function(b){a.splice(f,1,b)}))}),d.all(e)}function g(a,b,c){function e(d,e){if(0===d.type.indexOf("image")){if(f.pattern&&!h.validatePattern(d,f.pattern))return;var i=h.resize(d,f.width,f.height,f.quality,f.type,f.ratio,f.centerCrop,function(a,e){return h.attrGetter("ngfResizeIf",b,c,{$width:a,$height:e,$file:d})},f.restoreExif!==!1);g.push(i),i.then(function(b){a.splice(e,1,b)},function(a){d.$error="resize",d.$errorParam=(a?(a.message?a.message:a)+": ":"")+(d&&d.name)})}}var f=h.attrGetter("ngfResize",b,c);if(!(f&&angular.isObject(f)&&h.isResizeSupported()&&a.length))return h.emptyPromise();for(var g=[h.emptyPromise()],i=0;i<a.length;i++)e(a[i],i);return d.all(g)}var h=e;return h.getAttrWithDefaults=function(a,b){if(null!=a[b])return a[b];var c=h.defaults[b];return null==c?c:angular.isString(c)?c:JSON.stringify(c)},h.attrGetter=function(b,c,d,e){var f=this.getAttrWithDefaults(c,b);if(!d)return f;try{return e?a(f)(d,e):a(f)(d)}catch(g){if(b.search(/min|max|pattern/i))return f;throw g}},h.shouldUpdateOn=function(a,b,c){var d=h.attrGetter("ngModelOptions",b,c);return d&&d.updateOn?d.updateOn.split(" ").indexOf(a)>-1:!0},h.emptyPromise=function(){var a=d.defer(),c=arguments;return b(function(){a.resolve.apply(a,c)}),a.promise},h.rejectPromise=function(){var a=d.defer(),c=arguments;return b(function(){a.reject.apply(a,c)}),a.promise},h.happyPromise=function(a,c){var e=d.defer();return a.then(function(a){e.resolve(a)},function(a){b(function(){throw a}),e.resolve(c)}),e.promise},h.updateModel=function(c,d,e,i,j,k,l){function m(f,g,j,l,m){d.$$ngfPrevValidFiles=f,d.$$ngfPrevInvalidFiles=g;var n=f&&f.length?f[0]:null,o=g&&g.length?g[0]:null;c&&(h.applyModelValidation(c,f),c.$setViewValue(m?n:f)),i&&a(i)(e,{$files:f,$file:n,$newFiles:j,$duplicateFiles:l,$invalidFiles:g,$invalidFile:o,$event:k});var p=h.attrGetter("ngfModelInvalid",d);p&&b(function(){a(p).assign(e,m?o:g)}),b(function(){})}function n(){function a(a,b){return a.name===b.name&&(a.$ngfOrigSize||a.size)===(b.$ngfOrigSize||b.size)&&a.type===b.type}function b(b){var c;for(c=0;c<s.length;c++)if(a(b,s[c]))return!0;for(c=0;c<t.length;c++)if(a(b,t[c]))return!0;return!1}if(j){r=[],u=[];for(var c=0;c<j.length;c++)b(j[c])?u.push(j[c]):r.push(j[c])}}function o(a){return angular.isArray(a)?a:[a]}function p(){w=[],v=[],angular.forEach(r,function(a){a.$error?v.push(a):w.push(a)})}function q(){function a(){b(function(){m(x?s.concat(w):w,x?t.concat(v):v,j,u,y)},B&&B.debounce?B.debounce.change||B.debounce:0)}g(z?r:w,d,e).then(function(){z?h.validate(r,A,c,d,e).then(function(){p(),a()}):a()},function(a){throw"Could not resize files "+a})}var r,s,t,u=[],v=[],w=[];s=d.$$ngfPrevValidFiles||[],t=d.$$ngfPrevInvalidFiles||[],c&&c.$modelValue&&(s=o(c.$modelValue));var x=h.attrGetter("ngfKeep",d,e);r=(j||[]).slice(0),("distinct"===x||h.attrGetter("ngfKeepDistinct",d,e)===!0)&&n(d,e);var y=!x&&!h.attrGetter("ngfMultiple",d,e)&&!h.attrGetter("multiple",d);if(!x||r.length){h.attrGetter("ngfBeforeModelChange",d,e,{$files:j,$file:j&&j.length?j[0]:null,$newFiles:r,$duplicateFiles:u,$event:k});var z=h.attrGetter("ngfValidateAfterResize",d,e),A=r.length+s.length+t.length,B=h.attrGetter("ngModelOptions",d,e);h.validate(r,A,c,d,e).then(function(){l?m(r,[],j,u,y):(B&&B.allowInvalid||z?w=r:p(),h.attrGetter("ngfFixOrientation",d,e)&&h.isExifSupported()?f(w,d,e).then(function(){q()}):q())})}},h}]),ngFileUpload.directive("ngfSelect",["$parse","$timeout","$compile","Upload",function(a,b,c,d){function e(a){var b=a.match(/Android[^\d]*(\d+)\.(\d+)/);if(b&&b.length>2){var c=d.defaults.androidFixMinorVersion||4;return parseInt(b[1])<4||parseInt(b[1])===c&&parseInt(b[2])<c}return-1===a.indexOf("Chrome")&&/.*Windows.*Safari.*/.test(a)}function f(a,b,c,d,f,h,i,j){function k(){return"input"===b[0].tagName.toLowerCase()&&c.type&&"file"===c.type.toLowerCase()}function l(){return t("ngfChange")||t("ngfSelect")}function m(b){if(j.shouldUpdateOn("change",c,a)){for(var e=b.__files_||b.target&&b.target.files,f=[],g=0;g<e.length;g++)f.push(e[g]);j.updateModel(d,c,a,l(),f.length?f:null,b)}}function n(a){if(b!==a)for(var c=0;c<b[0].attributes.length;c++){var d=b[0].attributes[c];"type"!==d.name&&"class"!==d.name&&"style"!==d.name&&((null==d.value||""===d.value)&&("required"===d.name&&(d.value="required"),"multiple"===d.name&&(d.value="multiple")),a.attr(d.name,"id"===d.name?"ngf-"+d.value:d.value))}}function o(){if(k())return b;var a=angular.element('<input type="file">');n(a);var c=angular.element("<label>upload</label>");return c.css("visibility","hidden").css("position","absolute").css("overflow","hidden").css("width","0px").css("height","0px").css("border","none").css("margin","0px").css("padding","0px").attr("tabindex","-1"),g.push({el:b,ref:c}),document.body.appendChild(c.append(a)[0]),a}function p(c){if(b.attr("disabled"))return!1;if(!t("ngfSelectDisabled",a)){var d=q(c);if(null!=d)return d;r(c);try{k()||document.body.contains(w[0])||(g.push({el:b,ref:w.parent()}),document.body.appendChild(w.parent()[0]),w.bind("change",m))}catch(f){}return e(navigator.userAgent)?setTimeout(function(){w[0].click()},0):w[0].click(),!1}}function q(a){var b=a.changedTouches||a.originalEvent&&a.originalEvent.changedTouches;if("touchstart"===a.type)return v=b?b[0].clientY:0,!0;if(a.stopPropagation(),a.preventDefault(),"touchend"===a.type){var c=b?b[0].clientY:0;if(Math.abs(c-v)>20)return!1}}function r(b){j.shouldUpdateOn("click",c,a)&&w.val()&&(w.val(null),j.updateModel(d,c,a,l(),null,b,!0))}function s(a){if(w&&!w.attr("__ngf_ie10_Fix_")){if(!w[0].parentNode)return void(w=null);a.preventDefault(),a.stopPropagation(),w.unbind("click");var b=w.clone();return w.replaceWith(b),w=b,w.attr("__ngf_ie10_Fix_","true"),w.bind("change",m),w.bind("click",s),w[0].click(),!1}w.removeAttr("__ngf_ie10_Fix_")}var t=function(a,b){return j.attrGetter(a,c,b)};j.registerModelChangeValidator(d,c,a);var u=[];u.push(a.$watch(t("ngfMultiple"),function(){w.attr("multiple",t("ngfMultiple",a))})),u.push(a.$watch(t("ngfCapture"),function(){w.attr("capture",t("ngfCapture",a))})),u.push(a.$watch(t("ngfAccept"),function(){w.attr("accept",t("ngfAccept",a))})),c.$observe("accept",function(){w.attr("accept",t("accept"))}),u.push(function(){c.$$observers&&delete c.$$observers.accept});var v=0,w=b;k()||(w=o()),w.bind("change",m),k()?b.bind("click",r):b.bind("click touchstart touchend",p),-1!==navigator.appVersion.indexOf("MSIE 10")&&w.bind("click",s),d&&d.$formatters.push(function(a){return(null==a||0===a.length)&&w.val()&&w.val(null),a}),a.$on("$destroy",function(){k()||w.parent().remove(),angular.forEach(u,function(a){a()})}),h(function(){for(var a=0;a<g.length;a++){var b=g[a];document.body.contains(b.el[0])||(g.splice(a,1),b.ref.remove())}}),window.FileAPI&&window.FileAPI.ngfFixIE&&window.FileAPI.ngfFixIE(b,w,m)}var g=[];return{restrict:"AEC",require:"?ngModel",link:function(e,g,h,i){f(e,g,h,i,a,b,c,d)}}}]),function(){function a(a){return"img"===a.tagName.toLowerCase()?"image":"audio"===a.tagName.toLowerCase()?"audio":"video"===a.tagName.toLowerCase()?"video":/./}function b(b,c,d,e,f,g,h,i){function j(a){var g=b.attrGetter("ngfNoObjectUrl",f,d);b.dataUrl(a,g)["finally"](function(){c(function(){var b=(g?a.$ngfDataUrl:a.$ngfBlobUrl)||a.$ngfDataUrl;i?e.css("background-image","url('"+(b||"")+"')"):e.attr("src",b),b?e.removeClass("ng-hide"):e.addClass("ng-hide")})})}c(function(){var c=d.$watch(f[g],function(c){var d=h;if("ngfThumbnail"===g&&(d||(d={width:e[0].clientWidth,height:e[0].clientHeight}),0===d.width&&window.getComputedStyle)){var f=getComputedStyle(e[0]);d={width:parseInt(f.width.slice(0,-2)),height:parseInt(f.height.slice(0,-2))}}return angular.isString(c)?(e.removeClass("ng-hide"),i?e.css("background-image","url('"+c+"')"):e.attr("src",c)):void(!c||!c.type||0!==c.type.search(a(e[0]))||i&&0!==c.type.indexOf("image")?e.addClass("ng-hide"):d&&b.isResizeSupported()?b.resize(c,d.width,d.height,d.quality).then(function(a){j(a)},function(a){throw a}):j(c))});d.$on("$destroy",function(){c()})})}ngFileUpload.service("UploadDataUrl",["UploadBase","$timeout","$q",function(a,b,c){var d=a;return d.base64DataUrl=function(a){if(angular.isArray(a)){var b=c.defer(),e=0;return angular.forEach(a,function(c){d.dataUrl(c,!0)["finally"](function(){if(e++,e===a.length){var c=[];angular.forEach(a,function(a){c.push(a.$ngfDataUrl)}),b.resolve(c,a)}})}),b.promise}return d.dataUrl(a,!0)},d.dataUrl=function(a,e){if(!a)return d.emptyPromise(a,a);if(e&&null!=a.$ngfDataUrl||!e&&null!=a.$ngfBlobUrl)return d.emptyPromise(e?a.$ngfDataUrl:a.$ngfBlobUrl,a);var f=e?a.$$ngfDataUrlPromise:a.$$ngfBlobUrlPromise;if(f)return f;var g=c.defer();return b(function(){if(window.FileReader&&a&&(!window.FileAPI||-1===navigator.userAgent.indexOf("MSIE 8")||a.size<2e4)&&(!window.FileAPI||-1===navigator.userAgent.indexOf("MSIE 9")||a.size<4e6)){var c=window.URL||window.webkitURL;if(c&&c.createObjectURL&&!e){var f;try{f=c.createObjectURL(a)}catch(h){return void b(function(){a.$ngfBlobUrl="",g.reject()})}b(function(){if(a.$ngfBlobUrl=f,f){g.resolve(f,a),d.blobUrls=d.blobUrls||[],d.blobUrlsTotalSize=d.blobUrlsTotalSize||0,d.blobUrls.push({url:f,size:a.size}),d.blobUrlsTotalSize+=a.size||0;for(var b=d.defaults.blobUrlsMaxMemory||268435456,e=d.defaults.blobUrlsMaxQueueSize||200;(d.blobUrlsTotalSize>b||d.blobUrls.length>e)&&d.blobUrls.length>1;){var h=d.blobUrls.splice(0,1)[0];c.revokeObjectURL(h.url),d.blobUrlsTotalSize-=h.size}}})}else{var i=new FileReader;i.onload=function(c){b(function(){a.$ngfDataUrl=c.target.result,g.resolve(c.target.result,a),b(function(){delete a.$ngfDataUrl},1e3)})},i.onerror=function(){b(function(){a.$ngfDataUrl="",g.reject()})},i.readAsDataURL(a)}}else b(function(){a[e?"$ngfDataUrl":"$ngfBlobUrl"]="",g.reject()})}),f=e?a.$$ngfDataUrlPromise=g.promise:a.$$ngfBlobUrlPromise=g.promise,f["finally"](function(){delete a[e?"$$ngfDataUrlPromise":"$$ngfBlobUrlPromise"]}),f},d}]),ngFileUpload.directive("ngfSrc",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){b(a,c,d,e,f,"ngfSrc",a.attrGetter("ngfResize",f,d),!1)}}}]),ngFileUpload.directive("ngfBackground",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){b(a,c,d,e,f,"ngfBackground",a.attrGetter("ngfResize",f,d),!0)}}}]),ngFileUpload.directive("ngfThumbnail",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){var g=a.attrGetter("ngfSize",f,d);b(a,c,d,e,f,"ngfThumbnail",g,a.attrGetter("ngfAsBackground",f,d))}}}]),ngFileUpload.config(["$compileProvider",function(a){a.imgSrcSanitizationWhitelist&&a.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/),a.aHrefSanitizationWhitelist&&a.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/)}]),ngFileUpload.filter("ngfDataUrl",["UploadDataUrl","$sce",function(a,b){return function(c,d,e){if(angular.isString(c))return b.trustAsResourceUrl(c);var f=c&&((d?c.$ngfDataUrl:c.$ngfBlobUrl)||c.$ngfDataUrl);return c&&!f?(!c.$ngfDataUrlFilterInProgress&&angular.isObject(c)&&(c.$ngfDataUrlFilterInProgress=!0,a.dataUrl(c,d)),""):(c&&delete c.$ngfDataUrlFilterInProgress,(c&&f?e?b.trustAsResourceUrl(f):f:c)||"")}}])}(),ngFileUpload.service("UploadValidate",["UploadDataUrl","$q","$timeout",function(a,b,c){function d(a){var b="",c=[];if(a.length>2&&"/"===a[0]&&"/"===a[a.length-1])b=a.substring(1,a.length-1);else{var e=a.split(",");if(e.length>1)for(var f=0;f<e.length;f++){var g=d(e[f]);g.regexp?(b+="("+g.regexp+")",f<e.length-1&&(b+="|")):c=c.concat(g.excludes)}else 0===a.indexOf("!")?c.push("^((?!"+d(a.substring(1)).regexp+").)*$"):(0===a.indexOf(".")&&(a="*"+a),b="^"+a.replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]","g"),"\\$&")+"$",b=b.replace(/\\\*/g,".*").replace(/\\\?/g,"."))}return{regexp:b,excludes:c}}function e(a,b){null==b||a.$dirty||(a.$setDirty?a.$setDirty():a.$dirty=!0)}var f=a;return f.validatePattern=function(a,b){if(!b)return!0;var c=d(b),e=!0;if(c.regexp&&c.regexp.length){var f=new RegExp(c.regexp,"i");e=null!=a.type&&f.test(a.type)||null!=a.name&&f.test(a.name)}for(var g=c.excludes.length;g--;){var h=new RegExp(c.excludes[g],"i");e=e&&(null==a.type||h.test(a.type))&&(null==a.name||h.test(a.name))}return e},f.ratioToFloat=function(a){var b=a.toString(),c=b.search(/[x:]/i);return b=c>-1?parseFloat(b.substring(0,c))/parseFloat(b.substring(c+1)):parseFloat(b)},f.registerModelChangeValidator=function(a,b,c){a&&a.$formatters.push(function(d){a.$dirty&&(d&&!angular.isArray(d)&&(d=[d]),f.validate(d,d?d.length:0,a,b,c).then(function(){f.applyModelValidation(a,d)}))})},f.applyModelValidation=function(a,b){e(a,b),angular.forEach(a.$ngfValidations,function(b){a.$setValidity(b.name,b.valid)})},f.getValidationAttr=function(a,b,c,d,e){var g="ngf"+c[0].toUpperCase()+c.substr(1),h=f.attrGetter(g,a,b,{$file:e});if(null==h&&(h=f.attrGetter("ngfValidate",a,b,{$file:e}))){var i=(d||c).split(".");h=h[i[0]],i.length>1&&(h=h&&h[i[1]])}return h},f.validate=function(a,c,d,e,g){function h(b,c,h){if(a){for(var i=a.length,j=null;i--;){var k=a[i];if(k){var l=f.getValidationAttr(e,g,b,c,k);null!=l&&(h(k,l)||(k.$error=b,(k.$errorMessages=k.$errorMessages||{}).name=!0,k.$errorParam=l,a.splice(i,1),j=!1))}}null!==j&&d.$ngfValidations.push({name:b,valid:j})}}function i(c,h,i,k,l){function m(a,b,d){null!=d?k(b,d).then(function(e){l(e,d)?a.resolve():(b.$error=c,(b.$errorMessages=b.$errorMessages||{}).name=!0,b.$errorParam=d,a.reject())},function(){j("ngfValidateForce",{$file:b})?(b.$error=c,(b.$errorMessages=b.$errorMessages||{}).name=!0,b.$errorParam=d,a.reject()):a.resolve()}):a.resolve()}var n=[f.emptyPromise()];return a?(a=void 0===a.length?[a]:a,angular.forEach(a,function(a){var d=b.defer();return n.push(d.promise),!i||null!=a.type&&0===a.type.search(i)?void("dimensions"===c&&null!=f.attrGetter("ngfDimensions",e)?f.imageDimensions(a).then(function(b){m(d,a,j("ngfDimensions",{$file:a,$width:b.width,$height:b.height}))},function(){d.reject()}):"duration"===c&&null!=f.attrGetter("ngfDuration",e)?f.mediaDuration(a).then(function(b){m(d,a,j("ngfDuration",{$file:a,$duration:b}))},function(){d.reject()}):m(d,a,f.getValidationAttr(e,g,c,h,a))):void d.resolve()}),b.all(n).then(function(){d.$ngfValidations.push({name:c,valid:!0})},function(){d.$ngfValidations.push({name:c,valid:!1})})):void 0}d=d||{},d.$ngfValidations=d.$ngfValidations||[],angular.forEach(d.$ngfValidations,function(a){a.valid=!0});var j=function(a,b){return f.attrGetter(a,e,g,b)};if(null==a||0===a.length)return f.emptyPromise(d);a=void 0===a.length?[a]:a.slice(0),h("maxFiles",null,function(a,b){return b>=c}),h("pattern",null,f.validatePattern),h("minSize","size.min",function(a,b){return a.size+.1>=f.translateScalars(b)}),h("maxSize","size.max",function(a,b){return a.size-.1<=f.translateScalars(b)});var k=0;if(h("maxTotalSize",null,function(b,c){return k+=b.size,k>f.translateScalars(c)?(a.splice(0,a.length),!1):!0}),h("validateFn",null,function(a,b){return b===!0||null===b||""===b}),!a.length)return f.emptyPromise(d,d.$ngfValidations);var l=b.defer(),m=[];return m.push(f.happyPromise(i("maxHeight","height.max",/image/,this.imageDimensions,function(a,b){return a.height<=b}))),m.push(f.happyPromise(i("minHeight","height.min",/image/,this.imageDimensions,function(a,b){return a.height>=b}))),m.push(f.happyPromise(i("maxWidth","width.max",/image/,this.imageDimensions,function(a,b){return a.width<=b}))),m.push(f.happyPromise(i("minWidth","width.min",/image/,this.imageDimensions,function(a,b){return a.width>=b}))),m.push(f.happyPromise(i("dimensions",null,/image/,function(a,b){return f.emptyPromise(b)},function(a){return a}))),m.push(f.happyPromise(i("ratio",null,/image/,this.imageDimensions,function(a,b){for(var c=b.toString().split(","),d=!1,e=0;e<c.length;e++)Math.abs(a.width/a.height-f.ratioToFloat(c[e]))<1e-4&&(d=!0);return d}))),m.push(f.happyPromise(i("maxRatio","ratio.max",/image/,this.imageDimensions,function(a,b){return a.width/a.height-f.ratioToFloat(b)<1e-4}))),m.push(f.happyPromise(i("minRatio","ratio.min",/image/,this.imageDimensions,function(a,b){return a.width/a.height-f.ratioToFloat(b)>-1e-4}))),m.push(f.happyPromise(i("maxDuration","duration.max",/audio|video/,this.mediaDuration,function(a,b){return a<=f.translateScalars(b)}))),m.push(f.happyPromise(i("minDuration","duration.min",/audio|video/,this.mediaDuration,function(a,b){return a>=f.translateScalars(b)}))),m.push(f.happyPromise(i("duration",null,/audio|video/,function(a,b){return f.emptyPromise(b)},function(a){return a}))),m.push(f.happyPromise(i("validateAsyncFn",null,null,function(a,b){return b},function(a){return a===!0||null===a||""===a}))),b.all(m).then(function(){l.resolve(d,d.$ngfValidations)})},f.imageDimensions=function(a){if(a.$ngfWidth&&a.$ngfHeight){var d=b.defer();return c(function(){d.resolve({width:a.$ngfWidth,height:a.$ngfHeight})}),d.promise}if(a.$ngfDimensionPromise)return a.$ngfDimensionPromise;var e=b.defer();return c(function(){return 0!==a.type.indexOf("image")?void e.reject("not image"):void f.dataUrl(a).then(function(b){function d(){var b=h[0].clientWidth,c=h[0].clientHeight;h.remove(),a.$ngfWidth=b,a.$ngfHeight=c,e.resolve({width:b,height:c})}function f(){h.remove(),e.reject("load error")}function g(){c(function(){h[0].parentNode&&(h[0].clientWidth?d():i>10?f():g())},1e3)}var h=angular.element("<img>").attr("src",b).css("visibility","hidden").css("position","fixed");h.on("load",d),h.on("error",f);var i=0;g(),angular.element(document.getElementsByTagName("body")[0]).append(h)},function(){e.reject("load error")})}),a.$ngfDimensionPromise=e.promise,a.$ngfDimensionPromise["finally"](function(){delete a.$ngfDimensionPromise}),a.$ngfDimensionPromise},f.mediaDuration=function(a){if(a.$ngfDuration){var d=b.defer();return c(function(){d.resolve(a.$ngfDuration)}),d.promise}if(a.$ngfDurationPromise)return a.$ngfDurationPromise;var e=b.defer();return c(function(){return 0!==a.type.indexOf("audio")&&0!==a.type.indexOf("video")?void e.reject("not media"):void f.dataUrl(a).then(function(b){function d(){var b=h[0].duration;a.$ngfDuration=b,h.remove(),e.resolve(b)}function f(){h.remove(),e.reject("load error")}function g(){c(function(){h[0].parentNode&&(h[0].duration?d():i>10?f():g())},1e3)}var h=angular.element(0===a.type.indexOf("audio")?"<audio>":"<video>").attr("src",b).css("visibility","none").css("position","fixed");h.on("loadedmetadata",d),h.on("error",f);var i=0;g(),angular.element(document.body).append(h)},function(){e.reject("load error")})}),a.$ngfDurationPromise=e.promise,a.$ngfDurationPromise["finally"](function(){delete a.$ngfDurationPromise}),a.$ngfDurationPromise},f}]),ngFileUpload.service("UploadResize",["UploadValidate","$q",function(a,b){var c=a,d=function(a,b,c,d,e){var f=e?Math.max(c/a,d/b):Math.min(c/a,d/b);return{width:a*f,height:b*f,marginX:a*f-c,marginY:b*f-d}},e=function(a,e,f,g,h,i,j,k){var l=b.defer(),m=document.createElement("canvas"),n=document.createElement("img");return n.onload=function(){if(null!=k&&k(n.width,n.height)===!1)return void l.reject("resizeIf");try{if(i){var a=c.ratioToFloat(i),b=n.width/n.height;a>b?(e=n.width,f=e/a):(f=n.height,e=f*a)}e||(e=n.width),f||(f=n.height);var o=d(n.width,n.height,e,f,j);m.width=Math.min(o.width,e),m.height=Math.min(o.height,f);var p=m.getContext("2d");p.drawImage(n,Math.min(0,-o.marginX/2),Math.min(0,-o.marginY/2),o.width,o.height),l.resolve(m.toDataURL(h||"image/WebP",g||.934))}catch(q){l.reject(q)}},n.onerror=function(){l.reject()},n.src=a,l.promise};return c.dataUrltoBlob=function(a,b,c){for(var d=a.split(","),e=d[0].match(/:(.*?);/)[1],f=atob(d[1]),g=f.length,h=new Uint8Array(g);g--;)h[g]=f.charCodeAt(g);var i=new window.Blob([h],{type:e});return i.name=b,i.$ngfOrigSize=c,i},c.isResizeSupported=function(){var a=document.createElement("canvas");return window.atob&&a.getContext&&a.getContext("2d")&&window.Blob},c.isResizeSupported()&&Object.defineProperty(window.Blob.prototype,"name",{get:function(){return this.$ngfName},set:function(a){this.$ngfName=a},configurable:!0}),c.resize=function(a,d,f,g,h,i,j,k,l){if(0!==a.type.indexOf("image"))return c.emptyPromise(a);var m=b.defer();return c.dataUrl(a,!0).then(function(b){e(b,d,f,g,h||a.type,i,j,k).then(function(d){if("image/jpeg"===a.type&&l)try{d=c.restoreExif(b,d)}catch(e){setTimeout(function(){throw e},1)}m.resolve(c.dataUrltoBlob(d,a.name,a.size))},function(b){"resizeIf"===b&&m.resolve(a),m.reject()})},function(){m.reject()}),m.promise},c}]),function(){function a(a,c,d,e,f,g,h,i,j,k){function l(){return c.attr("disabled")||r("ngfDropDisabled",a)}function m(b,c){i.updateModel(e,d,a,r("ngfChange")||r("ngfDrop"),b,c)}function n(b,c){if(!i.shouldUpdateOn(b,d,a)||!c)return i.rejectPromise([]);var e=[];c.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi,function(a,b,c){e.push(c)});var f=[],g=[];if(e.length){angular.forEach(e,function(a){f.push(i.urlToBlob(a).then(function(a){g.push(a)}))});var h=k.defer();return k.all(f).then(function(){h.resolve(g)},function(a){h.reject(a)}),h.promise}}function o(a,b,c,d){var e=r("ngfDragOverClass",a,{$event:c}),f="dragover";if(angular.isString(e))f=e;else if(e&&(e.delay&&(v=e.delay),e.accept||e.reject)){var g=c.dataTransfer.items;if(null!=g&&g.length)for(var h=e.pattern||r("ngfPattern",a,{$event:c}),j=g.length;j--;){if(!i.validatePattern(g[j],h)){f=e.reject;break}f=e.accept}else f=e.accept}d(f)}function p(b,c,e,f){function g(a,b){var c=k.defer();if(null!=a)if(a.isDirectory){var d=[i.emptyPromise()];if(m){var e={type:"directory"};e.name=e.path=(b||"")+a.name+a.name,n.push(e)}var f=a.createReader(),h=[],p=function(){f.readEntries(function(e){try{e.length?(h=h.concat(Array.prototype.slice.call(e||[],0)),p()):(angular.forEach(h.slice(0),function(c){n.length<=j&&l>=o&&d.push(g(c,(b?b:"")+a.name+"/"))}),k.all(d).then(function(){c.resolve()},function(a){c.reject(a)}))}catch(f){c.reject(f)}},function(a){c.reject(a)})};p()}else a.file(function(a){try{a.path=(b?b:"")+a.name,m&&(a=i.rename(a,a.path)),n.push(a),o+=a.size,c.resolve()}catch(d){c.reject(d)}},function(a){c.reject(a)});return c.promise}var j=i.getValidationAttr(d,a,"maxFiles")||Number.MAX_VALUE,l=i.getValidationAttr(d,a,"maxTotalSize")||Number.MAX_VALUE,m=r("ngfIncludeDir",a),n=[],o=0,p=[i.emptyPromise()];if(b&&b.length>0&&"file"!==h.protocol())for(var q=0;q<b.length;q++){if(b[q].webkitGetAsEntry&&b[q].webkitGetAsEntry()&&b[q].webkitGetAsEntry().isDirectory){var s=b[q].webkitGetAsEntry();if(s.isDirectory&&!e)continue;null!=s&&p.push(g(s))}else{var t=b[q].getAsFile();null!=t&&(n.push(t),o+=t.size)}if(n.length>j||o>l||!f&&n.length>0)break}else if(null!=c)for(var u=0;u<c.length;u++){var v=c.item(u);if((v.type||v.size>0)&&(n.push(v),o+=v.size),n.length>j||o>l||!f&&n.length>0)break}var w=k.defer();return k.all(p).then(function(){if(f||m)w.resolve(n);else{for(var a=0;n[a]&&"directory"===n[a].type;)a++;w.resolve([n[a]])}},function(a){w.reject(a)}),w.promise}var q=b(),r=function(a,b,c){return i.attrGetter(a,d,b,c)};if(r("dropAvailable")&&g(function(){a[r("dropAvailable")]?a[r("dropAvailable")].value=q:a[r("dropAvailable")]=q}),!q)return void(r("ngfHideOnDropNotAvailable",a)===!0&&c.css("display","none"));null==r("ngfSelect")&&i.registerModelChangeValidator(e,d,a);var s,t=null,u=f(r("ngfStopPropagation")),v=1;c[0].addEventListener("dragover",function(b){if(!l()&&i.shouldUpdateOn("drop",d,a)){if(b.preventDefault(),u(a)&&b.stopPropagation(),navigator.userAgent.indexOf("Chrome")>-1){var e=b.dataTransfer.effectAllowed;b.dataTransfer.dropEffect="move"===e||"linkMove"===e?"move":"copy"}g.cancel(t),s||(s="C",o(a,d,b,function(d){s=d,c.addClass(s),r("ngfDrag",a,{$isDragging:!0,$class:s,$event:b})}))}},!1),c[0].addEventListener("dragenter",function(b){!l()&&i.shouldUpdateOn("drop",d,a)&&(b.preventDefault(),u(a)&&b.stopPropagation())},!1),c[0].addEventListener("dragleave",function(b){!l()&&i.shouldUpdateOn("drop",d,a)&&(b.preventDefault(),u(a)&&b.stopPropagation(),t=g(function(){s&&c.removeClass(s),s=null,r("ngfDrag",a,{$isDragging:!1,$event:b})},v||100))},!1),c[0].addEventListener("drop",function(b){if(!l()&&i.shouldUpdateOn("drop",d,a)){b.preventDefault(),u(a)&&b.stopPropagation(),s&&c.removeClass(s),s=null;var e,f=b.dataTransfer.items;try{e=b.dataTransfer&&b.dataTransfer.getData&&b.dataTransfer.getData("text/html")}catch(g){}p(f,b.dataTransfer.files,r("ngfAllowDir",a)!==!1,r("multiple")||r("ngfMultiple",a)).then(function(a){a.length?m(a,b):n("dropUrl",e).then(function(a){m(a,b)})})}},!1),c[0].addEventListener("paste",function(b){if(navigator.userAgent.toLowerCase().indexOf("firefox")>-1&&r("ngfEnableFirefoxPaste",a)&&b.preventDefault(),!l()&&i.shouldUpdateOn("paste",d,a)){var c=[],e=b.clipboardData||b.originalEvent.clipboardData;if(e&&e.items)for(var f=0;f<e.items.length;f++)-1!==e.items[f].type.indexOf("image")&&c.push(e.items[f].getAsFile());c.length?m(c,b):n("pasteUrl",e).then(function(a){m(a,b)})}},!1),navigator.userAgent.toLowerCase().indexOf("firefox")>-1&&r("ngfEnableFirefoxPaste",a)&&(c.attr("contenteditable",!0),c.on("keypress",function(a){a.metaKey||a.ctrlKey||a.preventDefault()}))}function b(){var a=document.createElement("div");return"draggable"in a&&"ondrop"in a&&!/Edge\/12./i.test(navigator.userAgent)}ngFileUpload.directive("ngfDrop",["$parse","$timeout","$location","Upload","$http","$q",function(b,c,d,e,f,g){return{restrict:"AEC",require:"?ngModel",link:function(h,i,j,k){a(h,i,j,k,b,c,d,e,f,g)}}}]),ngFileUpload.directive("ngfNoFileDrop",function(){return function(a,c){b()&&c.css("display","none")}}),ngFileUpload.directive("ngfDropAvailable",["$parse","$timeout","Upload",function(a,c,d){
return function(e,f,g){if(b()){var h=a(d.attrGetter("ngfDropAvailable",g));c(function(){h(e),h.assign&&h.assign(e,!0)})}}}])}(),ngFileUpload.service("UploadExif",["UploadResize","$q",function(a,b){function c(a,b,c,d){switch(b){case 2:return a.transform(-1,0,0,1,c,0);case 3:return a.transform(-1,0,0,-1,c,d);case 4:return a.transform(1,0,0,-1,0,d);case 5:return a.transform(0,1,1,0,0,0);case 6:return a.transform(0,1,-1,0,d,0);case 7:return a.transform(0,-1,-1,0,d,c);case 8:return a.transform(0,-1,1,0,0,c)}}function d(a){for(var b="",c=new Uint8Array(a),d=c.byteLength,e=0;d>e;e++)b+=String.fromCharCode(c[e]);return window.btoa(b)}var e=a;return e.isExifSupported=function(){return window.FileReader&&(new FileReader).readAsArrayBuffer&&e.isResizeSupported()},e.readOrientation=function(a){var c=b.defer(),d=new FileReader,e=a.slice(0,65536);return d.readAsArrayBuffer(e),d.onerror=function(a){return c.reject(a)},d.onload=function(a){var b={orientation:1},d=new DataView(this.result);if(65496!==d.getUint16(0,!1))return c.resolve(b);for(var e=d.byteLength,f=2;e>f;){var g=d.getUint16(f,!1);if(f+=2,65505===g){if(1165519206!==d.getUint32(f+=2,!1))return c.resolve(b);var h=18761===d.getUint16(f+=6,!1);f+=d.getUint32(f+4,h);var i=d.getUint16(f,h);f+=2;for(var j=0;i>j;j++)if(274===d.getUint16(f+12*j,h)){var k=d.getUint16(f+12*j+8,h);return k>=2&&8>=k&&(d.setUint16(f+12*j+8,1,h),b.fixedArrayBuffer=a.target.result),b.orientation=k,c.resolve(b)}}else{if(65280!==(65280&g))break;f+=d.getUint16(f,!1)}}return c.resolve(b)},c.promise},e.applyExifRotation=function(a){if(0!==a.type.indexOf("image/jpeg"))return e.emptyPromise(a);var f=b.defer();return e.readOrientation(a).then(function(b){return b.orientation<2||b.orientation>8?f.resolve(a):void e.dataUrl(a,!0).then(function(g){var h=document.createElement("canvas"),i=document.createElement("img");i.onload=function(){try{h.width=b.orientation>4?i.height:i.width,h.height=b.orientation>4?i.width:i.height;var g=h.getContext("2d");c(g,b.orientation,i.width,i.height),g.drawImage(i,0,0);var j=h.toDataURL(a.type||"image/WebP",.934);j=e.restoreExif(d(b.fixedArrayBuffer),j);var k=e.dataUrltoBlob(j,a.name);f.resolve(k)}catch(l){return f.reject(l)}},i.onerror=function(){f.reject()},i.src=g},function(a){f.reject(a)})},function(a){f.reject(a)}),f.promise},e.restoreExif=function(a,b){var c={};return c.KEY_STR="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",c.encode64=function(a){var b,c,d,e,f,g="",h="",i="",j=0;do b=a[j++],c=a[j++],h=a[j++],d=b>>2,e=(3&b)<<4|c>>4,f=(15&c)<<2|h>>6,i=63&h,isNaN(c)?f=i=64:isNaN(h)&&(i=64),g=g+this.KEY_STR.charAt(d)+this.KEY_STR.charAt(e)+this.KEY_STR.charAt(f)+this.KEY_STR.charAt(i),b=c=h="",d=e=f=i="";while(j<a.length);return g},c.restore=function(a,b){a.match("data:image/jpeg;base64,")&&(a=a.replace("data:image/jpeg;base64,",""));var c=this.decode64(a),d=this.slice2Segments(c),e=this.exifManipulation(b,d);return"data:image/jpeg;base64,"+this.encode64(e)},c.exifManipulation=function(a,b){var c=this.getExifArray(b),d=this.insertExif(a,c);return new Uint8Array(d)},c.getExifArray=function(a){for(var b,c=0;c<a.length;c++)if(b=a[c],255===b[0]&225===b[1])return b;return[]},c.insertExif=function(a,b){var c=a.replace("data:image/jpeg;base64,",""),d=this.decode64(c),e=d.indexOf(255,3),f=d.slice(0,e),g=d.slice(e),h=f;return h=h.concat(b),h=h.concat(g)},c.slice2Segments=function(a){for(var b=0,c=[];;){if(255===a[b]&218===a[b+1])break;if(255===a[b]&216===a[b+1])b+=2;else{var d=256*a[b+2]+a[b+3],e=b+d+2,f=a.slice(b,e);c.push(f),b=e}if(b>a.length)break}return c},c.decode64=function(a){var b,c,d,e,f,g="",h="",i=0,j=[],k=/[^A-Za-z0-9\+\/\=]/g;k.exec(a)&&console.log("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, NaNExpect errors in decoding."),a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");do d=this.KEY_STR.indexOf(a.charAt(i++)),e=this.KEY_STR.indexOf(a.charAt(i++)),f=this.KEY_STR.indexOf(a.charAt(i++)),h=this.KEY_STR.indexOf(a.charAt(i++)),b=d<<2|e>>4,c=(15&e)<<4|f>>2,g=(3&f)<<6|h,j.push(b),64!==f&&j.push(c),64!==h&&j.push(g),b=c=g="",d=e=f=h="";while(i<a.length);return j},c.restore(a,b)},e}]);
/**
 * @license AngularJS v1.4.7
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *     Any commits to this file should be reviewed with security in mind.  *
 *   Changes to this file can potentially create security vulnerabilities. *
 *          An approval from 2 Core members with history of modifying      *
 *                         this file is required.                          *
 *                                                                         *
 *  Does the change somehow allow for arbitrary javascript to be executed? *
 *    Or allows for someone to change the prototype of built-in objects?   *
 *     Or gives undesired access to variables likes document or window?    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

var $sanitizeMinErr = angular.$$minErr('$sanitize');

/**
 * @ngdoc module
 * @name ngSanitize
 * @description
 *
 * # ngSanitize
 *
 * The `ngSanitize` module provides functionality to sanitize HTML.
 *
 *
 * <div doc-module-components="ngSanitize"></div>
 *
 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
 */

/*
 * HTML Parser By Misko Hevery (misko@hevery.com)
 * based on:  HTML Parser By John Resig (ejohn.org)
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 *
 * // Use like so:
 * htmlParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 */


/**
 * @ngdoc service
 * @name $sanitize
 * @kind function
 *
 * @description
 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
 *   then serialized back to properly escaped html string. This means that no unsafe input can make
 *   it into the returned string, however, since our parser is more strict than a typical browser
 *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
 *   browser, won't make it through the sanitizer. The input may also contain SVG markup.
 *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
 *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
 *
 * @param {string} html HTML input.
 * @returns {string} Sanitized HTML.
 *
 * @example
   <example module="sanitizeExample" deps="angular-sanitize.js">
   <file name="index.html">
     <script>
         angular.module('sanitizeExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
             $scope.snippet =
               '<p style="color:blue">an html\n' +
               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
               'snippet</p>';
             $scope.deliberatelyTrustDangerousSnippet = function() {
               return $sce.trustAsHtml($scope.snippet);
             };
           }]);
     </script>
     <div ng-controller="ExampleController">
        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Directive</td>
           <td>How</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="bind-html-with-sanitize">
           <td>ng-bind-html</td>
           <td>Automatically uses $sanitize</td>
           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind-html="snippet"></div></td>
         </tr>
         <tr id="bind-html-with-trust">
           <td>ng-bind-html</td>
           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
           <td>
           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
&lt;/div&gt;</pre>
           </td>
           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
         </tr>
         <tr id="bind-default">
           <td>ng-bind</td>
           <td>Automatically escapes</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
       </div>
   </file>
   <file name="protractor.js" type="protractor">
     it('should sanitize the html snippet by default', function() {
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
     });

     it('should inline raw snippet if bound to a trusted value', function() {
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
         toBe("<p style=\"color:blue\">an html\n" +
              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
              "snippet</p>");
     });

     it('should escape snippet without any filter', function() {
       expect(element(by.css('#bind-default div')).getInnerHtml()).
         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
              "snippet&lt;/p&gt;");
     });

     it('should update', function() {
       element(by.model('snippet')).clear();
       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('new <b>text</b>');
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
         'new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
     });
   </file>
   </example>
 */
function $SanitizeProvider() {
  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
    return function(html) {
      var buf = [];
      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
        return !/^unsafe/.test($$sanitizeUri(uri, isImage));
      }));
      return buf.join('');
    };
  }];
}

function sanitizeText(chars) {
  var buf = [];
  var writer = htmlSanitizeWriter(buf, angular.noop);
  writer.chars(chars);
  return buf.join('');
}


// Regular Expressions for parsing tags and attributes
var START_TAG_REGEXP =
       /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
  END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
  ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
  BEGIN_TAG_REGEXP = /^</,
  BEGING_END_TAGE_REGEXP = /^<\//,
  COMMENT_REGEXP = /<!--(.*?)-->/g,
  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
  CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
  SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  // Match everything outside of normal chars and " (quote character)
  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;


// Good source of info about elements and attributes
// http://dev.w3.org/html5/spec/Overview.html#semantics
// http://simon.html5.org/html-elements

// Safe Void Elements - HTML5
// http://dev.w3.org/html5/spec/Overview.html#void-elements
var voidElements = makeMap("area,br,col,hr,img,wbr");

// Elements that you can, intentionally, leave open (and which close themselves)
// http://dev.w3.org/html5/spec/Overview.html#optional-tags
var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
    optionalEndTagInlineElements = makeMap("rp,rt"),
    optionalEndTagElements = angular.extend({},
                                            optionalEndTagInlineElements,
                                            optionalEndTagBlockElements);

// Safe Block Elements - HTML5
var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));

// Inline Elements - HTML5
var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));

// SVG Elements
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
// They can potentially allow for arbitrary javascript to be executed. See #11290
var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
        "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
        "radialGradient,rect,stop,svg,switch,text,title,tspan,use");

// Special Elements (can contain anything)
var specialElements = makeMap("script,style");

var validElements = angular.extend({},
                                   voidElements,
                                   blockElements,
                                   inlineElements,
                                   optionalEndTagElements,
                                   svgElements);

//Attributes that have href and hence need to be sanitized
var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");

var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
    'valign,value,vspace,width');

// SVG attributes (without "id" and "name" attributes)
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);

var validAttrs = angular.extend({},
                                uriAttrs,
                                svgAttrs,
                                htmlAttrs);

function makeMap(str, lowercaseKeys) {
  var obj = {}, items = str.split(','), i;
  for (i = 0; i < items.length; i++) {
    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
  }
  return obj;
}


/**
 * @example
 * htmlParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 * @param {string} html string
 * @param {object} handler
 */
function htmlParser(html, handler) {
  if (typeof html !== 'string') {
    if (html === null || typeof html === 'undefined') {
      html = '';
    } else {
      html = '' + html;
    }
  }
  var index, chars, match, stack = [], last = html, text;
  stack.last = function() { return stack[stack.length - 1]; };

  while (html) {
    text = '';
    chars = true;

    // Make sure we're not in a script or style element
    if (!stack.last() || !specialElements[stack.last()]) {

      // Comment
      if (html.indexOf("<!--") === 0) {
        // comments containing -- are not allowed unless they terminate the comment
        index = html.indexOf("--", 4);

        if (index >= 0 && html.lastIndexOf("-->", index) === index) {
          if (handler.comment) handler.comment(html.substring(4, index));
          html = html.substring(index + 3);
          chars = false;
        }
      // DOCTYPE
      } else if (DOCTYPE_REGEXP.test(html)) {
        match = html.match(DOCTYPE_REGEXP);

        if (match) {
          html = html.replace(match[0], '');
          chars = false;
        }
      // end tag
      } else if (BEGING_END_TAGE_REGEXP.test(html)) {
        match = html.match(END_TAG_REGEXP);

        if (match) {
          html = html.substring(match[0].length);
          match[0].replace(END_TAG_REGEXP, parseEndTag);
          chars = false;
        }

      // start tag
      } else if (BEGIN_TAG_REGEXP.test(html)) {
        match = html.match(START_TAG_REGEXP);

        if (match) {
          // We only have a valid start-tag if there is a '>'.
          if (match[4]) {
            html = html.substring(match[0].length);
            match[0].replace(START_TAG_REGEXP, parseStartTag);
          }
          chars = false;
        } else {
          // no ending tag found --- this piece should be encoded as an entity.
          text += '<';
          html = html.substring(1);
        }
      }

      if (chars) {
        index = html.indexOf("<");

        text += index < 0 ? html : html.substring(0, index);
        html = index < 0 ? "" : html.substring(index);

        if (handler.chars) handler.chars(decodeEntities(text));
      }

    } else {
      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\W\w].
      html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
        function(all, text) {
          text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");

          if (handler.chars) handler.chars(decodeEntities(text));

          return "";
      });

      parseEndTag("", stack.last());
    }

    if (html == last) {
      throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
                                        "of html: {0}", html);
    }
    last = html;
  }

  // Clean up any remaining tags
  parseEndTag();

  function parseStartTag(tag, tagName, rest, unary) {
    tagName = angular.lowercase(tagName);
    if (blockElements[tagName]) {
      while (stack.last() && inlineElements[stack.last()]) {
        parseEndTag("", stack.last());
      }
    }

    if (optionalEndTagElements[tagName] && stack.last() == tagName) {
      parseEndTag("", tagName);
    }

    unary = voidElements[tagName] || !!unary;

    if (!unary) {
      stack.push(tagName);
    }

    var attrs = {};

    rest.replace(ATTR_REGEXP,
      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
        var value = doubleQuotedValue
          || singleQuotedValue
          || unquotedValue
          || '';

        attrs[name] = decodeEntities(value);
    });
    if (handler.start) handler.start(tagName, attrs, unary);
  }

  function parseEndTag(tag, tagName) {
    var pos = 0, i;
    tagName = angular.lowercase(tagName);
    if (tagName) {
      // Find the closest opened tag of the same type
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos] == tagName) break;
      }
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (i = stack.length - 1; i >= pos; i--)
        if (handler.end) handler.end(stack[i]);

      // Remove the open elements from the stack
      stack.length = pos;
    }
  }
}

var hiddenPre=document.createElement("pre");
/**
 * decodes all entities into regular string
 * @param value
 * @returns {string} A string with decoded entities.
 */
function decodeEntities(value) {
  if (!value) { return ''; }

  hiddenPre.innerHTML = value.replace(/</g,"&lt;");
  // innerText depends on styling as it doesn't display hidden elements.
  // Therefore, it's better to use textContent not to cause unnecessary reflows.
  return hiddenPre.textContent;
}

/**
 * Escapes all potentially dangerous characters, so that the
 * resulting string can be safely inserted into attribute or
 * element text.
 * @param value
 * @returns {string} escaped text
 */
function encodeEntities(value) {
  return value.
    replace(/&/g, '&amp;').
    replace(SURROGATE_PAIR_REGEXP, function(value) {
      var hi = value.charCodeAt(0);
      var low = value.charCodeAt(1);
      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
    }).
    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
      return '&#' + value.charCodeAt(0) + ';';
    }).
    replace(/</g, '&lt;').
    replace(/>/g, '&gt;');
}

/**
 * create an HTML/XML writer which writes to buffer
 * @param {Array} buf use buf.jain('') to get out sanitized html string
 * @returns {object} in the form of {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * }
 */
function htmlSanitizeWriter(buf, uriValidator) {
  var ignore = false;
  var out = angular.bind(buf, buf.push);
  return {
    start: function(tag, attrs, unary) {
      tag = angular.lowercase(tag);
      if (!ignore && specialElements[tag]) {
        ignore = tag;
      }
      if (!ignore && validElements[tag] === true) {
        out('<');
        out(tag);
        angular.forEach(attrs, function(value, key) {
          var lkey=angular.lowercase(key);
          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
          if (validAttrs[lkey] === true &&
            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
            out(' ');
            out(key);
            out('="');
            out(encodeEntities(value));
            out('"');
          }
        });
        out(unary ? '/>' : '>');
      }
    },
    end: function(tag) {
        tag = angular.lowercase(tag);
        if (!ignore && validElements[tag] === true) {
          out('</');
          out(tag);
          out('>');
        }
        if (tag == ignore) {
          ignore = false;
        }
      },
    chars: function(chars) {
        if (!ignore) {
          out(encodeEntities(chars));
        }
      }
  };
}


// define ngSanitize module and register $sanitize service
angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);

/* global sanitizeText: false */

/**
 * @ngdoc filter
 * @name linky
 * @kind function
 *
 * @description
 * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
 * plain email address links.
 *
 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
 *
 * @param {string} text Input text.
 * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
 * @returns {string} Html-linkified text.
 *
 * @usage
   <span ng-bind-html="linky_expression | linky"></span>
 *
 * @example
   <example module="linkyExample" deps="angular-sanitize.js">
     <file name="index.html">
       <script>
         angular.module('linkyExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', function($scope) {
             $scope.snippet =
               'Pretty text with some links:\n'+
               'http://angularjs.org/,\n'+
               'mailto:us@somewhere.org,\n'+
               'another@somewhere.org,\n'+
               'and one more: ftp://127.0.0.1/.';
             $scope.snippetWithTarget = 'http://angularjs.org/';
           }]);
       </script>
       <div ng-controller="ExampleController">
       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Filter</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="linky-filter">
           <td>linky filter</td>
           <td>
             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
           </td>
           <td>
             <div ng-bind-html="snippet | linky"></div>
           </td>
         </tr>
         <tr id="linky-target">
          <td>linky target</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
          </td>
         </tr>
         <tr id="escaped-html">
           <td>no filter</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
     </file>
     <file name="protractor.js" type="protractor">
       it('should linkify the snippet with urls', function() {
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
       });

       it('should not linkify snippet without the linky filter', function() {
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
       });

       it('should update', function() {
         element(by.model('snippet')).clear();
         element(by.model('snippet')).sendKeys('new http://link.');
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('new http://link.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
             .toBe('new http://link.');
       });

       it('should work with the target property', function() {
        expect(element(by.id('linky-target')).
            element(by.binding("snippetWithTarget | linky:'_blank'")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
       });
     </file>
   </example>
 */
angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
  var LINKY_URL_REGEXP =
        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
      MAILTO_REGEXP = /^mailto:/i;

  return function(text, target) {
    if (!text) return text;
    var match;
    var raw = text;
    var html = [];
    var url;
    var i;
    while ((match = raw.match(LINKY_URL_REGEXP))) {
      // We can not end in these as they are sometimes found at the end of the sentence
      url = match[0];
      // if we did not match ftp/http/www/mailto then assume mailto
      if (!match[2] && !match[4]) {
        url = (match[3] ? 'http://' : 'mailto:') + url;
      }
      i = match.index;
      addText(raw.substr(0, i));
      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
      raw = raw.substring(i + match[0].length);
    }
    addText(raw);
    return $sanitize(html.join(''));

    function addText(text) {
      if (!text) {
        return;
      }
      html.push(sanitizeText(text));
    }

    function addLink(url, text) {
      html.push('<a ');
      if (angular.isDefined(target)) {
        html.push('target="',
                  target,
                  '" ');
      }
      html.push('href="',
                url.replace(/"/g, '&quot;'),
                '">');
      addText(text);
      html.push('</a>');
    }
  };
}]);


})(window, window.angular);

/*!
 * ui-select
 * http://github.com/angular-ui/ui-select
 * Version: 0.16.0 - 2016-03-23T20:51:56.609Z
 * License: MIT
 */


(function () {
  "use strict";
  var KEY = {
    TAB: 9,
    ENTER: 13,
    ESC: 27,
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    HOME: 36,
    END: 35,
    BACKSPACE: 8,
    DELETE: 46,
    COMMAND: 91,

    MAP: { 91 : "COMMAND", 8 : "BACKSPACE" , 9 : "TAB" , 13 : "ENTER" , 16 : "SHIFT" , 17 : "CTRL" , 18 : "ALT" , 19 : "PAUSEBREAK" , 20 : "CAPSLOCK" , 27 : "ESC" , 32 : "SPACE" , 33 : "PAGE_UP", 34 : "PAGE_DOWN" , 35 : "END" , 36 : "HOME" , 37 : "LEFT" , 38 : "UP" , 39 : "RIGHT" , 40 : "DOWN" , 43 : "+" , 44 : "PRINTSCREEN" , 45 : "INSERT" , 46 : "DELETE", 48 : "0" , 49 : "1" , 50 : "2" , 51 : "3" , 52 : "4" , 53 : "5" , 54 : "6" , 55 : "7" , 56 : "8" , 57 : "9" , 59 : ";", 61 : "=" , 65 : "A" , 66 : "B" , 67 : "C" , 68 : "D" , 69 : "E" , 70 : "F" , 71 : "G" , 72 : "H" , 73 : "I" , 74 : "J" , 75 : "K" , 76 : "L", 77 : "M" , 78 : "N" , 79 : "O" , 80 : "P" , 81 : "Q" , 82 : "R" , 83 : "S" , 84 : "T" , 85 : "U" , 86 : "V" , 87 : "W" , 88 : "X" , 89 : "Y" , 90 : "Z", 96 : "0" , 97 : "1" , 98 : "2" , 99 : "3" , 100 : "4" , 101 : "5" , 102 : "6" , 103 : "7" , 104 : "8" , 105 : "9", 106 : "*" , 107 : "+" , 109 : "-" , 110 : "." , 111 : "/", 112 : "F1" , 113 : "F2" , 114 : "F3" , 115 : "F4" , 116 : "F5" , 117 : "F6" , 118 : "F7" , 119 : "F8" , 120 : "F9" , 121 : "F10" , 122 : "F11" , 123 : "F12", 144 : "NUMLOCK" , 145 : "SCROLLLOCK" , 186 : ";" , 187 : "=" , 188 : "," , 189 : "-" , 190 : "." , 191 : "/" , 192 : "`" , 219 : "[" , 220 : "\\" , 221 : "]" , 222 : "'"
    },

    isControl: function (e) {
      var k = e.which;
      switch (k) {
        case KEY.COMMAND:
        case KEY.SHIFT:
        case KEY.CTRL:
        case KEY.ALT:
          return true;
      }

      if (e.metaKey) return true;

      return false;
    },
    isFunctionKey: function (k) {
      k = k.which ? k.which : k;
      return k >= 112 && k <= 123;
    },
    isVerticalMovement: function (k){
      return ~[KEY.UP, KEY.DOWN].indexOf(k);
    },
    isHorizontalMovement: function (k){
      return ~[KEY.LEFT,KEY.RIGHT,KEY.BACKSPACE,KEY.DELETE].indexOf(k);
    },
    toSeparator: function (k) {
      var sep = {ENTER:"\n",TAB:"\t",SPACE:" "}[k];
      if (sep) return sep;
      // return undefined for special keys other than enter, tab or space.
      // no way to use them to cut strings.
      return KEY[k] ? undefined : k;
    }
  };

  /**
   * Add querySelectorAll() to jqLite.
   *
   * jqLite find() is limited to lookups by tag name.
   * TODO This will change with future versions of AngularJS, to be removed when this happens
   *
   * See jqLite.find - why not use querySelectorAll? https://github.com/angular/angular.js/issues/3586
   * See feat(jqLite): use querySelectorAll instead of getElementsByTagName in jqLite.find https://github.com/angular/angular.js/pull/3598
   */
  if (angular.element.prototype.querySelectorAll === undefined) {
    angular.element.prototype.querySelectorAll = function(selector) {
      return angular.element(this[0].querySelectorAll(selector));
    };
  }

  /**
   * Add closest() to jqLite.
   */
  if (angular.element.prototype.closest === undefined) {
    angular.element.prototype.closest = function( selector) {
      var elem = this[0];
      var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;

      while (elem) {
        if (matchesSelector.bind(elem)(selector)) {
          return elem;
        } else {
          elem = elem.parentElement;
        }
      }
      return false;
    };
  }

  var latestId = 0;

  var uis = angular.module('ui.select', [])

      .constant('uiSelectConfig', {
        theme: 'bootstrap',
        searchEnabled: true,
        sortable: false,
        placeholder: '', // Empty by default, like HTML tag <select>
        refreshDelay: 1000, // In milliseconds
        closeOnSelect: true,
        skipFocusser: false,
        dropdownPosition: 'auto',
        generateId: function() {
          return latestId++;
        },
        appendToBody: false
      })

      // See Rename minErr and make it accessible from outside https://github.com/angular/angular.js/issues/6913
      .service('uiSelectMinErr', function() {
        var minErr = angular.$$minErr('ui.select');
        return function() {
          var error = minErr.apply(this, arguments);
          var message = error.message.replace(new RegExp('\nhttp://errors.angularjs.org/.*'), '');
          return new Error(message);
        };
      })

      // Recreates old behavior of ng-transclude. Used internally.
      .directive('uisTranscludeAppend', function () {
        return {
          link: function (scope, element, attrs, ctrl, transclude) {
            transclude(scope, function (clone) {
              element.append(clone);
            });
          }
        };
      })

      /**
       * Highlights text that matches $select.search.
       *
       * Taken from AngularUI Bootstrap Typeahead
       * See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340
       */
      .filter('highlight', function() {
        function escapeRegexp(queryToEscape) {
          return ('' + queryToEscape).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
        }

        return function(matchItem, query) {
          return query && matchItem ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<span class="ui-select-highlight">$&</span>') : matchItem;
        };
      })

      /**
       * A read-only equivalent of jQuery's offset function: http://api.jquery.com/offset/
       *
       * Taken from AngularUI Bootstrap Position:
       * See https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js#L70
       */
      .factory('uisOffset',
          ['$document', '$window',
            function ($document, $window) {

              return function(element) {
                var boundingClientRect = element[0].getBoundingClientRect();
                return {
                  width: boundingClientRect.width || element.prop('offsetWidth'),
                  height: boundingClientRect.height || element.prop('offsetHeight'),
                  top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                  left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
                };
              };
            }]);

  uis.directive('uiSelectChoices',
      ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile', '$window',
        function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile, $window) {

          return {
            restrict: 'EA',
            require: '^uiSelect',
            replace: true,
            transclude: true,
            templateUrl: function(tElement) {
              // Needed so the uiSelect can detect the transcluded content
              tElement.addClass('ui-select-choices');

              // Gets theme attribute from parent (ui-select)
              var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
              return theme + '/choices.tpl.html';
            },

            compile: function(tElement, tAttrs) {

              if (!tAttrs.repeat) throw uiSelectMinErr('repeat', "Expected 'repeat' expression.");

              return function link(scope, element, attrs, $select, transcludeFn) {

                // var repeat = RepeatParser.parse(attrs.repeat);
                var groupByExp = attrs.groupBy;
                var groupFilterExp = attrs.groupFilter;

                $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp); //Result ready at $select.parserResult

                $select.disableChoiceExpression = attrs.uiDisableChoice;
                $select.onHighlightCallback = attrs.onHighlight;

                $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;

                if(groupByExp) {
                  var groups = element.querySelectorAll('.ui-select-choices-group');
                  if (groups.length !== 1) throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-group but got '{0}'.", groups.length);
                  groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());
                }

                var choices = element.querySelectorAll('.ui-select-choices-row');
                if (choices.length !== 1) {
                  throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row but got '{0}'.", choices.length);
                }

                choices.attr('ng-repeat', $select.parserResult.repeatExpression(groupByExp))
                    .attr('ng-if', '$select.open'); //Prevent unnecessary watches when dropdown is closed
                if ($window.document.addEventListener) {  //crude way to exclude IE8, specifically, which also cannot capture events
                  choices.attr('ng-mouseenter', '$select.setActiveItem('+$select.parserResult.itemName +')')
                      .attr('ng-click', '$select.select(' + $select.parserResult.itemName + ',$select.skipFocusser,$event)');
                }

                var rowsInner = element.querySelectorAll('.ui-select-choices-row-inner');
                if (rowsInner.length !== 1) throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row-inner but got '{0}'.", rowsInner.length);
                rowsInner.attr('uis-transclude-append', ''); //Adding uisTranscludeAppend directive to row element after choices element has ngRepeat
                if (!$window.document.addEventListener) {  //crude way to target IE8, specifically, which also cannot capture events - so event bindings must be here
                  rowsInner.attr('ng-mouseenter', '$select.setActiveItem('+$select.parserResult.itemName +')')
                      .attr('ng-click', '$select.select(' + $select.parserResult.itemName + ',$select.skipFocusser,$event)');
                }

                $compile(element, transcludeFn)(scope); //Passing current transcludeFn to be able to append elements correctly from uisTranscludeAppend

                scope.$watch('$select.search', function(newValue) {
                  if(newValue && !$select.open && $select.multiple) $select.activate(false, true);
                  $select.activeIndex = $select.tagging.isActivated ? -1 : 0;
                  if (!attrs.minimumInputLength || $select.search.length >= attrs.minimumInputLength) {
                    $select.refresh(attrs.refresh);
                  } else {
                    $select.items = [];
                  }
                });

                attrs.$observe('refreshDelay', function() {
                  // $eval() is needed otherwise we get a string instead of a number
                  var refreshDelay = scope.$eval(attrs.refreshDelay);
                  $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;
                });
              };
            }
          };
        }]);

  /**
   * Contains ui-select "intelligence".
   *
   * The goal is to limit dependency on the DOM whenever possible and
   * put as much logic in the controller (instead of the link functions) as possible so it can be easily tested.
   */
  uis.controller('uiSelectCtrl',
      ['$scope', '$element', '$timeout', '$filter', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse', '$injector', '$window',
        function($scope, $element, $timeout, $filter, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse, $injector, $window) {

          var ctrl = this;

          var EMPTY_SEARCH = '';

          ctrl.placeholder = uiSelectConfig.placeholder;
          ctrl.searchEnabled = uiSelectConfig.searchEnabled;
          ctrl.sortable = uiSelectConfig.sortable;
          ctrl.refreshDelay = uiSelectConfig.refreshDelay;
          ctrl.paste = uiSelectConfig.paste;

          ctrl.removeSelected = false; //If selected item(s) should be removed from dropdown list
          ctrl.closeOnSelect = true; //Initialized inside uiSelect directive link function
          ctrl.skipFocusser = false; //Set to true to avoid returning focus to ctrl when item is selected
          ctrl.search = EMPTY_SEARCH;

          ctrl.activeIndex = 0; //Dropdown of choices
          ctrl.items = []; //All available choices

          ctrl.open = false;
          ctrl.focus = false;
          ctrl.disabled = false;
          ctrl.selected = undefined;

          ctrl.dropdownPosition = 'auto';

          ctrl.focusser = undefined; //Reference to input element used to handle focus events
          ctrl.resetSearchInput = true;
          ctrl.multiple = undefined; // Initialized inside uiSelect directive link function
          ctrl.disableChoiceExpression = undefined; // Initialized inside uiSelectChoices directive link function
          ctrl.tagging = {isActivated: false, fct: undefined};
          ctrl.taggingTokens = {isActivated: false, tokens: undefined};
          ctrl.lockChoiceExpression = undefined; // Initialized inside uiSelectMatch directive link function
          ctrl.clickTriggeredSelect = false;
          ctrl.$filter = $filter;

          // Use $injector to check for $animate and store a reference to it
          ctrl.$animate = (function () {
            try {
              return $injector.get('$animate');
            } catch (err) {
              // $animate does not exist
              return null;
            }
          })();

          ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');
          if (ctrl.searchInput.length !== 1) {
            throw uiSelectMinErr('searchInput', "Expected 1 input.ui-select-search but got '{0}'.", ctrl.searchInput.length);
          }

          ctrl.isEmpty = function() {
            return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '' || (ctrl.multiple && ctrl.selected.length === 0);
          };

          function _findIndex(collection, predicate, thisArg){
            if (collection.findIndex){
              return collection.findIndex(predicate, thisArg);
            } else {
              var list = Object(collection);
              var length = list.length >>> 0;
              var value;

              for (var i = 0; i < length; i++) {
                value = list[i];
                if (predicate.call(thisArg, value, i, list)) {
                  return i;
                }
              }
              return -1;
            }
          }

          // Most of the time the user does not want to empty the search input when in typeahead mode
          function _resetSearchInput() {
            if (ctrl.resetSearchInput || (ctrl.resetSearchInput === undefined && uiSelectConfig.resetSearchInput)) {
              ctrl.search = EMPTY_SEARCH;
              //reset activeIndex
              if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {
                ctrl.activeIndex = _findIndex(ctrl.items, function(item){
                  return angular.equals(this, item);
                }, ctrl.selected);
              }
            }
          }

          function _groupsFilter(groups, groupNames) {
            var i, j, result = [];
            for(i = 0; i < groupNames.length ;i++){
              for(j = 0; j < groups.length ;j++){
                if(groups[j].name == [groupNames[i]]){
                  result.push(groups[j]);
                }
              }
            }
            return result;
          }

          // When the user clicks on ui-select, displays the dropdown list
          ctrl.activate = function(initSearchValue, avoidReset) {
            if (!ctrl.disabled  && !ctrl.open) {
              if(!avoidReset) _resetSearchInput();

              $scope.$broadcast('uis:activate');

              ctrl.open = true;

              ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;

              // ensure that the index is set to zero for tagging variants
              // that where first option is auto-selected
              if ( ctrl.activeIndex === -1 && ctrl.taggingLabel !== false ) {
                ctrl.activeIndex = 0;
              }

              var container = $element.querySelectorAll('.ui-select-choices-content');
              if (ctrl.$animate && ctrl.$animate.on && ctrl.$animate.enabled(container[0])) {
                ctrl.$animate.on('enter', container[0], function (elem, phase) {
                  if (phase === 'close') {
                    // Only focus input after the animation has finished
                    $timeout(function () {
                      ctrl.focusSearchInput(initSearchValue);
                    });
                  }
                });
              } else {
                $timeout(function () {
                  ctrl.focusSearchInput(initSearchValue);
                  if(!ctrl.tagging.isActivated && ctrl.items.length > 1) {
                    _ensureHighlightVisible();
                  }
                });
              }
            }
          };

          ctrl.focusSearchInput = function (initSearchValue) {
            ctrl.search = initSearchValue || ctrl.search;
            ctrl.searchInput[0].focus();
          };

          ctrl.findGroupByName = function(name) {
            return ctrl.groups && ctrl.groups.filter(function(group) {
                  return group.name === name;
                })[0];
          };

          ctrl.parseRepeatAttr = function(repeatAttr, groupByExp, groupFilterExp) {
            function updateGroups(items) {
              var groupFn = $scope.$eval(groupByExp);
              ctrl.groups = [];
              angular.forEach(items, function(item) {
                var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];
                var group = ctrl.findGroupByName(groupName);
                if(group) {
                  group.items.push(item);
                }
                else {
                  ctrl.groups.push({name: groupName, items: [item]});
                }
              });
              if(groupFilterExp){
                var groupFilterFn = $scope.$eval(groupFilterExp);
                if( angular.isFunction(groupFilterFn)){
                  ctrl.groups = groupFilterFn(ctrl.groups);
                } else if(angular.isArray(groupFilterFn)){
                  ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);
                }
              }
              ctrl.items = [];
              ctrl.groups.forEach(function(group) {
                ctrl.items = ctrl.items.concat(group.items);
              });
            }

            function setPlainItems(items) {
              ctrl.items = items;
            }

            ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;

            ctrl.parserResult = RepeatParser.parse(repeatAttr);

            ctrl.isGrouped = !!groupByExp;
            ctrl.itemProperty = ctrl.parserResult.itemName;

            //If collection is an Object, convert it to Array

            var originalSource = ctrl.parserResult.source;

            //When an object is used as source, we better create an array and use it as 'source'
            var createArrayFromObject = function(){
              var origSrc = originalSource($scope);
              $scope.$uisSource = Object.keys(origSrc).map(function(v){
                var result = {};
                result[ctrl.parserResult.keyName] = v;
                result.value = origSrc[v];
                return result;
              });
            };

            if (ctrl.parserResult.keyName){ // Check for (key,value) syntax
              createArrayFromObject();
              ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);
              $scope.$watch(originalSource, function(newVal, oldVal){
                if (newVal !== oldVal) createArrayFromObject();
              }, true);
            }

            ctrl.refreshItems = function (data){
              data = data || ctrl.parserResult.source($scope);
              var selectedItems = ctrl.selected;
              //TODO should implement for single mode removeSelected
              if (ctrl.isEmpty() || (angular.isArray(selectedItems) && !selectedItems.length) || !ctrl.removeSelected) {
                ctrl.setItemsFn(data);
              }else{
                if ( data !== undefined ) {
                  var filteredItems = data.filter(function(i) {
                    return selectedItems.every(function(selectedItem) {
                      return !angular.equals(i, selectedItem);
                    });
                  });
                  ctrl.setItemsFn(filteredItems);
                }
              }
              if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up'){
                $scope.calculateDropdownPos();
              }
            };

            // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259
            $scope.$watchCollection(ctrl.parserResult.source, function(items) {
              if (items === undefined || items === null) {
                // If the user specifies undefined or null => reset the collection
                // Special case: items can be undefined if the user did not initialized the collection on the scope
                // i.e $scope.addresses = [] is missing
                ctrl.items = [];
              } else {
                if (!angular.isArray(items)) {
                  throw uiSelectMinErr('items', "Expected an array but got '{0}'.", items);
                } else {
                  //Remove already selected items (ex: while searching)
                  //TODO Should add a test
                  ctrl.refreshItems(items);
                  ctrl.ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
                }
              }
            });

          };

          var _refreshDelayPromise;

          /**
           * Typeahead mode: lets the user refresh the collection using his own function.
           *
           * See Expose $select.search for external / remote filtering https://github.com/angular-ui/ui-select/pull/31
           */
          ctrl.refresh = function(refreshAttr) {
            if (refreshAttr !== undefined) {

              // Debounce
              // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155
              // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177
              if (_refreshDelayPromise) {
                $timeout.cancel(_refreshDelayPromise);
              }
              _refreshDelayPromise = $timeout(function() {
                $scope.$eval(refreshAttr);
              }, ctrl.refreshDelay);
            }
          };

          ctrl.isActive = function(itemScope) {
            if ( !ctrl.open ) {
              return false;
            }
            var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
            var isActive =  itemIndex == ctrl.activeIndex;

            if ( !isActive || ( itemIndex < 0 && ctrl.taggingLabel !== false ) ||( itemIndex < 0 && ctrl.taggingLabel === false) ) {
              return false;
            }

            if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {
              itemScope.$eval(ctrl.onHighlightCallback);
            }

            return isActive;
          };

          ctrl.isDisabled = function(itemScope) {

            if (!ctrl.open) return;

            var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
            var isDisabled = false;
            var item;

            if (itemIndex >= 0 && !angular.isUndefined(ctrl.disableChoiceExpression)) {
              item = ctrl.items[itemIndex];
              isDisabled = !!(itemScope.$eval(ctrl.disableChoiceExpression)); // force the boolean value
              item._uiSelectChoiceDisabled = isDisabled; // store this for later reference
            }

            return isDisabled;
          };


          // When the user selects an item with ENTER or clicks the dropdown
          ctrl.select = function(item, skipFocusser, $event) {
            if (item === undefined || !item._uiSelectChoiceDisabled) {

              if ( ! ctrl.items && ! ctrl.search && ! ctrl.tagging.isActivated) return;

              if (!item || !item._uiSelectChoiceDisabled) {
                if(ctrl.tagging.isActivated) {
                  // if taggingLabel is disabled, we pull from ctrl.search val
                  if ( ctrl.taggingLabel === false ) {
                    if ( ctrl.activeIndex < 0 ) {
                      item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;
                      if (!item || angular.equals( ctrl.items[0], item ) ) {
                        return;
                      }
                    } else {
                      // keyboard nav happened first, user selected from dropdown
                      item = ctrl.items[ctrl.activeIndex];
                    }
                  } else {
                    // tagging always operates at index zero, taggingLabel === false pushes
                    // the ctrl.search value without having it injected
                    if ( ctrl.activeIndex === 0 ) {
                      // ctrl.tagging pushes items to ctrl.items, so we only have empty val
                      // for `item` if it is a detected duplicate
                      if ( item === undefined ) return;

                      // create new item on the fly if we don't already have one;
                      // use tagging function if we have one
                      if ( ctrl.tagging.fct !== undefined && typeof item === 'string' ) {
                        item = ctrl.tagging.fct(item);
                        if (!item) return;
                        // if item type is 'string', apply the tagging label
                      } else if ( typeof item === 'string' ) {
                        // trim the trailing space
                        item = item.replace(ctrl.taggingLabel,'').trim();
                      }
                    }
                  }
                  // search ctrl.selected for dupes potentially caused by tagging and return early if found
                  if ( ctrl.selected && angular.isArray(ctrl.selected) && ctrl.selected.filter( function (selection) { return angular.equals(selection, item); }).length > 0 ) {
                    ctrl.close(skipFocusser);
                    return;
                  }
                }

                $scope.$broadcast('uis:select', item);

                var locals = {};
                locals[ctrl.parserResult.itemName] = item;

                $timeout(function(){
                  ctrl.onSelectCallback($scope, {
                    $item: item,
                    $model: ctrl.parserResult.modelMapper($scope, locals)
                  });
                });

                if (ctrl.closeOnSelect) {
                  ctrl.close(skipFocusser);
                }
                if ($event && $event.type === 'click') {
                  ctrl.clickTriggeredSelect = true;
                }
              }
            }
          };

          // Closes the dropdown
          ctrl.close = function(skipFocusser) {
            if (!ctrl.open) return;
            if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();
            _resetSearchInput();
            ctrl.open = false;

            $scope.$broadcast('uis:close', skipFocusser);

          };

          ctrl.setFocus = function(){
            if (!ctrl.focus) ctrl.focusInput[0].focus();
          };

          ctrl.clear = function($event) {
            ctrl.select(undefined);
            $event.stopPropagation();
            $timeout(function() {
              ctrl.focusser[0].focus();
            }, 0, false);
          };

          // Toggle dropdown
          ctrl.toggle = function(e) {
            if (ctrl.open) {
              ctrl.close();
              e.preventDefault();
              e.stopPropagation();
            } else {
              ctrl.activate();
            }
          };

          ctrl.isLocked = function(itemScope, itemIndex) {
            var isLocked, item = ctrl.selected[itemIndex];

            if (item && !angular.isUndefined(ctrl.lockChoiceExpression)) {
              isLocked = !!(itemScope.$eval(ctrl.lockChoiceExpression)); // force the boolean value
              item._uiSelectChoiceLocked = isLocked; // store this for later reference
            }

            return isLocked;
          };

          var sizeWatch = null;
          ctrl.sizeSearchInput = function() {

            var input = ctrl.searchInput[0],
                container = ctrl.searchInput.parent().parent()[0],
                calculateContainerWidth = function() {
                  // Return the container width only if the search input is visible
                  return container.clientWidth * !!input.offsetParent;
                },
                updateIfVisible = function(containerWidth) {
                  if (containerWidth === 0) {
                    return false;
                  }
                  var inputWidth = containerWidth - input.offsetLeft - 10;
                  if (inputWidth < 50) inputWidth = containerWidth;
                  ctrl.searchInput.css('width', inputWidth+'px');
                  return true;
                };

            ctrl.searchInput.css('width', '10px');
            $timeout(function() { //Give tags time to render correctly
              if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {
                sizeWatch = $scope.$watch(calculateContainerWidth, function(containerWidth) {
                  if (updateIfVisible(containerWidth)) {
                    sizeWatch();
                    sizeWatch = null;
                  }
                });
              }
            });
          };

          function _handleDropDownSelection(key) {
            var processed = true;
            switch (key) {
              case KEY.DOWN:
                if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
                else if (ctrl.activeIndex < ctrl.items.length - 1) { ctrl.activeIndex++; }
                break;
              case KEY.UP:
                if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
                else if (ctrl.activeIndex > 0 || (ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1)) { ctrl.activeIndex--; }
                break;
              case KEY.TAB:
                if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);
                break;
              case KEY.ENTER:
                if(ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)){
                  ctrl.select(ctrl.items[ctrl.activeIndex], ctrl.skipFocusser); // Make sure at least one dropdown item is highlighted before adding if not in tagging mode
                } else {
                  ctrl.activate(false, true); //In case its the search input in 'multiple' mode
                }
                break;
              case KEY.ESC:
                ctrl.close();
                break;
              default:
                processed = false;
            }
            return processed;
          }

          // Bind to keyboard shortcuts
          ctrl.searchInput.on('keydown', function(e) {

            var key = e.which;

            if (~[KEY.ENTER,KEY.ESC].indexOf(key)){
              e.preventDefault();
              e.stopPropagation();
            }

            // if(~[KEY.ESC,KEY.TAB].indexOf(key)){
            //   //TODO: SEGURO?
            //   ctrl.close();
            // }

            $scope.$apply(function() {

              var tagged = false;

              if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {
                _handleDropDownSelection(key);
                if ( ctrl.taggingTokens.isActivated ) {
                  for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
                    if ( ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode] ) {
                      // make sure there is a new value to push via tagging
                      if ( ctrl.search.length > 0 ) {
                        tagged = true;
                      }
                    }
                  }
                  if ( tagged ) {
                    $timeout(function() {
                      ctrl.searchInput.triggerHandler('tagged');
                      var newItem = ctrl.search.replace(KEY.MAP[e.keyCode],'').trim();
                      if ( ctrl.tagging.fct ) {
                        newItem = ctrl.tagging.fct( newItem );
                      }
                      if (newItem) ctrl.select(newItem, true);
                    });
                  }
                }
              }

            });

            if(KEY.isVerticalMovement(key) && ctrl.items.length > 0){
              _ensureHighlightVisible();
            }

            if (key === KEY.ENTER || key === KEY.ESC) {
              e.preventDefault();
              e.stopPropagation();
            }

          });

          ctrl.searchInput.on('paste', function (e) {
            var data;

            if (window.clipboardData && window.clipboardData.getData) { // IE
              data = window.clipboardData.getData('Text');
            } else {
              data = (e.originalEvent || e).clipboardData.getData('text/plain');
            }

            // Prepend the current input field text to the paste buffer.
            data = ctrl.search + data;

            if (data && data.length > 0) {
              // If tagging try to split by tokens and add items
              if (ctrl.taggingTokens.isActivated) {
                var separator = KEY.toSeparator(ctrl.taggingTokens.tokens[0]);
                var items = data.split(separator || ctrl.taggingTokens.tokens[0]); // split by first token only
                if (items && items.length > 0) {
                  var oldsearch = ctrl.search;
                  angular.forEach(items, function (item) {
                    var newItem = ctrl.tagging.fct ? ctrl.tagging.fct(item) : item;
                    if (newItem) {
                      ctrl.select(newItem, true);
                    }
                  });
                  ctrl.search = oldsearch || EMPTY_SEARCH;
                  e.preventDefault();
                  e.stopPropagation();
                }
              } else if (ctrl.paste) {
                ctrl.paste(data);
                ctrl.search = EMPTY_SEARCH;
                e.preventDefault();
                e.stopPropagation();
              }
            }
          });

          ctrl.searchInput.on('tagged', function() {
            $timeout(function() {
              _resetSearchInput();
            });
          });

          // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431
          function _ensureHighlightVisible() {
            var container = $element.querySelectorAll('.ui-select-choices-content');
            var choices = container.querySelectorAll('.ui-select-choices-row');
            if (choices.length < 1) {
              throw uiSelectMinErr('choices', "Expected multiple .ui-select-choices-row but got '{0}'.", choices.length);
            }

            if (ctrl.activeIndex < 0) {
              return;
            }

            var highlighted = choices[ctrl.activeIndex];
            var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;
            var height = container[0].offsetHeight;

            if (posY > height) {
              container[0].scrollTop += posY - height;
            } else if (posY < highlighted.clientHeight) {
              if (ctrl.isGrouped && ctrl.activeIndex === 0)
                container[0].scrollTop = 0; //To make group header visible when going all the way up
              else
                container[0].scrollTop -= highlighted.clientHeight - posY;
            }
          }

          $scope.$on('$destroy', function() {
            ctrl.searchInput.off('keyup keydown tagged blur paste');
          });

          angular.element($window).bind('resize', function() {
            ctrl.sizeSearchInput();
          });

        }]);

  uis.directive('uiSelect',
      ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout',
        function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {

          return {
            restrict: 'EA',
            templateUrl: function(tElement, tAttrs) {
              var theme = tAttrs.theme || uiSelectConfig.theme;
              return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');
            },
            replace: true,
            transclude: true,
            require: ['uiSelect', '^ngModel'],
            scope: true,

            controller: 'uiSelectCtrl',
            controllerAs: '$select',
            compile: function(tElement, tAttrs) {

              // Allow setting ngClass on uiSelect
              var match = /{(.*)}\s*{(.*)}/.exec(tAttrs.ngClass);
              if(match) {
                var combined = '{'+ match[1] +', '+ match[2] +'}';
                tAttrs.ngClass = combined;
                tElement.attr('ng-class', combined);
              }

              //Multiple or Single depending if multiple attribute presence
              if (angular.isDefined(tAttrs.multiple))
                tElement.append('<ui-select-multiple/>').removeAttr('multiple');
              else
                tElement.append('<ui-select-single/>');

              if (tAttrs.inputId)
                tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;

              return function(scope, element, attrs, ctrls, transcludeFn) {

                var $select = ctrls[0];
                var ngModel = ctrls[1];

                $select.generatedId = uiSelectConfig.generateId();
                $select.baseTitle = attrs.title || 'Select box';
                $select.focusserTitle = $select.baseTitle + ' focus';
                $select.focusserId = 'focusser-' + $select.generatedId;

                $select.closeOnSelect = function() {
                  if (angular.isDefined(attrs.closeOnSelect)) {
                    return $parse(attrs.closeOnSelect)();
                  } else {
                    return uiSelectConfig.closeOnSelect;
                  }
                }();

                scope.$watch('skipFocusser', function() {
                  var skipFocusser = scope.$eval(attrs.skipFocusser);
                  $select.skipFocusser = skipFocusser !== undefined ? skipFocusser : uiSelectConfig.skipFocusser;
                });

                $select.onSelectCallback = $parse(attrs.onSelect);
                $select.onRemoveCallback = $parse(attrs.onRemove);

                //Limit the number of selections allowed
                $select.limit = (angular.isDefined(attrs.limit)) ? parseInt(attrs.limit, 10) : undefined;

                //Set reference to ngModel from uiSelectCtrl
                $select.ngModel = ngModel;

                $select.choiceGrouped = function(group){
                  return $select.isGrouped && group && group.name;
                };

                if(attrs.tabindex){
                  attrs.$observe('tabindex', function(value) {
                    $select.focusInput.attr('tabindex', value);
                    element.removeAttr('tabindex');
                  });
                }

                scope.$watch('searchEnabled', function() {
                  var searchEnabled = scope.$eval(attrs.searchEnabled);
                  $select.searchEnabled = searchEnabled !== undefined ? searchEnabled : uiSelectConfig.searchEnabled;
                });

                scope.$watch('sortable', function() {
                  var sortable = scope.$eval(attrs.sortable);
                  $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;
                });

                attrs.$observe('disabled', function() {
                  // No need to use $eval() (thanks to ng-disabled) since we already get a boolean instead of a string
                  $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;
                });

                attrs.$observe('resetSearchInput', function() {
                  // $eval() is needed otherwise we get a string instead of a boolean
                  var resetSearchInput = scope.$eval(attrs.resetSearchInput);
                  $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;
                });

                attrs.$observe('paste', function() {
                  $select.paste = scope.$eval(attrs.paste);
                });

                attrs.$observe('tagging', function() {
                  if(attrs.tagging !== undefined)
                  {
                    // $eval() is needed otherwise we get a string instead of a boolean
                    var taggingEval = scope.$eval(attrs.tagging);
                    $select.tagging = {isActivated: true, fct: taggingEval !== true ? taggingEval : undefined};
                  }
                  else
                  {
                    $select.tagging = {isActivated: false, fct: undefined};
                  }
                });

                attrs.$observe('taggingLabel', function() {
                  if(attrs.tagging !== undefined )
                  {
                    // check eval for FALSE, in this case, we disable the labels
                    // associated with tagging
                    if ( attrs.taggingLabel === 'false' ) {
                      $select.taggingLabel = false;
                    }
                    else
                    {
                      $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';
                    }
                  }
                });

                attrs.$observe('taggingTokens', function() {
                  if (attrs.tagging !== undefined) {
                    var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',','ENTER'];
                    $select.taggingTokens = {isActivated: true, tokens: tokens };
                  }
                });

                //Automatically gets focus when loaded
                if (angular.isDefined(attrs.autofocus)){
                  $timeout(function(){
                    $select.setFocus();
                  });
                }

                //Gets focus based on scope event name (e.g. focus-on='SomeEventName')
                if (angular.isDefined(attrs.focusOn)){
                  scope.$on(attrs.focusOn, function() {
                    $timeout(function(){
                      $select.setFocus();
                    });
                  });
                }

                function onDocumentClick(e) {
                  if (!$select.open) return; //Skip it if dropdown is close

                  var contains = false;

                  if (window.jQuery) {
                    // Firefox 3.6 does not support element.contains()
                    // See Node.contains https://developer.mozilla.org/en-US/docs/Web/API/Node.contains
                    contains = window.jQuery.contains(element[0], e.target);
                  } else {
                    contains = element[0].contains(e.target);
                  }

                  if (!contains && !$select.clickTriggeredSelect) {
                    var skipFocusser;
                    if (!$select.skipFocusser) {
                      //Will lose focus only with certain targets
                      var focusableControls = ['input','button','textarea','select'];
                      var targetController = angular.element(e.target).controller('uiSelect'); //To check if target is other ui-select
                      skipFocusser = targetController && targetController !== $select; //To check if target is other ui-select
                      if (!skipFocusser) skipFocusser =  ~focusableControls.indexOf(e.target.tagName.toLowerCase()); //Check if target is input, button or textarea
                    } else {
                      skipFocusser = true;
                    }
                    $select.close(skipFocusser);
                    scope.$digest();
                  }
                  $select.clickTriggeredSelect = false;
                }

                // See Click everywhere but here event http://stackoverflow.com/questions/12931369
                $document.on('click', onDocumentClick);

                scope.$on('$destroy', function() {
                  $document.off('click', onDocumentClick);
                });

                // Move transcluded elements to their correct position in main template
                transcludeFn(scope, function(clone) {
                  // See Transclude in AngularJS http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html

                  // One day jqLite will be replaced by jQuery and we will be able to write:
                  // var transcludedElement = clone.filter('.my-class')
                  // instead of creating a hackish DOM element:
                  var transcluded = angular.element('<div>').append(clone);

                  var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');
                  transcludedMatch.removeAttr('ui-select-match'); //To avoid loop in case directive as attr
                  transcludedMatch.removeAttr('data-ui-select-match'); // Properly handle HTML5 data-attributes
                  if (transcludedMatch.length !== 1) {
                    throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-match but got '{0}'.", transcludedMatch.length);
                  }
                  element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);

                  var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');
                  transcludedChoices.removeAttr('ui-select-choices'); //To avoid loop in case directive as attr
                  transcludedChoices.removeAttr('data-ui-select-choices'); // Properly handle HTML5 data-attributes
                  if (transcludedChoices.length !== 1) {
                    throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-choices but got '{0}'.", transcludedChoices.length);
                  }
                  element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);
                });

                // Support for appending the select field to the body when its open
                var appendToBody = scope.$eval(attrs.appendToBody);
                if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {
                  scope.$watch('$select.open', function(isOpen) {
                    if (isOpen) {
                      positionDropdown();
                    } else {
                      resetDropdown();
                    }
                  });

                  // Move the dropdown back to its original location when the scope is destroyed. Otherwise
                  // it might stick around when the user routes away or the select field is otherwise removed
                  scope.$on('$destroy', function() {
                    resetDropdown();
                  });
                }

                // Hold on to a reference to the .ui-select-container element for appendToBody support
                var placeholder = null,
                    originalWidth = '';

                function positionDropdown() {
                  // Remember the absolute position of the element
                  var offset = uisOffset(element);

                  // Clone the element into a placeholder element to take its original place in the DOM
                  placeholder = angular.element('<div class="ui-select-placeholder"></div>');
                  placeholder[0].style.width = offset.width + 'px';
                  placeholder[0].style.height = offset.height + 'px';
                  element.after(placeholder);

                  // Remember the original value of the element width inline style, so it can be restored
                  // when the dropdown is closed
                  originalWidth = element[0].style.width;

                  // Now move the actual dropdown element to the end of the body
                  $document.find('body').append(element);

                  element[0].style.position = 'absolute';
                  element[0].style.left = offset.left + 'px';
                  element[0].style.top = offset.top + 'px';
                  element[0].style.width = offset.width + 'px';
                }

                function resetDropdown() {
                  if (placeholder === null) {
                    // The dropdown has not actually been display yet, so there's nothing to reset
                    return;
                  }

                  // Move the dropdown element back to its original location in the DOM
                  placeholder.replaceWith(element);
                  placeholder = null;

                  element[0].style.position = '';
                  element[0].style.left = '';
                  element[0].style.top = '';
                  element[0].style.width = originalWidth;

                  // Set focus back on to the moved element
                  $select.setFocus();
                }

                // Hold on to a reference to the .ui-select-dropdown element for direction support.
                var dropdown = null,
                    directionUpClassName = 'direction-up';

                // Support changing the direction of the dropdown if there isn't enough space to render it.
                scope.$watch('$select.open', function() {

                  if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up'){
                    scope.calculateDropdownPos();
                  }

                });

                var setDropdownPosUp = function(offset, offsetDropdown){

                  offset = offset || uisOffset(element);
                  offsetDropdown = offsetDropdown || uisOffset(dropdown);

                  dropdown[0].style.position = 'absolute';
                  dropdown[0].style.top = (offsetDropdown.height * -1) + 'px';
                  element.addClass(directionUpClassName);

                };

                var setDropdownPosDown = function(offset, offsetDropdown){

                  element.removeClass(directionUpClassName);

                  offset = offset || uisOffset(element);
                  offsetDropdown = offsetDropdown || uisOffset(dropdown);

                  dropdown[0].style.position = '';
                  dropdown[0].style.top = '';

                };

                scope.calculateDropdownPos = function(){

                  if ($select.open) {
                    dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');
                    if (dropdown.length === 0) {
                      return;
                    }

                    // Hide the dropdown so there is no flicker until $timeout is done executing.
                    dropdown[0].style.opacity = 0;

                    // Delay positioning the dropdown until all choices have been added so its height is correct.
                    $timeout(function(){

                      if ($select.dropdownPosition === 'up'){
                        //Go UP
                        setDropdownPosUp();

                      }else{ //AUTO

                        element.removeClass(directionUpClassName);

                        var offset = uisOffset(element);
                        var offsetDropdown = uisOffset(dropdown);

                        //https://code.google.com/p/chromium/issues/detail?id=342307#c4
                        var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop; //To make it cross browser (blink, webkit, IE, Firefox).

                        // Determine if the direction of the dropdown needs to be changed.
                        if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {
                          //Go UP
                          setDropdownPosUp(offset, offsetDropdown);
                        }else{
                          //Go DOWN
                          setDropdownPosDown(offset, offsetDropdown);
                        }

                      }

                      // Display the dropdown once it has been positioned.
                      dropdown[0].style.opacity = 1;
                    });
                  } else {
                    if (dropdown === null || dropdown.length === 0) {
                      return;
                    }

                    // Reset the position of the dropdown.
                    dropdown[0].style.position = '';
                    dropdown[0].style.top = '';
                    element.removeClass(directionUpClassName);
                  }
                };
              };
            }
          };
        }]);

  uis.directive('uiSelectMatch', ['uiSelectConfig', function(uiSelectConfig) {
    return {
      restrict: 'EA',
      require: '^uiSelect',
      replace: true,
      transclude: true,
      templateUrl: function(tElement) {
        // Needed so the uiSelect can detect the transcluded content
        tElement.addClass('ui-select-match');

        // Gets theme attribute from parent (ui-select)
        var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
        var multi = tElement.parent().attr('multiple');
        return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');
      },
      link: function(scope, element, attrs, $select) {
        $select.lockChoiceExpression = attrs.uiLockChoice;
        attrs.$observe('placeholder', function(placeholder) {
          $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;
        });

        function setAllowClear(allow) {
          $select.allowClear = (angular.isDefined(allow)) ? (allow === '') ? true : (allow.toLowerCase() === 'true') : false;
        }

        attrs.$observe('allowClear', setAllowClear);
        setAllowClear(attrs.allowClear);

        if($select.multiple){
          $select.sizeSearchInput();
        }

      }
    };
  }]);

  uis.directive('uiSelectMultiple', ['uiSelectMinErr','$timeout', function(uiSelectMinErr, $timeout) {
    return {
      restrict: 'EA',
      require: ['^uiSelect', '^ngModel'],

      controller: ['$scope','$timeout', function($scope, $timeout){

        var ctrl = this,
            $select = $scope.$select,
            ngModel;

        if (angular.isUndefined($select.selected))
          $select.selected = [];

        //Wait for link fn to inject it
        $scope.$evalAsync(function(){ ngModel = $scope.ngModel; });

        ctrl.activeMatchIndex = -1;

        ctrl.updateModel = function(){
          ngModel.$setViewValue(Date.now()); //Set timestamp as a unique string to force changes
          ctrl.refreshComponent();
        };

        ctrl.refreshComponent = function(){
          //Remove already selected items
          //e.g. When user clicks on a selection, the selected array changes and
          //the dropdown should remove that item
          $select.refreshItems();
          $select.sizeSearchInput();
        };

        // Remove item from multiple select
        ctrl.removeChoice = function(index){

          var removedChoice = $select.selected[index];

          // if the choice is locked, can't remove it
          if(removedChoice._uiSelectChoiceLocked) return;

          var locals = {};
          locals[$select.parserResult.itemName] = removedChoice;

          $select.selected.splice(index, 1);
          ctrl.activeMatchIndex = -1;
          $select.sizeSearchInput();

          // Give some time for scope propagation.
          $timeout(function(){
            $select.onRemoveCallback($scope, {
              $item: removedChoice,
              $model: $select.parserResult.modelMapper($scope, locals)
            });
          });

          ctrl.updateModel();

        };

        ctrl.getPlaceholder = function(){
          //Refactor single?
          if($select.selected && $select.selected.length) return;
          return $select.placeholder;
        };


      }],
      controllerAs: '$selectMultiple',

      link: function(scope, element, attrs, ctrls) {

        var $select = ctrls[0];
        var ngModel = scope.ngModel = ctrls[1];
        var $selectMultiple = scope.$selectMultiple;

        //$select.selected = raw selected objects (ignoring any property binding)

        $select.multiple = true;
        $select.removeSelected = true;

        //Input that will handle focus
        $select.focusInput = $select.searchInput;

        //Properly check for empty if set to multiple
        ngModel.$isEmpty = function(value) {
          return !value || value.length === 0;
        };

        //From view --> model
        ngModel.$parsers.unshift(function () {
          var locals = {},
              result,
              resultMultiple = [];
          for (var j = $select.selected.length - 1; j >= 0; j--) {
            locals = {};
            locals[$select.parserResult.itemName] = $select.selected[j];
            result = $select.parserResult.modelMapper(scope, locals);
            resultMultiple.unshift(result);
          }
          return resultMultiple;
        });

        // From model --> view
        ngModel.$formatters.unshift(function (inputValue) {
          var data = $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
              locals = {},
              result;
          if (!data) return inputValue;
          var resultMultiple = [];
          var checkFnMultiple = function(list, value){
            if (!list || !list.length) return;
            for (var p = list.length - 1; p >= 0; p--) {
              locals[$select.parserResult.itemName] = list[p];
              result = $select.parserResult.modelMapper(scope, locals);
              if($select.parserResult.trackByExp){
                var propsItemNameMatches = /(\w*)\./.exec($select.parserResult.trackByExp);
                var matches = /\.([^\s]+)/.exec($select.parserResult.trackByExp);
                if(propsItemNameMatches && propsItemNameMatches.length > 0 && propsItemNameMatches[1] == $select.parserResult.itemName){
                  if(matches && matches.length>0 && result[matches[1]] == value[matches[1]]){
                    resultMultiple.unshift(list[p]);
                    return true;
                  }
                }
              }
              if (angular.equals(result,value)){
                resultMultiple.unshift(list[p]);
                return true;
              }
            }
            return false;
          };
          if (!inputValue) return resultMultiple; //If ngModel was undefined
          for (var k = inputValue.length - 1; k >= 0; k--) {
            //Check model array of currently selected items
            if (!checkFnMultiple($select.selected, inputValue[k])){
              //Check model array of all items available
              if (!checkFnMultiple(data, inputValue[k])){
                //If not found on previous lists, just add it directly to resultMultiple
                resultMultiple.unshift(inputValue[k]);
              }
            }
          }
          return resultMultiple;
        });

        //Watch for external model changes
        scope.$watchCollection(function(){ return ngModel.$modelValue; }, function(newValue, oldValue) {
          if (oldValue != newValue){
            ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
            $selectMultiple.refreshComponent();
          }
        });

        ngModel.$render = function() {
          // Make sure that model value is array
          if(!angular.isArray(ngModel.$viewValue)){
            // Have tolerance for null or undefined values
            if(angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null){
              $select.selected = [];
            } else {
              throw uiSelectMinErr('multiarr', "Expected model value to be array but got '{0}'", ngModel.$viewValue);
            }
          }
          $select.selected = ngModel.$viewValue;
          $selectMultiple.refreshComponent();
          scope.$evalAsync(); //To force $digest
        };

        scope.$on('uis:select', function (event, item) {
          if($select.selected.length >= $select.limit) {
            return;
          }
          $select.selected.push(item);
          $selectMultiple.updateModel();
        });

        scope.$on('uis:activate', function () {
          $selectMultiple.activeMatchIndex = -1;
        });

        scope.$watch('$select.disabled', function(newValue, oldValue) {
          // As the search input field may now become visible, it may be necessary to recompute its size
          if (oldValue && !newValue) $select.sizeSearchInput();
        });

        $select.searchInput.on('keydown', function(e) {
          var key = e.which;
          scope.$apply(function() {
            var processed = false;
            // var tagged = false; //Checkme
            if(KEY.isHorizontalMovement(key)){
              processed = _handleMatchSelection(key);
            }
            if (processed  && key != KEY.TAB) {
              //TODO Check si el tab selecciona aun correctamente
              //Crear test
              e.preventDefault();
              e.stopPropagation();
            }
          });
        });
        function _getCaretPosition(el) {
          if(angular.isNumber(el.selectionStart)) return el.selectionStart;
          // selectionStart is not supported in IE8 and we don't want hacky workarounds so we compromise
          else return el.value.length;
        }
        // Handles selected options in "multiple" mode
        function _handleMatchSelection(key){
          var caretPosition = _getCaretPosition($select.searchInput[0]),
              length = $select.selected.length,
          // none  = -1,
              first = 0,
              last  = length-1,
              curr  = $selectMultiple.activeMatchIndex,
              next  = $selectMultiple.activeMatchIndex+1,
              prev  = $selectMultiple.activeMatchIndex-1,
              newIndex = curr;

          if(caretPosition > 0 || ($select.search.length && key == KEY.RIGHT)) return false;

          $select.close();

          function getNewActiveMatchIndex(){
            switch(key){
              case KEY.LEFT:
                // Select previous/first item
                if(~$selectMultiple.activeMatchIndex) return prev;
                // Select last item
                else return last;
                break;
              case KEY.RIGHT:
                // Open drop-down
                if(!~$selectMultiple.activeMatchIndex || curr === last){
                  $select.activate();
                  return false;
                }
                // Select next/last item
                else return next;
                break;
              case KEY.BACKSPACE:
                // Remove selected item and select previous/first
                if(~$selectMultiple.activeMatchIndex){
                  $selectMultiple.removeChoice(curr);
                  return prev;
                }
                // Select last item
                else return last;
                break;
              case KEY.DELETE:
                // Remove selected item and select next item
                if(~$selectMultiple.activeMatchIndex){
                  $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);
                  return curr;
                }
                else return false;
            }
          }

          newIndex = getNewActiveMatchIndex();

          if(!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1;
          else $selectMultiple.activeMatchIndex = Math.min(last,Math.max(first,newIndex));

          return true;
        }

        $select.searchInput.on('keyup', function(e) {

          if ( ! KEY.isVerticalMovement(e.which) ) {
            scope.$evalAsync( function () {
              $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
            });
          }
          // Push a "create new" item into array if there is a search string
          if ( $select.tagging.isActivated && $select.search.length > 0 ) {

            // return early with these keys
            if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which) ) {
              return;
            }
            // always reset the activeIndex to the first item when tagging
            $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
            // taggingLabel === false bypasses all of this
            if ($select.taggingLabel === false) return;

            var items = angular.copy( $select.items );
            var stashArr = angular.copy( $select.items );
            var newItem;
            var item;
            var hasTag = false;
            var dupeIndex = -1;
            var tagItems;
            var tagItem;

            // case for object tagging via transform `$select.tagging.fct` function
            if ( $select.tagging.fct !== undefined) {
              tagItems = $select.$filter('filter')(items,{'isTag': true});
              if ( tagItems.length > 0 ) {
                tagItem = tagItems[0];
              }
              // remove the first element, if it has the `isTag` prop we generate a new one with each keyup, shaving the previous
              if ( items.length > 0 && tagItem ) {
                hasTag = true;
                items = items.slice(1,items.length);
                stashArr = stashArr.slice(1,stashArr.length);
              }
              newItem = $select.tagging.fct($select.search);
              // verify the new tag doesn't match the value of a possible selection choice or an already selected item.
              if (
                  stashArr.some(function (origItem) {
                    return angular.equals(origItem, $select.tagging.fct($select.search));
                  }) ||
                  $select.selected.some(function (origItem) {
                    return angular.equals(origItem, newItem);
                  })
              ) {
                scope.$evalAsync(function () {
                  $select.activeIndex = 0;
                  $select.items = items;
                });
                return;
              }
              newItem.isTag = true;
              // handle newItem string and stripping dupes in tagging string context
            } else {
              // find any tagging items already in the $select.items array and store them
              tagItems = $select.$filter('filter')(items,function (item) {
                return item.match($select.taggingLabel);
              });
              if ( tagItems.length > 0 ) {
                tagItem = tagItems[0];
              }
              item = items[0];
              // remove existing tag item if found (should only ever be one tag item)
              if ( item !== undefined && items.length > 0 && tagItem ) {
                hasTag = true;
                items = items.slice(1,items.length);
                stashArr = stashArr.slice(1,stashArr.length);
              }
              newItem = $select.search+' '+$select.taggingLabel;
              if ( _findApproxDupe($select.selected, $select.search) > -1 ) {
                return;
              }
              // verify the the tag doesn't match the value of an existing item from
              // the searched data set or the items already selected
              if ( _findCaseInsensitiveDupe(stashArr.concat($select.selected)) ) {
                // if there is a tag from prev iteration, strip it / queue the change
                // and return early
                if ( hasTag ) {
                  items = stashArr;
                  scope.$evalAsync( function () {
                    $select.activeIndex = 0;
                    $select.items = items;
                  });
                }
                return;
              }
              if ( _findCaseInsensitiveDupe(stashArr) ) {
                // if there is a tag from prev iteration, strip it
                if ( hasTag ) {
                  $select.items = stashArr.slice(1,stashArr.length);
                }
                return;
              }
            }
            if ( hasTag ) dupeIndex = _findApproxDupe($select.selected, newItem);
            // dupe found, shave the first item
            if ( dupeIndex > -1 ) {
              items = items.slice(dupeIndex+1,items.length-1);
            } else {
              items = [];
              items.push(newItem);
              items = items.concat(stashArr);
            }
            scope.$evalAsync( function () {
              $select.activeIndex = 0;
              $select.items = items;
            });
          }
        });
        function _findCaseInsensitiveDupe(arr) {
          if ( arr === undefined || $select.search === undefined ) {
            return false;
          }
          var hasDupe = arr.filter( function (origItem) {
                if ( $select.search.toUpperCase() === undefined || origItem === undefined ) {
                  return false;
                }
                return origItem.toUpperCase() === $select.search.toUpperCase();
              }).length > 0;

          return hasDupe;
        }
        function _findApproxDupe(haystack, needle) {
          var dupeIndex = -1;
          if(angular.isArray(haystack)) {
            var tempArr = angular.copy(haystack);
            for (var i = 0; i <tempArr.length; i++) {
              // handle the simple string version of tagging
              if ( $select.tagging.fct === undefined ) {
                // search the array for the match
                if ( tempArr[i]+' '+$select.taggingLabel === needle ) {
                  dupeIndex = i;
                }
                // handle the object tagging implementation
              } else {
                var mockObj = tempArr[i];
                if (angular.isObject(mockObj)) {
                  mockObj.isTag = true;
                }
                if ( angular.equals(mockObj, needle) ) {
                  dupeIndex = i;
                }
              }
            }
          }
          return dupeIndex;
        }

        $select.searchInput.on('blur', function() {
          $timeout(function() {
            $selectMultiple.activeMatchIndex = -1;
          });
        });

      }
    };
  }]);

  uis.directive('uiSelectSingle', ['$timeout','$compile', function($timeout, $compile) {
    return {
      restrict: 'EA',
      require: ['^uiSelect', '^ngModel'],
      link: function(scope, element, attrs, ctrls) {

        var $select = ctrls[0];
        var ngModel = ctrls[1];

        //From view --> model
        ngModel.$parsers.unshift(function (inputValue) {
          var locals = {},
              result;
          locals[$select.parserResult.itemName] = inputValue;
          result = $select.parserResult.modelMapper(scope, locals);
          return result;
        });

        //From model --> view
        ngModel.$formatters.unshift(function (inputValue) {
          var data = $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
              locals = {},
              result;
          if (data){
            var checkFnSingle = function(d){
              locals[$select.parserResult.itemName] = d;
              result = $select.parserResult.modelMapper(scope, locals);
              return result == inputValue;
            };
            //If possible pass same object stored in $select.selected
            if ($select.selected && checkFnSingle($select.selected)) {
              return $select.selected;
            }
            for (var i = data.length - 1; i >= 0; i--) {
              if (checkFnSingle(data[i])) return data[i];
            }
          }
          return inputValue;
        });

        //Update viewValue if model change
        scope.$watch('$select.selected', function(newValue) {
          if (ngModel.$viewValue !== newValue) {
            ngModel.$setViewValue(newValue);
          }
        });

        ngModel.$render = function() {
          $select.selected = ngModel.$viewValue;
        };

        scope.$on('uis:select', function (event, item) {
          $select.selected = item;
        });

        scope.$on('uis:close', function (event, skipFocusser) {
          $timeout(function(){
            $select.focusser.prop('disabled', false);
            if (!skipFocusser) $select.focusser[0].focus();
          },0,false);
        });

        scope.$on('uis:activate', function () {
          focusser.prop('disabled', true); //Will reactivate it on .close()
        });

        //Idea from: https://github.com/ivaynberg/select2/blob/79b5bf6db918d7560bdd959109b7bcfb47edaf43/select2.js#L1954
        var focusser = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");
        $compile(focusser)(scope);
        $select.focusser = focusser;

        //Input that will handle focus
        $select.focusInput = focusser;

        element.parent().append(focusser);
        focusser.bind("focus", function(){
          scope.$evalAsync(function(){
            $select.focus = true;
          });
        });
        focusser.bind("blur", function(){
          scope.$evalAsync(function(){
            $select.focus = false;
          });
        });
        focusser.bind("keydown", function(e){

          if (e.which === KEY.BACKSPACE) {
            e.preventDefault();
            e.stopPropagation();
            $select.select(undefined);
            scope.$apply();
            return;
          }

          if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
            return;
          }

          if (e.which == KEY.DOWN  || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE){
            e.preventDefault();
            e.stopPropagation();
            $select.activate();
          }

          scope.$digest();
        });

        focusser.bind("keyup input", function(e){

          if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {
            return;
          }

          $select.activate(focusser.val()); //User pressed some regular key, so we pass it to the search input
          focusser.val('');
          scope.$digest();

        });


      }
    };
  }]);
// Make multiple matches sortable
  uis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function($timeout, uiSelectConfig, uiSelectMinErr) {
    return {
      require: '^^uiSelect',
      link: function(scope, element, attrs, $select) {
        if (scope[attrs.uiSelectSort] === null) {
          throw uiSelectMinErr('sort', 'Expected a list to sort');
        }

        var options = angular.extend({
              axis: 'horizontal'
            },
            scope.$eval(attrs.uiSelectSortOptions));

        var axis = options.axis;
        var draggingClassName = 'dragging';
        var droppingClassName = 'dropping';
        var droppingBeforeClassName = 'dropping-before';
        var droppingAfterClassName = 'dropping-after';

        scope.$watch(function(){
          return $select.sortable;
        }, function(newValue){
          if (newValue) {
            element.attr('draggable', true);
          } else {
            element.removeAttr('draggable');
          }
        });

        element.on('dragstart', function(event) {
          element.addClass(draggingClassName);

          (event.dataTransfer || event.originalEvent.dataTransfer).setData('text', scope.$index.toString());
        });

        element.on('dragend', function() {
          element.removeClass(draggingClassName);
        });

        var move = function(from, to) {
          /*jshint validthis: true */
          this.splice(to, 0, this.splice(from, 1)[0]);
        };

        var dragOverHandler = function(event) {
          event.preventDefault();

          var offset = axis === 'vertical' ? event.offsetY || event.layerY || (event.originalEvent ? event.originalEvent.offsetY : 0) : event.offsetX || event.layerX || (event.originalEvent ? event.originalEvent.offsetX : 0);

          if (offset < (this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2)) {
            element.removeClass(droppingAfterClassName);
            element.addClass(droppingBeforeClassName);

          } else {
            element.removeClass(droppingBeforeClassName);
            element.addClass(droppingAfterClassName);
          }
        };

        var dropTimeout;

        var dropHandler = function(event) {
          event.preventDefault();

          var droppedItemIndex = parseInt((event.dataTransfer || event.originalEvent.dataTransfer).getData('text'), 10);

          // prevent event firing multiple times in firefox
          $timeout.cancel(dropTimeout);
          dropTimeout = $timeout(function() {
            _dropHandler(droppedItemIndex);
          }, 20);
        };

        var _dropHandler = function(droppedItemIndex) {
          var theList = scope.$eval(attrs.uiSelectSort);
          var itemToMove = theList[droppedItemIndex];
          var newIndex = null;

          if (element.hasClass(droppingBeforeClassName)) {
            if (droppedItemIndex < scope.$index) {
              newIndex = scope.$index - 1;
            } else {
              newIndex = scope.$index;
            }
          } else {
            if (droppedItemIndex < scope.$index) {
              newIndex = scope.$index;
            } else {
              newIndex = scope.$index + 1;
            }
          }

          move.apply(theList, [droppedItemIndex, newIndex]);

          scope.$apply(function() {
            scope.$emit('uiSelectSort:change', {
              array: theList,
              item: itemToMove,
              from: droppedItemIndex,
              to: newIndex
            });
          });

          element.removeClass(droppingClassName);
          element.removeClass(droppingBeforeClassName);
          element.removeClass(droppingAfterClassName);

          element.off('drop', dropHandler);
        };

        element.on('dragenter', function() {
          if (element.hasClass(draggingClassName)) {
            return;
          }

          element.addClass(droppingClassName);

          element.on('dragover', dragOverHandler);
          element.on('drop', dropHandler);
        });

        element.on('dragleave', function(event) {
          if (event.target != element) {
            return;
          }
          element.removeClass(droppingClassName);
          element.removeClass(droppingBeforeClassName);
          element.removeClass(droppingAfterClassName);

          element.off('dragover', dragOverHandler);
          element.off('drop', dropHandler);
        });
      }
    };
  }]);

  /**
   * Parses "repeat" attribute.
   *
   * Taken from AngularJS ngRepeat source code
   * See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211
   *
   * Original discussion about parsing "repeat" attribute instead of fully relying on ng-repeat:
   * https://github.com/angular-ui/ui-select/commit/5dd63ad#commitcomment-5504697
   */

  uis.service('uisRepeatParser', ['uiSelectMinErr','$parse', function(uiSelectMinErr, $parse) {
    var self = this;

    /**
     * Example:
     * expression = "address in addresses | filter: {street: $select.search} track by $index"
     * itemName = "address",
     * source = "addresses | filter: {street: $select.search}",
     * trackByExp = "$index",
     */
    self.parse = function(expression) {


      var match;
      //var isObjectCollection = /\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)/.test(expression);
      // If an array is used as collection

      // if (isObjectCollection){
      // 000000000000000000000000000000111111111000000000000000222222222222220033333333333333333333330000444444444444444444000000000000000055555555555000000000000000000000066666666600000000
      match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(\s*[\s\S]+?)?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);

      // 1 Alias
      // 2 Item
      // 3 Key on (key,value)
      // 4 Value on (key,value)
      // 5 Source expression (including filters)
      // 6 Track by

      if (!match) {
        throw uiSelectMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
            expression);
      }

      var source = match[5],
          filters = '';

      // When using (key,value) ui-select requires filters to be extracted, since the object
      // is converted to an array for $select.items
      // (in which case the filters need to be reapplied)
      if (match[3]) {
        // Remove any enclosing parenthesis
        source = match[5].replace(/(^\()|(\)$)/g, '');
        // match all after | but not after ||
        var filterMatch = match[5].match(/^\s*(?:[\s\S]+?)(?:[^\|]|\|\|)+([\s\S]*)\s*$/);
        if(filterMatch && filterMatch[1].trim()) {
          filters = filterMatch[1];
          source = source.replace(filters, '');
        }
      }

      return {
        itemName: match[4] || match[2], // (lhs) Left-hand side,
        keyName: match[3], //for (key, value) syntax
        source: $parse(source),
        filters: filters,
        trackByExp: match[6],
        modelMapper: $parse(match[1] || match[4] || match[2]),
        repeatExpression: function (grouped) {
          var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');
          if (this.trackByExp) {
            expression += ' track by ' + this.trackByExp;
          }
          return expression;
        }
      };

    };

    self.getGroupNgRepeatExpression = function() {
      return '$group in $select.groups';
    };

  }]);

}());
angular.module("ui.select").run(["$templateCache", function($templateCache) {$templateCache.put("bootstrap/choices.tpl.html","<ul class=\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\" role=\"listbox\" ng-show=\"$select.open\"><li class=\"ui-select-choices-group\" id=\"ui-select-choices-{{ $select.generatedId }}\"><div class=\"divider\" ng-show=\"$select.isGrouped && $index > 0\"></div><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label dropdown-header\" ng-bind=\"$group.name\"></div><div id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\" role=\"option\"><a href=\"\" class=\"ui-select-choices-row-inner\"></a></div></li></ul>");
  $templateCache.put("bootstrap/match-multiple.tpl.html","<span class=\"ui-select-match\"><span ng-repeat=\"$item in $select.selected\"><span class=\"ui-select-match-item btn btn-default btn-xs\" tabindex=\"-1\" type=\"button\" ng-disabled=\"$select.disabled\" ng-click=\"$selectMultiple.activeMatchIndex = $index;\" ng-class=\"{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span class=\"close ui-select-match-close\" ng-hide=\"$select.disabled\" ng-click=\"$selectMultiple.removeChoice($index)\">&nbsp;&times;</span> <span uis-transclude-append=\"\"></span></span></span></span>");
  $templateCache.put("bootstrap/match.tpl.html","<div class=\"ui-select-match\" ng-hide=\"$select.open\" ng-disabled=\"$select.disabled\" ng-class=\"{\'btn-default-focus\':$select.focus}\"><span tabindex=\"-1\" class=\"btn btn-default form-control ui-select-toggle\" aria-label=\"{{ $select.baseTitle }} activate\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" style=\"outline: 0;\"><span ng-show=\"$select.isEmpty()\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"ui-select-match-text pull-left\" ng-class=\"{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}\" ng-transclude=\"\"></span> <i class=\"caret pull-right\" ng-click=\"$select.toggle($event)\"></i> <a ng-show=\"$select.allowClear && !$select.isEmpty()\" aria-label=\"{{ $select.baseTitle }} clear\" style=\"margin-right: 10px\" ng-click=\"$select.clear($event)\" class=\"btn btn-xs btn-link pull-right\"><i class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></i></a></span></div>");
  $templateCache.put("bootstrap/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\" ng-class=\"{open: $select.open}\"><div><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" class=\"ui-select-search input-xs\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-click=\"$select.activate()\" ng-model=\"$select.search\" role=\"combobox\" aria-label=\"{{ $select.baseTitle }}\" ondrop=\"return false;\"></div><div class=\"ui-select-choices\"></div></div>");
  $templateCache.put("bootstrap/select.tpl.html","<div class=\"ui-select-container ui-select-bootstrap dropdown\" ng-class=\"{open: $select.open}\"><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"off\" tabindex=\"-1\" aria-expanded=\"true\" aria-label=\"{{ $select.baseTitle }}\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"form-control ui-select-search\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-show=\"$select.searchEnabled && $select.open\"><div class=\"ui-select-choices\"></div></div>");
  $templateCache.put("select2/choices.tpl.html","<ul class=\"ui-select-choices ui-select-choices-content select2-results\"><li class=\"ui-select-choices-group\" ng-class=\"{\'select2-result-with-children\': $select.choiceGrouped($group) }\"><div ng-show=\"$select.choiceGrouped($group)\" class=\"ui-select-choices-group-label select2-result-label\" ng-bind=\"$group.name\"></div><ul role=\"listbox\" id=\"ui-select-choices-{{ $select.generatedId }}\" ng-class=\"{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }\"><li role=\"option\" id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}\"><div class=\"select2-result-label ui-select-choices-row-inner\"></div></li></ul></li></ul>");
  $templateCache.put("select2/match-multiple.tpl.html","<span class=\"ui-select-match\"><li class=\"ui-select-match-item select2-search-choice\" ng-repeat=\"$item in $select.selected\" ng-class=\"{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span uis-transclude-append=\"\"></span> <a href=\"javascript:;\" class=\"ui-select-match-close select2-search-choice-close\" ng-click=\"$selectMultiple.removeChoice($index)\" tabindex=\"-1\"></a></li></span>");
  $templateCache.put("select2/match.tpl.html","<a class=\"select2-choice ui-select-match\" ng-class=\"{\'select2-default\': $select.isEmpty()}\" ng-click=\"$select.toggle($event)\" aria-label=\"{{ $select.baseTitle }} select\"><span ng-show=\"$select.isEmpty()\" class=\"select2-chosen\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"select2-chosen\" ng-transclude=\"\"></span> <abbr ng-if=\"$select.allowClear && !$select.isEmpty()\" class=\"select2-search-choice-close\" ng-click=\"$select.clear($event)\"></abbr> <span class=\"select2-arrow ui-select-toggle\"><b></b></span></a>");
  $templateCache.put("select2/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}\"><ul class=\"select2-choices\"><span class=\"ui-select-match\"></span><li class=\"select2-search-field\"><input type=\"text\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"select2-input ui-select-search\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-model=\"$select.search\" ng-click=\"$select.activate()\" style=\"width: 34px;\" ondrop=\"return false;\"></li></ul><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"ui-select-choices\"></div></div></div>");
  $templateCache.put("select2/select.tpl.html","<div class=\"ui-select-container select2 select2-container\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}\"><div class=\"ui-select-match\"></div><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"select2-search\" ng-show=\"$select.searchEnabled\"><input type=\"text\" autocomplete=\"off\" autocorrect=\"false\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"ui-select-search select2-input\" ng-model=\"$select.search\"></div><div class=\"ui-select-choices\"></div></div></div>");
  $templateCache.put("selectize/choices.tpl.html","<div ng-show=\"$select.open\" class=\"ui-select-choices ui-select-dropdown selectize-dropdown single\"><div class=\"ui-select-choices-content selectize-dropdown-content\"><div class=\"ui-select-choices-group optgroup\" role=\"listbox\"><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label optgroup-header\" ng-bind=\"$group.name\"></div><div role=\"option\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\"><div class=\"option ui-select-choices-row-inner\" data-selectable=\"\"></div></div></div></div></div>");
  $templateCache.put("selectize/match.tpl.html","<div ng-hide=\"($select.open || $select.isEmpty())\" class=\"ui-select-match\" ng-transclude=\"\"></div>");
  $templateCache.put("selectize/select.tpl.html","<div class=\"ui-select-container selectize-control single\" ng-class=\"{\'open\': $select.open}\"><div class=\"selectize-input\" ng-class=\"{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}\" ng-click=\"$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()\"><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"off\" tabindex=\"-1\" class=\"ui-select-search ui-select-toggle\" ng-click=\"$select.toggle($event)\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-hide=\"!$select.searchEnabled || ($select.selected && !$select.open)\" ng-disabled=\"$select.disabled\" aria-label=\"{{ $select.baseTitle }}\"></div><div class=\"ui-select-choices\"></div></div>");}]);
//from https://github.com/paulyoder/angular-bootstrap-show-errors - v2.3.0
(function ()
{
	var showErrorsModule;

	showErrorsModule = angular.module('ui.bootstrap.showErrors', []);

	showErrorsModule.directive('showErrors', [
	  '$timeout', 'showErrorsConfig', '$interpolate', function ($timeout, showErrorsConfig, $interpolate)
	  {
	  	var getShowSuccess, getTrigger, linkFn;
	  	getTrigger = function (options)
	  	{
	  		var trigger;
	  		trigger = showErrorsConfig.trigger;
	  		if (options && (options.trigger != null))
	  		{
	  			trigger = options.trigger;
	  		}
	  		return trigger;
	  	};
	  	getShowSuccess = function (options)
	  	{
	  		var showSuccess;
	  		showSuccess = showErrorsConfig.showSuccess;
	  		if (options && (options.showSuccess != null))
	  		{
	  			showSuccess = options.showSuccess;
	  		}
	  		return showSuccess;
	  	};
	  	linkFn = function (scope, el, attrs, formCtrl)
	  	{
	  		var blurred, inputEl, inputName, inputNgEl, options, showSuccess, toggleClasses, trigger;
	  		blurred = false;
	  		options = scope.$eval(attrs.showErrors);
	  		showSuccess = getShowSuccess(options);
	  		trigger = getTrigger(options);

			//modified by SMF - added timeout so that dynamically added fields have time to set their name attribute before this runs
			  $timeout(function()
			  {
			  	inputEl = el[0].querySelector('.form-control[name]');
			  	inputNgEl = angular.element(inputEl);
			  	inputName = $interpolate(inputNgEl.attr('name') || '')(scope);
			  	if (!inputName)
			  	{
			  		throw "show-errors element has no child input elements with a 'name' attribute and a 'form-control' class";
			  	}
			  	inputNgEl.bind(trigger, function ()
			  	{
			  		blurred = true;
			  		return toggleClasses(formCtrl[inputName].$invalid);
			  	});
			  	scope.$watch(function ()
			  	{
			  		return formCtrl[inputName] && formCtrl[inputName].$invalid;
			  	}, function (invalid)
			  	{
			  		if (!blurred)
			  		{
			  			return;
			  		}
			  		return toggleClasses(invalid);
			  	});
			  	scope.$on('show-errors-check-validity', function ()
			  	{
			  		return toggleClasses(formCtrl[inputName].$invalid);
			  	});
			  	scope.$on('show-errors-reset', function ()
			  	{
			  		return $timeout(function ()
			  		{
			  			el.removeClass('has-error');
			  			el.removeClass('has-success');
			  			return blurred = false;
			  		}, 0, false);
			  	});
			  });

	  		
	  		return toggleClasses = function (invalid)
	  		{
	  			el.toggleClass('has-error', invalid);
	  			if (showSuccess)
	  			{
	  				return el.toggleClass('has-success', !invalid);
	  			}
	  		};
	  	};
	  	return {
	  		restrict: 'A',
	  		require: '^form',
	  		compile: function (elem, attrs)
	  		{
	  			if (attrs['showErrors'].indexOf('skipFormGroupCheck') === -1)
	  			{
	  				if (!(elem.hasClass('form-group') || elem.hasClass('input-group')))
	  				{
	  					throw "show-errors element does not have the 'form-group' or 'input-group' class";
	  				}
	  			}
	  			return linkFn;
	  		}
	  	};
	  }
	]);

	showErrorsModule.provider('showErrorsConfig', function ()
	{
		var _showSuccess, _trigger;
		_showSuccess = false;
		_trigger = 'blur';
		this.showSuccess = function (showSuccess)
		{
			return _showSuccess = showSuccess;
		};
		this.trigger = function (trigger)
		{
			return _trigger = trigger;
		};
		this.$get = function ()
		{
			return {
				showSuccess: _showSuccess,
				trigger: _trigger
			};
		};
	});

}).call(this);
/*! angular-bootstrap-show-errors (version 2.3.0) 2015-01-19 */
(function () { var a; a = angular.module("ui.bootstrap.showErrors", []), a.directive("showErrors", ["$timeout", "showErrorsConfig", "$interpolate", function (a, b, c) { var d, e, f; return e = function (a) { var c; return c = b.trigger, a && null != a.trigger && (c = a.trigger), c }, d = function (a) { var c; return c = b.showSuccess, a && null != a.showSuccess && (c = a.showSuccess), c }, f = function (b, f, g, h) { var i, j, k, l, m, n, o, p; if (i = !1, m = b.$eval(g.showErrors), n = d(m), p = e(m), j = f[0].querySelector(".form-control[name]"), l = angular.element(j), k = c(l.attr("name") || "")(b), !k) throw "show-errors element has no child input elements with a 'name' attribute and a 'form-control' class"; return l.bind(p, function () { return i = !0, o(h[k].$invalid) }), b.$watch(function () { return h[k] && h[k].$invalid }, function (a) { return i ? o(a) : void 0 }), b.$on("show-errors-check-validity", function () { return o(h[k].$invalid) }), b.$on("show-errors-reset", function () { return a(function () { return f.removeClass("has-error"), f.removeClass("has-success"), i = !1 }, 0, !1) }), o = function (a) { return f.toggleClass("has-error", a), n ? f.toggleClass("has-success", !a) : void 0 } }, { restrict: "A", require: "^form", compile: function (a, b) { if (-1 === b.showErrors.indexOf("skipFormGroupCheck") && !a.hasClass("form-group") && !a.hasClass("input-group")) throw "show-errors element does not have the 'form-group' or 'input-group' class"; return f } } }]), a.provider("showErrorsConfig", function () { var a, b; a = !1, b = "blur", this.showSuccess = function (b) { return a = b }, this.trigger = function (a) { return b = a }, this.$get = function () { return { showSuccess: a, trigger: b } } }) }).call(this);
/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 1.1.0 - 2016-01-18
 * License: MIT
 */angular.module("ui.bootstrap",["ui.bootstrap.tpls","ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.isClass","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.debounce","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.paging","ui.bootstrap.pager","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]),angular.module("ui.bootstrap.tpls",["uib/template/accordion/accordion-group.html","uib/template/accordion/accordion.html","uib/template/alert/alert.html","uib/template/carousel/carousel.html","uib/template/carousel/slide.html","uib/template/datepicker/datepicker.html","uib/template/datepicker/day.html","uib/template/datepicker/month.html","uib/template/datepicker/popup.html","uib/template/datepicker/year.html","uib/template/modal/backdrop.html","uib/template/modal/window.html","uib/template/pager/pager.html","uib/template/pagination/pagination.html","uib/template/tooltip/tooltip-html-popup.html","uib/template/tooltip/tooltip-popup.html","uib/template/tooltip/tooltip-template-popup.html","uib/template/popover/popover-html.html","uib/template/popover/popover-template.html","uib/template/popover/popover.html","uib/template/progressbar/bar.html","uib/template/progressbar/progress.html","uib/template/progressbar/progressbar.html","uib/template/rating/rating.html","uib/template/tabs/tab.html","uib/template/tabs/tabset.html","uib/template/timepicker/timepicker.html","uib/template/typeahead/typeahead-match.html","uib/template/typeahead/typeahead-popup.html"]),angular.module("ui.bootstrap.collapse",[]).directive("uibCollapse",["$animate","$q","$parse","$injector",function(a,b,c,d){var e=d.has("$animateCss")?d.get("$animateCss"):null;return{link:function(d,f,g){function h(){f.hasClass("collapse")&&f.hasClass("in")||b.resolve(l(d)).then(function(){f.removeClass("collapse").addClass("collapsing").attr("aria-expanded",!0).attr("aria-hidden",!1),e?e(f,{addClass:"in",easing:"ease",to:{height:f[0].scrollHeight+"px"}}).start()["finally"](i):a.addClass(f,"in",{to:{height:f[0].scrollHeight+"px"}}).then(i)})}function i(){f.removeClass("collapsing").addClass("collapse").css({height:"auto"}),m(d)}function j(){return f.hasClass("collapse")||f.hasClass("in")?void b.resolve(n(d)).then(function(){f.css({height:f[0].scrollHeight+"px"}).removeClass("collapse").addClass("collapsing").attr("aria-expanded",!1).attr("aria-hidden",!0),e?e(f,{removeClass:"in",to:{height:"0"}}).start()["finally"](k):a.removeClass(f,"in",{to:{height:"0"}}).then(k)}):k()}function k(){f.css({height:"0"}),f.removeClass("collapsing").addClass("collapse"),o(d)}var l=c(g.expanding),m=c(g.expanded),n=c(g.collapsing),o=c(g.collapsed);d.$eval(g.uibCollapse)||f.addClass("in").addClass("collapse").attr("aria-expanded",!0).attr("aria-hidden",!1).css({height:"auto"}),d.$watch(g.uibCollapse,function(a){a?j():h()})}}}]),angular.module("ui.bootstrap.accordion",["ui.bootstrap.collapse"]).constant("uibAccordionConfig",{closeOthers:!0}).controller("UibAccordionController",["$scope","$attrs","uibAccordionConfig",function(a,b,c){this.groups=[],this.closeOthers=function(d){var e=angular.isDefined(b.closeOthers)?a.$eval(b.closeOthers):c.closeOthers;e&&angular.forEach(this.groups,function(a){a!==d&&(a.isOpen=!1)})},this.addGroup=function(a){var b=this;this.groups.push(a),a.$on("$destroy",function(c){b.removeGroup(a)})},this.removeGroup=function(a){var b=this.groups.indexOf(a);-1!==b&&this.groups.splice(b,1)}}]).directive("uibAccordion",function(){return{controller:"UibAccordionController",controllerAs:"accordion",transclude:!0,templateUrl:function(a,b){return b.templateUrl||"uib/template/accordion/accordion.html"}}}).directive("uibAccordionGroup",function(){return{require:"^uibAccordion",transclude:!0,replace:!0,templateUrl:function(a,b){return b.templateUrl||"uib/template/accordion/accordion-group.html"},scope:{heading:"@",isOpen:"=?",isDisabled:"=?"},controller:function(){this.setHeading=function(a){this.heading=a}},link:function(a,b,c,d){d.addGroup(a),a.openClass=c.openClass||"panel-open",a.panelClass=c.panelClass||"panel-default",a.$watch("isOpen",function(c){b.toggleClass(a.openClass,!!c),c&&d.closeOthers(a)}),a.toggleOpen=function(b){a.isDisabled||b&&32!==b.which||(a.isOpen=!a.isOpen)}}}}).directive("uibAccordionHeading",function(){return{transclude:!0,template:"",replace:!0,require:"^uibAccordionGroup",link:function(a,b,c,d,e){d.setHeading(e(a,angular.noop))}}}).directive("uibAccordionTransclude",function(){return{require:"^uibAccordionGroup",link:function(a,b,c,d){a.$watch(function(){return d[c.uibAccordionTransclude]},function(a){a&&(b.find("span").html(""),b.find("span").append(a))})}}}),angular.module("ui.bootstrap.alert",[]).controller("UibAlertController",["$scope","$attrs","$interpolate","$timeout",function(a,b,c,d){a.closeable=!!b.close;var e=angular.isDefined(b.dismissOnTimeout)?c(b.dismissOnTimeout)(a.$parent):null;e&&d(function(){a.close()},parseInt(e,10))}]).directive("uibAlert",function(){return{controller:"UibAlertController",controllerAs:"alert",templateUrl:function(a,b){return b.templateUrl||"uib/template/alert/alert.html"},transclude:!0,replace:!0,scope:{type:"@",close:"&"}}}),angular.module("ui.bootstrap.buttons",[]).constant("uibButtonConfig",{activeClass:"active",toggleEvent:"click"}).controller("UibButtonsController",["uibButtonConfig",function(a){this.activeClass=a.activeClass||"active",this.toggleEvent=a.toggleEvent||"click"}]).directive("uibBtnRadio",["$parse",function(a){return{require:["uibBtnRadio","ngModel"],controller:"UibButtonsController",controllerAs:"buttons",link:function(b,c,d,e){var f=e[0],g=e[1],h=a(d.uibUncheckable);c.find("input").css({display:"none"}),g.$render=function(){c.toggleClass(f.activeClass,angular.equals(g.$modelValue,b.$eval(d.uibBtnRadio)))},c.on(f.toggleEvent,function(){if(!d.disabled){var a=c.hasClass(f.activeClass);(!a||angular.isDefined(d.uncheckable))&&b.$apply(function(){g.$setViewValue(a?null:b.$eval(d.uibBtnRadio)),g.$render()})}}),d.uibUncheckable&&b.$watch(h,function(a){d.$set("uncheckable",a?"":null)})}}}]).directive("uibBtnCheckbox",function(){return{require:["uibBtnCheckbox","ngModel"],controller:"UibButtonsController",controllerAs:"button",link:function(a,b,c,d){function e(){return g(c.btnCheckboxTrue,!0)}function f(){return g(c.btnCheckboxFalse,!1)}function g(b,c){return angular.isDefined(b)?a.$eval(b):c}var h=d[0],i=d[1];b.find("input").css({display:"none"}),i.$render=function(){b.toggleClass(h.activeClass,angular.equals(i.$modelValue,e()))},b.on(h.toggleEvent,function(){c.disabled||a.$apply(function(){i.$setViewValue(b.hasClass(h.activeClass)?f():e()),i.$render()})})}}}),angular.module("ui.bootstrap.carousel",[]).controller("UibCarouselController",["$scope","$element","$interval","$timeout","$animate",function(a,b,c,d,e){function f(){for(;s.length;)s.shift()}function g(a){if(angular.isUndefined(p[a].index))return p[a];for(var b=0,c=p.length;c>b;++b)if(p[b].index===a)return p[b]}function h(c,d,g){t||(angular.extend(c,{direction:g,active:!0}),angular.extend(o.currentSlide||{},{direction:g,active:!1}),e.enabled(b)&&!a.$currentTransition&&c.$element&&o.slides.length>1&&(c.$element.data(q,c.direction),o.currentSlide&&o.currentSlide.$element&&o.currentSlide.$element.data(q,c.direction),a.$currentTransition=!0,e.on("addClass",c.$element,function(b,c){if("close"===c&&(a.$currentTransition=null,e.off("addClass",b),s.length)){var d=s.pop(),g=a.indexOfSlide(d),i=g>o.getCurrentIndex()?"next":"prev";f(),h(d,g,i)}})),o.currentSlide=c,r=d,k())}function i(){m&&(c.cancel(m),m=null)}function j(b){b.length||(a.$currentTransition=null,f())}function k(){i();var b=+a.interval;!isNaN(b)&&b>0&&(m=c(l,b))}function l(){var b=+a.interval;n&&!isNaN(b)&&b>0&&p.length?a.next():a.pause()}var m,n,o=this,p=o.slides=a.slides=[],q="uib-slideDirection",r=-1,s=[];o.currentSlide=null;var t=!1;o.addSlide=function(b,c){b.$element=c,p.push(b),1===p.length||b.active?(a.$currentTransition&&(a.$currentTransition=null),o.select(p[p.length-1]),1===p.length&&a.play()):b.active=!1},o.getCurrentIndex=function(){return o.currentSlide&&angular.isDefined(o.currentSlide.index)?+o.currentSlide.index:r},o.next=a.next=function(){var b=(o.getCurrentIndex()+1)%p.length;return 0===b&&a.noWrap()?void a.pause():o.select(g(b),"next")},o.prev=a.prev=function(){var b=o.getCurrentIndex()-1<0?p.length-1:o.getCurrentIndex()-1;return a.noWrap()&&b===p.length-1?void a.pause():o.select(g(b),"prev")},o.removeSlide=function(a){angular.isDefined(a.index)&&p.sort(function(a,b){return+a.index>+b.index});var b=s.indexOf(a);-1!==b&&s.splice(b,1);var c=p.indexOf(a);p.splice(c,1),d(function(){p.length>0&&a.active?c>=p.length?o.select(p[c-1]):o.select(p[c]):r>c&&r--}),0===p.length&&(o.currentSlide=null,f())},o.select=a.select=function(b,c){var d=a.indexOfSlide(b);void 0===c&&(c=d>o.getCurrentIndex()?"next":"prev"),b&&b!==o.currentSlide&&!a.$currentTransition?h(b,d,c):b&&b!==o.currentSlide&&a.$currentTransition&&(s.push(b),b.active=!1)},a.indexOfSlide=function(a){return angular.isDefined(a.index)?+a.index:p.indexOf(a)},a.isActive=function(a){return o.currentSlide===a},a.pause=function(){a.noPause||(n=!1,i())},a.play=function(){n||(n=!0,k())},a.$on("$destroy",function(){t=!0,i()}),a.$watch("noTransition",function(a){e.enabled(b,!a)}),a.$watch("interval",k),a.$watchCollection("slides",j)}]).directive("uibCarousel",function(){return{transclude:!0,replace:!0,controller:"UibCarouselController",controllerAs:"carousel",templateUrl:function(a,b){return b.templateUrl||"uib/template/carousel/carousel.html"},scope:{interval:"=",noTransition:"=",noPause:"=",noWrap:"&"}}}).directive("uibSlide",function(){return{require:"^uibCarousel",transclude:!0,replace:!0,templateUrl:function(a,b){return b.templateUrl||"uib/template/carousel/slide.html"},scope:{active:"=?",actual:"=?",index:"=?"},link:function(a,b,c,d){d.addSlide(a,b),a.$on("$destroy",function(){d.removeSlide(a)}),a.$watch("active",function(b){b&&d.select(a)})}}}).animation(".item",["$animateCss",function(a){function b(a,b,c){a.removeClass(b),c&&c()}var c="uib-slideDirection";return{beforeAddClass:function(d,e,f){if("active"===e){var g=!1,h=d.data(c),i="next"===h?"left":"right",j=b.bind(this,d,i+" "+h,f);return d.addClass(h),a(d,{addClass:i}).start().done(j),function(){g=!0}}f()},beforeRemoveClass:function(d,e,f){if("active"===e){var g=!1,h=d.data(c),i="next"===h?"left":"right",j=b.bind(this,d,i,f);return a(d,{addClass:i}).start().done(j),function(){g=!0}}f()}}}]),angular.module("ui.bootstrap.dateparser",[]).service("uibDateParser",["$log","$locale","orderByFilter",function(a,b,c){function d(a){var b=[],d=a.split(""),e=a.indexOf("'");if(e>-1){var f=!1;a=a.split("");for(var g=e;g<a.length;g++)f?("'"===a[g]&&(g+1<a.length&&"'"===a[g+1]?(a[g+1]="$",d[g+1]=""):(d[g]="",f=!1)),a[g]="$"):"'"===a[g]&&(a[g]="$",d[g]="",f=!0);a=a.join("")}return angular.forEach(m,function(c){var e=a.indexOf(c.key);if(e>-1){a=a.split(""),d[e]="("+c.regex+")",a[e]="$";for(var f=e+1,g=e+c.key.length;g>f;f++)d[f]="",a[f]="$";a=a.join(""),b.push({index:e,apply:c.apply,matcher:c.regex})}}),{regex:new RegExp("^"+d.join("")+"$"),map:c(b,"index")}}function e(a,b,c){return 1>c?!1:1===b&&c>28?29===c&&(a%4===0&&a%100!==0||a%400===0):3===b||5===b||8===b||10===b?31>c:!0}function f(a){return parseInt(a,10)}function g(a,b){return a&&b?k(a,b):a}function h(a,b){return a&&b?k(a,b,!0):a}function i(a,b){var c=Date.parse("Jan 01, 1970 00:00:00 "+a)/6e4;return isNaN(c)?b:c}function j(a,b){return a=new Date(a.getTime()),a.setMinutes(a.getMinutes()+b),a}function k(a,b,c){c=c?-1:1;var d=i(b,a.getTimezoneOffset());return j(a,c*(d-a.getTimezoneOffset()))}var l,m,n=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;this.init=function(){l=b.id,this.parsers={},m=[{key:"yyyy",regex:"\\d{4}",apply:function(a){this.year=+a}},{key:"yy",regex:"\\d{2}",apply:function(a){this.year=+a+2e3}},{key:"y",regex:"\\d{1,4}",apply:function(a){this.year=+a}},{key:"M!",regex:"0?[1-9]|1[0-2]",apply:function(a){this.month=a-1}},{key:"MMMM",regex:b.DATETIME_FORMATS.MONTH.join("|"),apply:function(a){this.month=b.DATETIME_FORMATS.MONTH.indexOf(a)}},{key:"MMM",regex:b.DATETIME_FORMATS.SHORTMONTH.join("|"),apply:function(a){this.month=b.DATETIME_FORMATS.SHORTMONTH.indexOf(a)}},{key:"MM",regex:"0[1-9]|1[0-2]",apply:function(a){this.month=a-1}},{key:"M",regex:"[1-9]|1[0-2]",apply:function(a){this.month=a-1}},{key:"d!",regex:"[0-2]?[0-9]{1}|3[0-1]{1}",apply:function(a){this.date=+a}},{key:"dd",regex:"[0-2][0-9]{1}|3[0-1]{1}",apply:function(a){this.date=+a}},{key:"d",regex:"[1-2]?[0-9]{1}|3[0-1]{1}",apply:function(a){this.date=+a}},{key:"EEEE",regex:b.DATETIME_FORMATS.DAY.join("|")},{key:"EEE",regex:b.DATETIME_FORMATS.SHORTDAY.join("|")},{key:"HH",regex:"(?:0|1)[0-9]|2[0-3]",apply:function(a){this.hours=+a}},{key:"hh",regex:"0[0-9]|1[0-2]",apply:function(a){this.hours=+a}},{key:"H",regex:"1?[0-9]|2[0-3]",apply:function(a){this.hours=+a}},{key:"h",regex:"[0-9]|1[0-2]",apply:function(a){this.hours=+a}},{key:"mm",regex:"[0-5][0-9]",apply:function(a){this.minutes=+a}},{key:"m",regex:"[0-9]|[1-5][0-9]",apply:function(a){this.minutes=+a}},{key:"sss",regex:"[0-9][0-9][0-9]",apply:function(a){this.milliseconds=+a}},{key:"ss",regex:"[0-5][0-9]",apply:function(a){this.seconds=+a}},{key:"s",regex:"[0-9]|[1-5][0-9]",apply:function(a){this.seconds=+a}},{key:"a",regex:b.DATETIME_FORMATS.AMPMS.join("|"),apply:function(a){12===this.hours&&(this.hours=0),"PM"===a&&(this.hours+=12)}},{key:"Z",regex:"[+-]\\d{4}",apply:function(a){var b=a.match(/([+-])(\d{2})(\d{2})/),c=b[1],d=b[2],e=b[3];this.hours+=f(c+d),this.minutes+=f(c+e)}},{key:"ww",regex:"[0-4][0-9]|5[0-3]"},{key:"w",regex:"[0-9]|[1-4][0-9]|5[0-3]"},{key:"GGGG",regex:b.DATETIME_FORMATS.ERANAMES.join("|").replace(/\s/g,"\\s")},{key:"GGG",regex:b.DATETIME_FORMATS.ERAS.join("|")},{key:"GG",regex:b.DATETIME_FORMATS.ERAS.join("|")},{key:"G",regex:b.DATETIME_FORMATS.ERAS.join("|")}]},this.init(),this.parse=function(c,f,g){if(!angular.isString(c)||!f)return c;f=b.DATETIME_FORMATS[f]||f,f=f.replace(n,"\\$&"),b.id!==l&&this.init(),this.parsers[f]||(this.parsers[f]=d(f));var h=this.parsers[f],i=h.regex,j=h.map,k=c.match(i),m=!1;if(k&&k.length){var o,p;angular.isDate(g)&&!isNaN(g.getTime())?o={year:g.getFullYear(),month:g.getMonth(),date:g.getDate(),hours:g.getHours(),minutes:g.getMinutes(),seconds:g.getSeconds(),milliseconds:g.getMilliseconds()}:(g&&a.warn("dateparser:","baseDate is not a valid date"),o={year:1900,month:0,date:1,hours:0,minutes:0,seconds:0,milliseconds:0});for(var q=1,r=k.length;r>q;q++){var s=j[q-1];"Z"===s.matcher&&(m=!0),s.apply&&s.apply.call(o,k[q])}var t=m?Date.prototype.setUTCFullYear:Date.prototype.setFullYear,u=m?Date.prototype.setUTCHours:Date.prototype.setHours;return e(o.year,o.month,o.date)&&(!angular.isDate(g)||isNaN(g.getTime())||m?(p=new Date(0),t.call(p,o.year,o.month,o.date),u.call(p,o.hours||0,o.minutes||0,o.seconds||0,o.milliseconds||0)):(p=new Date(g),t.call(p,o.year,o.month,o.date),u.call(p,o.hours,o.minutes,o.seconds,o.milliseconds))),p}},this.toTimezone=g,this.fromTimezone=h,this.timezoneToOffset=i,this.addDateMinutes=j,this.convertTimezoneToLocal=k}]),angular.module("ui.bootstrap.isClass",[]).directive("uibIsClass",["$animate",function(a){var b=/^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/,c=/^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;return{restrict:"A",compile:function(d,e){function f(a,b,c){i.push(a),j.push({scope:a,element:b}),o.forEach(function(b,c){g(b,a)}),a.$on("$destroy",h)}function g(b,d){var e=b.match(c),f=d.$eval(e[1]),g=e[2],h=k[b];if(!h){var i=function(b){var c=null;j.some(function(a){var d=a.scope.$eval(m);return d===b?(c=a,!0):void 0}),h.lastActivated!==c&&(h.lastActivated&&a.removeClass(h.lastActivated.element,f),c&&a.addClass(c.element,f),h.lastActivated=c)};k[b]=h={lastActivated:null,scope:d,watchFn:i,compareWithExp:g,watcher:d.$watch(g,i)}}h.watchFn(d.$eval(g))}function h(a){var b=a.targetScope,c=i.indexOf(b);if(i.splice(c,1),j.splice(c,1),i.length){var d=i[0];angular.forEach(k,function(a){a.scope===b&&(a.watcher=d.$watch(a.compareWithExp,a.watchFn),a.scope=d)})}else k={}}var i=[],j=[],k={},l=e.uibIsClass.match(b),m=l[2],n=l[1],o=n.split(",");return f}}}]),angular.module("ui.bootstrap.position",[]).factory("$uibPosition",["$document","$window",function(a,b){var c,d={normal:/(auto|scroll)/,hidden:/(auto|scroll|hidden)/},e={auto:/\s?auto?\s?/i,primary:/^(top|bottom|left|right)$/,secondary:/^(top|bottom|left|right|center)$/,vertical:/^(top|bottom)$/};return{getRawNode:function(a){return a[0]||a},parseStyle:function(a){return a=parseFloat(a),isFinite(a)?a:0},offsetParent:function(c){function d(a){return"static"===(b.getComputedStyle(a).position||"static")}c=this.getRawNode(c);for(var e=c.offsetParent||a[0].documentElement;e&&e!==a[0].documentElement&&d(e);)e=e.offsetParent;return e||a[0].documentElement},scrollbarWidth:function(){if(angular.isUndefined(c)){var b=angular.element('<div style="position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;"></div>');a.find("body").append(b),c=b[0].offsetWidth-b[0].clientWidth,c=isFinite(c)?c:0,b.remove()}return c},scrollParent:function(c,e){c=this.getRawNode(c);var f=e?d.hidden:d.normal,g=a[0].documentElement,h=b.getComputedStyle(c),i="absolute"===h.position,j=c.parentElement||g;if(j===g||"fixed"===h.position)return g;for(;j.parentElement&&j!==g;){var k=b.getComputedStyle(j);if(i&&"static"!==k.position&&(i=!1),!i&&f.test(k.overflow+k.overflowY+k.overflowX))break;j=j.parentElement}return j},position:function(c,d){c=this.getRawNode(c);var e=this.offset(c);if(d){var f=b.getComputedStyle(c);e.top-=this.parseStyle(f.marginTop),e.left-=this.parseStyle(f.marginLeft)}var g=this.offsetParent(c),h={top:0,left:0};return g!==a[0].documentElement&&(h=this.offset(g),h.top+=g.clientTop-g.scrollTop,h.left+=g.clientLeft-g.scrollLeft),{width:Math.round(angular.isNumber(e.width)?e.width:c.offsetWidth),height:Math.round(angular.isNumber(e.height)?e.height:c.offsetHeight),top:Math.round(e.top-h.top),left:Math.round(e.left-h.left)}},offset:function(c){c=this.getRawNode(c);var d=c.getBoundingClientRect();return{width:Math.round(angular.isNumber(d.width)?d.width:c.offsetWidth),height:Math.round(angular.isNumber(d.height)?d.height:c.offsetHeight),top:Math.round(d.top+(b.pageYOffset||a[0].documentElement.scrollTop)),left:Math.round(d.left+(b.pageXOffset||a[0].documentElement.scrollLeft))}},viewportOffset:function(c,d,e){c=this.getRawNode(c),e=e!==!1?!0:!1;var f=c.getBoundingClientRect(),g={top:0,left:0,bottom:0,right:0},h=d?a[0].documentElement:this.scrollParent(c),i=h.getBoundingClientRect();if(g.top=i.top+h.clientTop,g.left=i.left+h.clientLeft,h===a[0].documentElement&&(g.top+=b.pageYOffset,g.left+=b.pageXOffset),g.bottom=g.top+h.clientHeight,g.right=g.left+h.clientWidth,e){var j=b.getComputedStyle(h);g.top+=this.parseStyle(j.paddingTop),g.bottom-=this.parseStyle(j.paddingBottom),g.left+=this.parseStyle(j.paddingLeft),g.right-=this.parseStyle(j.paddingRight)}return{top:Math.round(f.top-g.top),bottom:Math.round(g.bottom-f.bottom),left:Math.round(f.left-g.left),right:Math.round(g.right-f.right)}},parsePlacement:function(a){var b=e.auto.test(a);return b&&(a=a.replace(e.auto,"")),a=a.split("-"),a[0]=a[0]||"top",e.primary.test(a[0])||(a[0]="top"),a[1]=a[1]||"center",e.secondary.test(a[1])||(a[1]="center"),b?a[2]=!0:a[2]=!1,a},positionElements:function(a,c,d,f){a=this.getRawNode(a),c=this.getRawNode(c);var g=angular.isDefined(c.offsetWidth)?c.offsetWidth:c.prop("offsetWidth"),h=angular.isDefined(c.offsetHeight)?c.offsetHeight:c.prop("offsetHeight");d=this.parsePlacement(d);var i=f?this.offset(a):this.position(a),j={top:0,left:0,placement:""};if(d[2]){var k=this.viewportOffset(a),l=b.getComputedStyle(c),m={width:g+Math.round(Math.abs(this.parseStyle(l.marginLeft)+this.parseStyle(l.marginRight))),height:h+Math.round(Math.abs(this.parseStyle(l.marginTop)+this.parseStyle(l.marginBottom)))};if(d[0]="top"===d[0]&&m.height>k.top&&m.height<=k.bottom?"bottom":"bottom"===d[0]&&m.height>k.bottom&&m.height<=k.top?"top":"left"===d[0]&&m.width>k.left&&m.width<=k.right?"right":"right"===d[0]&&m.width>k.right&&m.width<=k.left?"left":d[0],d[1]="top"===d[1]&&m.height-i.height>k.bottom&&m.height-i.height<=k.top?"bottom":"bottom"===d[1]&&m.height-i.height>k.top&&m.height-i.height<=k.bottom?"top":"left"===d[1]&&m.width-i.width>k.right&&m.width-i.width<=k.left?"right":"right"===d[1]&&m.width-i.width>k.left&&m.width-i.width<=k.right?"left":d[1],"center"===d[1])if(e.vertical.test(d[0])){var n=i.width/2-g/2;k.left+n<0&&m.width-i.width<=k.right?d[1]="left":k.right+n<0&&m.width-i.width<=k.left&&(d[1]="right")}else{var o=i.height/2-m.height/2;k.top+o<0&&m.height-i.height<=k.bottom?d[1]="top":k.bottom+o<0&&m.height-i.height<=k.top&&(d[1]="bottom")}}switch(d[0]){case"top":j.top=i.top-h;break;case"bottom":j.top=i.top+i.height;break;case"left":j.left=i.left-g;break;case"right":j.left=i.left+i.width}switch(d[1]){case"top":j.top=i.top;break;case"bottom":j.top=i.top+i.height-h;break;case"left":j.left=i.left;break;case"right":j.left=i.left+i.width-g;break;case"center":e.vertical.test(d[0])?j.left=i.left+i.width/2-g/2:j.top=i.top+i.height/2-h/2}return j.top=Math.round(j.top),j.left=Math.round(j.left),j.placement="center"===d[1]?d[0]:d[0]+"-"+d[1],j},positionArrow:function(a,c){a=this.getRawNode(a);var d=a.querySelector(".tooltip-inner, .popover-inner");if(d){var f=angular.element(d).hasClass("tooltip-inner"),g=f?a.querySelector(".tooltip-arrow"):a.querySelector(".arrow");if(g){if(c=this.parsePlacement(c),"center"===c[1])return void angular.element(g).css({top:"",bottom:"",right:"",left:"",margin:""});var h="border-"+c[0]+"-width",i=b.getComputedStyle(g)[h],j="border-";j+=e.vertical.test(c[0])?c[0]+"-"+c[1]:c[1]+"-"+c[0],j+="-radius";var k=b.getComputedStyle(f?d:a)[j],l={top:"auto",bottom:"auto",left:"auto",right:"auto",margin:0};switch(c[0]){case"top":l.bottom=f?"0":"-"+i;break;case"bottom":l.top=f?"0":"-"+i;break;case"left":l.right=f?"0":"-"+i;break;case"right":l.left=f?"0":"-"+i}l[c[1]]=k,angular.element(g).css(l)}}}}}]),angular.module("ui.bootstrap.datepicker",["ui.bootstrap.dateparser","ui.bootstrap.isClass","ui.bootstrap.position"]).value("$datepickerSuppressError",!1).constant("uibDatepickerConfig",{datepickerMode:"day",formatDay:"dd",formatMonth:"MMMM",formatYear:"yyyy",formatDayHeader:"EEE",formatDayTitle:"MMMM yyyy",formatMonthTitle:"yyyy",maxDate:null,maxMode:"year",minDate:null,minMode:"day",ngModelOptions:{},shortcutPropagation:!1,showWeeks:!0,yearColumns:5,yearRows:4}).controller("UibDatepickerController",["$scope","$attrs","$parse","$interpolate","$locale","$log","dateFilter","uibDatepickerConfig","$datepickerSuppressError","uibDateParser",function(a,b,c,d,e,f,g,h,i,j){var k=this,l={$setViewValue:angular.noop},m={},n=[];this.modes=["day","month","year"],angular.forEach(["formatDay","formatMonth","formatYear","formatDayHeader","formatDayTitle","formatMonthTitle"],function(c){k[c]=angular.isDefined(b[c])?d(b[c])(a.$parent):h[c]}),angular.forEach(["showWeeks","yearRows","yearColumns","shortcutPropagation"],function(c){k[c]=angular.isDefined(b[c])?a.$parent.$eval(b[c]):h[c]}),angular.isDefined(b.startingDay)?k.startingDay=a.$parent.$eval(b.startingDay):angular.isNumber(h.startingDay)?k.startingDay=h.startingDay:k.startingDay=(e.DATETIME_FORMATS.FIRSTDAYOFWEEK+8)%7,angular.forEach(["minDate","maxDate"],function(c){b[c]?n.push(a.$parent.$watch(b[c],function(a){k[c]=a?angular.isDate(a)?j.fromTimezone(new Date(a),m.timezone):new Date(g(a,"medium")):null,k.refreshView()})):k[c]=h[c]?j.fromTimezone(new Date(h[c]),m.timezone):null}),angular.forEach(["minMode","maxMode"],function(c){b[c]?n.push(a.$parent.$watch(b[c],function(d){k[c]=a[c]=angular.isDefined(d)?d:b[c],("minMode"===c&&k.modes.indexOf(a.datepickerMode)<k.modes.indexOf(k[c])||"maxMode"===c&&k.modes.indexOf(a.datepickerMode)>k.modes.indexOf(k[c]))&&(a.datepickerMode=k[c])})):k[c]=a[c]=h[c]||null}),a.datepickerMode=a.datepickerMode||h.datepickerMode,a.uniqueId="datepicker-"+a.$id+"-"+Math.floor(1e4*Math.random()),angular.isDefined(b.initDate)?(this.activeDate=j.fromTimezone(a.$parent.$eval(b.initDate),m.timezone)||new Date,n.push(a.$parent.$watch(b.initDate,function(a){a&&(l.$isEmpty(l.$modelValue)||l.$invalid)&&(k.activeDate=j.fromTimezone(a,m.timezone),k.refreshView())}))):this.activeDate=new Date,a.disabled=angular.isDefined(b.disabled)||!1,angular.isDefined(b.ngDisabled)&&n.push(a.$parent.$watch(b.ngDisabled,function(b){a.disabled=b,k.refreshView()})),a.isActive=function(b){return 0===k.compare(b.date,k.activeDate)?(a.activeDateId=b.uid,!0):!1},this.init=function(a){l=a,m=a.$options||h.ngModelOptions,l.$modelValue&&(this.activeDate=l.$modelValue),l.$render=function(){k.render()}},this.render=function(){if(l.$viewValue){var a=new Date(l.$viewValue),b=!isNaN(a);b?this.activeDate=j.fromTimezone(a,m.timezone):i||f.error('Datepicker directive: "ng-model" value must be a Date object')}this.refreshView()},this.refreshView=function(){if(this.element){a.selectedDt=null,this._refreshView(),a.activeDt&&(a.activeDateId=a.activeDt.uid);var b=l.$viewValue?new Date(l.$viewValue):null;b=j.fromTimezone(b,m.timezone),l.$setValidity("dateDisabled",!b||this.element&&!this.isDisabled(b))}},this.createDateObject=function(b,c){var d=l.$viewValue?new Date(l.$viewValue):null;d=j.fromTimezone(d,m.timezone);var e={date:b,label:g(b,c.replace(/d!/,"dd")).replace(/M!/,"MM"),selected:d&&0===this.compare(b,d),disabled:this.isDisabled(b),current:0===this.compare(b,new Date),customClass:this.customClass(b)||null};return d&&0===this.compare(b,d)&&(a.selectedDt=e),k.activeDate&&0===this.compare(e.date,k.activeDate)&&(a.activeDt=e),e},this.isDisabled=function(c){return a.disabled||this.minDate&&this.compare(c,this.minDate)<0||this.maxDate&&this.compare(c,this.maxDate)>0||b.dateDisabled&&a.dateDisabled({date:c,mode:a.datepickerMode})},this.customClass=function(b){return a.customClass({date:b,mode:a.datepickerMode})},this.split=function(a,b){for(var c=[];a.length>0;)c.push(a.splice(0,b));return c},a.select=function(b){if(a.datepickerMode===k.minMode){var c=l.$viewValue?j.fromTimezone(new Date(l.$viewValue),m.timezone):new Date(0,0,0,0,0,0,0);c.setFullYear(b.getFullYear(),b.getMonth(),b.getDate()),c=j.toTimezone(c,m.timezone),l.$setViewValue(c),l.$render()}else k.activeDate=b,a.datepickerMode=k.modes[k.modes.indexOf(a.datepickerMode)-1]},a.move=function(a){var b=k.activeDate.getFullYear()+a*(k.step.years||0),c=k.activeDate.getMonth()+a*(k.step.months||0);k.activeDate.setFullYear(b,c,1),k.refreshView()},a.toggleMode=function(b){b=b||1,a.datepickerMode===k.maxMode&&1===b||a.datepickerMode===k.minMode&&-1===b||(a.datepickerMode=k.modes[k.modes.indexOf(a.datepickerMode)+b])},a.keys={13:"enter",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down"};var o=function(){k.element[0].focus()};a.$on("uib:datepicker.focus",o),a.keydown=function(b){var c=a.keys[b.which];if(c&&!b.shiftKey&&!b.altKey&&!a.disabled)if(b.preventDefault(),k.shortcutPropagation||b.stopPropagation(),"enter"===c||"space"===c){if(k.isDisabled(k.activeDate))return;a.select(k.activeDate)}else!b.ctrlKey||"up"!==c&&"down"!==c?(k.handleKeyDown(c,b),k.refreshView()):a.toggleMode("up"===c?1:-1)},a.$on("$destroy",function(){for(;n.length;)n.shift()()})}]).controller("UibDaypickerController",["$scope","$element","dateFilter",function(a,b,c){function d(a,b){return 1!==b||a%4!==0||a%100===0&&a%400!==0?f[b]:29}function e(a){var b=new Date(a);b.setDate(b.getDate()+4-(b.getDay()||7));var c=b.getTime();return b.setMonth(0),b.setDate(1),Math.floor(Math.round((c-b)/864e5)/7)+1}var f=[31,28,31,30,31,30,31,31,30,31,30,31];this.step={months:1},this.element=b,this.init=function(b){angular.extend(b,this),a.showWeeks=b.showWeeks,b.refreshView()},this.getDates=function(a,b){for(var c,d=new Array(b),e=new Date(a),f=0;b>f;)c=new Date(e),d[f++]=c,e.setDate(e.getDate()+1);return d},this._refreshView=function(){var b=this.activeDate.getFullYear(),d=this.activeDate.getMonth(),f=new Date(this.activeDate);f.setFullYear(b,d,1);var g=this.startingDay-f.getDay(),h=g>0?7-g:-g,i=new Date(f);h>0&&i.setDate(-h+1);for(var j=this.getDates(i,42),k=0;42>k;k++)j[k]=angular.extend(this.createDateObject(j[k],this.formatDay),{secondary:j[k].getMonth()!==d,uid:a.uniqueId+"-"+k});a.labels=new Array(7);for(var l=0;7>l;l++)a.labels[l]={abbr:c(j[l].date,this.formatDayHeader),full:c(j[l].date,"EEEE")};if(a.title=c(this.activeDate,this.formatDayTitle),a.rows=this.split(j,7),a.showWeeks){a.weekNumbers=[];for(var m=(11-this.startingDay)%7,n=a.rows.length,o=0;n>o;o++)a.weekNumbers.push(e(a.rows[o][m].date))}},this.compare=function(a,b){var c=new Date(a.getFullYear(),a.getMonth(),a.getDate()),d=new Date(b.getFullYear(),b.getMonth(),b.getDate());return c.setFullYear(a.getFullYear()),d.setFullYear(b.getFullYear()),c-d},this.handleKeyDown=function(a,b){var c=this.activeDate.getDate();if("left"===a)c-=1;else if("up"===a)c-=7;else if("right"===a)c+=1;else if("down"===a)c+=7;else if("pageup"===a||"pagedown"===a){var e=this.activeDate.getMonth()+("pageup"===a?-1:1);this.activeDate.setMonth(e,1),c=Math.min(d(this.activeDate.getFullYear(),this.activeDate.getMonth()),c)}else"home"===a?c=1:"end"===a&&(c=d(this.activeDate.getFullYear(),this.activeDate.getMonth()));this.activeDate.setDate(c)}}]).controller("UibMonthpickerController",["$scope","$element","dateFilter",function(a,b,c){this.step={years:1},this.element=b,this.init=function(a){angular.extend(a,this),a.refreshView()},this._refreshView=function(){for(var b,d=new Array(12),e=this.activeDate.getFullYear(),f=0;12>f;f++)b=new Date(this.activeDate),b.setFullYear(e,f,1),d[f]=angular.extend(this.createDateObject(b,this.formatMonth),{uid:a.uniqueId+"-"+f});a.title=c(this.activeDate,this.formatMonthTitle),a.rows=this.split(d,3)},this.compare=function(a,b){var c=new Date(a.getFullYear(),a.getMonth()),d=new Date(b.getFullYear(),b.getMonth());return c.setFullYear(a.getFullYear()),d.setFullYear(b.getFullYear()),c-d},this.handleKeyDown=function(a,b){var c=this.activeDate.getMonth();if("left"===a)c-=1;else if("up"===a)c-=3;else if("right"===a)c+=1;else if("down"===a)c+=3;else if("pageup"===a||"pagedown"===a){var d=this.activeDate.getFullYear()+("pageup"===a?-1:1);this.activeDate.setFullYear(d)}else"home"===a?c=0:"end"===a&&(c=11);this.activeDate.setMonth(c)}}]).controller("UibYearpickerController",["$scope","$element","dateFilter",function(a,b,c){function d(a){return parseInt((a-1)/f,10)*f+1}var e,f;this.element=b,this.yearpickerInit=function(){e=this.yearColumns,f=this.yearRows*e,this.step={years:f}},this._refreshView=function(){for(var b,c=new Array(f),g=0,h=d(this.activeDate.getFullYear());f>g;g++)b=new Date(this.activeDate),b.setFullYear(h+g,0,1),c[g]=angular.extend(this.createDateObject(b,this.formatYear),{uid:a.uniqueId+"-"+g});a.title=[c[0].label,c[f-1].label].join(" - "),a.rows=this.split(c,e),a.columns=e},this.compare=function(a,b){return a.getFullYear()-b.getFullYear()},this.handleKeyDown=function(a,b){var c=this.activeDate.getFullYear();"left"===a?c-=1:"up"===a?c-=e:"right"===a?c+=1:"down"===a?c+=e:"pageup"===a||"pagedown"===a?c+=("pageup"===a?-1:1)*f:"home"===a?c=d(this.activeDate.getFullYear()):"end"===a&&(c=d(this.activeDate.getFullYear())+f-1),this.activeDate.setFullYear(c)}}]).directive("uibDatepicker",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||"uib/template/datepicker/datepicker.html"},scope:{datepickerMode:"=?",dateDisabled:"&",customClass:"&",shortcutPropagation:"&?"},require:["uibDatepicker","^ngModel"],controller:"UibDatepickerController",controllerAs:"datepicker",link:function(a,b,c,d){var e=d[0],f=d[1];e.init(f)}}}).directive("uibDaypicker",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||"uib/template/datepicker/day.html";
},require:["^uibDatepicker","uibDaypicker"],controller:"UibDaypickerController",link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive("uibMonthpicker",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||"uib/template/datepicker/month.html"},require:["^uibDatepicker","uibMonthpicker"],controller:"UibMonthpickerController",link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive("uibYearpicker",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||"uib/template/datepicker/year.html"},require:["^uibDatepicker","uibYearpicker"],controller:"UibYearpickerController",link:function(a,b,c,d){var e=d[0];angular.extend(e,d[1]),e.yearpickerInit(),e.refreshView()}}}).constant("uibDatepickerPopupConfig",{altInputFormats:[],appendToBody:!1,clearText:"Clear",closeOnDateSelection:!0,closeText:"Done",currentText:"Today",datepickerPopup:"yyyy-MM-dd",datepickerPopupTemplateUrl:"uib/template/datepicker/popup.html",datepickerTemplateUrl:"uib/template/datepicker/datepicker.html",html5Types:{date:"yyyy-MM-dd","datetime-local":"yyyy-MM-ddTHH:mm:ss.sss",month:"yyyy-MM"},onOpenFocus:!0,showButtonBar:!0}).controller("UibDatepickerPopupController",["$scope","$element","$attrs","$compile","$parse","$document","$rootScope","$uibPosition","dateFilter","uibDateParser","uibDatepickerPopupConfig","$timeout","uibDatepickerConfig",function(a,b,c,d,e,f,g,h,i,j,k,l,m){function n(a){return a.replace(/([A-Z])/g,function(a){return"-"+a.toLowerCase()})}function o(b){var c=j.parse(b,t,a.date);if(isNaN(c))for(var d=0;d<E.length;d++)if(c=j.parse(b,E[d],a.date),!isNaN(c))return c;return c}function p(a){if(angular.isNumber(a)&&(a=new Date(a)),!a)return null;if(angular.isDate(a)&&!isNaN(a))return a;if(angular.isString(a)){var b=o(a);if(!isNaN(b))return j.toTimezone(b,C.timezone)}return B.$options&&B.$options.allowInvalid?a:void 0}function q(a,b){var d=a||b;return c.ngRequired||d?(angular.isNumber(d)&&(d=new Date(d)),d?angular.isDate(d)&&!isNaN(d)?!0:angular.isString(d)?!isNaN(o(b)):!1:!0):!0}function r(c){if(a.isOpen||!a.disabled){var d=D[0],e=b[0].contains(c.target),f=void 0!==d.contains&&d.contains(c.target);!a.isOpen||e||f||a.$apply(function(){a.isOpen=!1})}}function s(c){27===c.which&&a.isOpen?(c.preventDefault(),c.stopPropagation(),a.$apply(function(){a.isOpen=!1}),b[0].focus()):40!==c.which||a.isOpen||(c.preventDefault(),c.stopPropagation(),a.$apply(function(){a.isOpen=!0}))}var t,u,v,w,x,y,z,A,B,C,D,E,F={},G=!1,H=[];a.watchData={},this.init=function(h){if(B=h,C=h.$options||m.ngModelOptions,u=angular.isDefined(c.closeOnDateSelection)?a.$parent.$eval(c.closeOnDateSelection):k.closeOnDateSelection,v=angular.isDefined(c.datepickerAppendToBody)?a.$parent.$eval(c.datepickerAppendToBody):k.appendToBody,w=angular.isDefined(c.onOpenFocus)?a.$parent.$eval(c.onOpenFocus):k.onOpenFocus,x=angular.isDefined(c.datepickerPopupTemplateUrl)?c.datepickerPopupTemplateUrl:k.datepickerPopupTemplateUrl,y=angular.isDefined(c.datepickerTemplateUrl)?c.datepickerTemplateUrl:k.datepickerTemplateUrl,E=angular.isDefined(c.altInputFormats)?a.$parent.$eval(c.altInputFormats):k.altInputFormats,a.showButtonBar=angular.isDefined(c.showButtonBar)?a.$parent.$eval(c.showButtonBar):k.showButtonBar,k.html5Types[c.type]?(t=k.html5Types[c.type],G=!0):(t=c.uibDatepickerPopup||k.datepickerPopup,c.$observe("uibDatepickerPopup",function(a,b){var c=a||k.datepickerPopup;if(c!==t&&(t=c,B.$modelValue=null,!t))throw new Error("uibDatepickerPopup must have a date format specified.")})),!t)throw new Error("uibDatepickerPopup must have a date format specified.");if(G&&c.uibDatepickerPopup)throw new Error("HTML5 date input types do not support custom formats.");if(z=angular.element("<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>"),a.ngModelOptions=angular.copy(C),a.ngModelOptions.timezone=null,z.attr({"ng-model":"date","ng-model-options":"ngModelOptions","ng-change":"dateSelection(date)","template-url":x}),A=angular.element(z.children()[0]),A.attr("template-url",y),G&&"month"===c.type&&(A.attr("datepicker-mode",'"month"'),A.attr("min-mode","month")),c.datepickerOptions){var l=a.$parent.$eval(c.datepickerOptions);l&&l.initDate&&(a.initDate=j.fromTimezone(l.initDate,C.timezone),A.attr("init-date","initDate"),delete l.initDate),angular.forEach(l,function(a,b){A.attr(n(b),a)})}angular.forEach(["minMode","maxMode","datepickerMode","shortcutPropagation"],function(b){if(c[b]){var d=e(c[b]),f={get:function(){return d(a.$parent)}};if(A.attr(n(b),"watchData."+b),"datepickerMode"===b){var g=d.assign;f.set=function(b){g(a.$parent,b)}}Object.defineProperty(a.watchData,b,f)}}),angular.forEach(["minDate","maxDate","initDate"],function(b){if(c[b]){var d=e(c[b]);H.push(a.$parent.$watch(d,function(c){"minDate"===b||"maxDate"===b?(null===c?F[b]=null:angular.isDate(c)?F[b]=j.fromTimezone(new Date(c),C.timezone):F[b]=new Date(i(c,"medium")),a.watchData[b]=null===c?null:F[b]):a.watchData[b]=j.fromTimezone(new Date(c),C.timezone)})),A.attr(n(b),"watchData."+b)}}),c.dateDisabled&&A.attr("date-disabled","dateDisabled({ date: date, mode: mode })"),angular.forEach(["formatDay","formatMonth","formatYear","formatDayHeader","formatDayTitle","formatMonthTitle","showWeeks","startingDay","yearRows","yearColumns"],function(a){angular.isDefined(c[a])&&A.attr(n(a),c[a])}),c.customClass&&A.attr("custom-class","customClass({ date: date, mode: mode })"),G?B.$formatters.push(function(b){return a.date=j.fromTimezone(b,C.timezone),b}):(B.$$parserName="date",B.$validators.date=q,B.$parsers.unshift(p),B.$formatters.push(function(b){return B.$isEmpty(b)?(a.date=b,b):(a.date=j.fromTimezone(b,C.timezone),t=t.replace(/M!/,"MM").replace(/d!/,"dd"),i(a.date,t))})),B.$viewChangeListeners.push(function(){a.date=o(B.$viewValue)}),b.bind("keydown",s),D=d(z)(a),z.remove(),v?f.find("body").append(D):b.after(D),a.$on("$destroy",function(){for(a.isOpen===!0&&(g.$$phase||a.$apply(function(){a.isOpen=!1})),D.remove(),b.unbind("keydown",s),f.unbind("click",r);H.length;)H.shift()()})},a.getText=function(b){return a[b+"Text"]||k[b+"Text"]},a.isDisabled=function(b){return"today"===b&&(b=new Date),a.watchData.minDate&&a.compare(b,F.minDate)<0||a.watchData.maxDate&&a.compare(b,F.maxDate)>0},a.compare=function(a,b){return new Date(a.getFullYear(),a.getMonth(),a.getDate())-new Date(b.getFullYear(),b.getMonth(),b.getDate())},a.dateSelection=function(c){angular.isDefined(c)&&(a.date=c);var d=a.date?i(a.date,t):null;b.val(d),B.$setViewValue(d),u&&(a.isOpen=!1,b[0].focus())},a.keydown=function(c){27===c.which&&(c.stopPropagation(),a.isOpen=!1,b[0].focus())},a.select=function(b){if("today"===b){var c=new Date;angular.isDate(a.date)?(b=new Date(a.date),b.setFullYear(c.getFullYear(),c.getMonth(),c.getDate())):b=new Date(c.setHours(0,0,0,0))}a.dateSelection(b)},a.close=function(){a.isOpen=!1,b[0].focus()},a.disabled=angular.isDefined(c.disabled)||!1,c.ngDisabled&&H.push(a.$parent.$watch(e(c.ngDisabled),function(b){a.disabled=b})),a.$watch("isOpen",function(c){c?a.disabled?a.isOpen=!1:(a.position=v?h.offset(b):h.position(b),a.position.top=a.position.top+b.prop("offsetHeight"),l(function(){w&&a.$broadcast("uib:datepicker.focus"),f.bind("click",r)},0,!1)):f.unbind("click",r)})}]).directive("uibDatepickerPopup",function(){return{require:["ngModel","uibDatepickerPopup"],controller:"UibDatepickerPopupController",scope:{isOpen:"=?",currentText:"@",clearText:"@",closeText:"@",dateDisabled:"&",customClass:"&"},link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive("uibDatepickerPopupWrap",function(){return{replace:!0,transclude:!0,templateUrl:function(a,b){return b.templateUrl||"uib/template/datepicker/popup.html"}}}),angular.module("ui.bootstrap.debounce",[]).factory("$$debounce",["$timeout",function(a){return function(b,c){var d;return function(){var e=this,f=Array.prototype.slice.call(arguments);d&&a.cancel(d),d=a(function(){b.apply(e,f)},c)}}}]),angular.module("ui.bootstrap.dropdown",["ui.bootstrap.position"]).constant("uibDropdownConfig",{appendToOpenClass:"uib-dropdown-open",openClass:"open"}).service("uibDropdownService",["$document","$rootScope",function(a,b){var c=null;this.open=function(b){c||(a.on("click",d),a.on("keydown",e)),c&&c!==b&&(c.isOpen=!1),c=b},this.close=function(b){c===b&&(c=null,a.off("click",d),a.off("keydown",e))};var d=function(a){if(c&&!(a&&"disabled"===c.getAutoClose()||a&&3===a.which)){var d=c.getToggleElement();if(!(a&&d&&d[0].contains(a.target))){var e=c.getDropdownElement();a&&"outsideClick"===c.getAutoClose()&&e&&e[0].contains(a.target)||(c.isOpen=!1,b.$$phase||c.$apply())}}},e=function(a){27===a.which?(c.focusToggleElement(),d()):c.isKeynavEnabled()&&-1!==[38,40].indexOf(a.which)&&c.isOpen&&(a.preventDefault(),a.stopPropagation(),c.focusDropdownEntry(a.which))}}]).controller("UibDropdownController",["$scope","$element","$attrs","$parse","uibDropdownConfig","uibDropdownService","$animate","$uibPosition","$document","$compile","$templateRequest",function(a,b,c,d,e,f,g,h,i,j,k){var l,m,n=this,o=a.$new(),p=e.appendToOpenClass,q=e.openClass,r=angular.noop,s=c.onToggle?d(c.onToggle):angular.noop,t=!1,u=null,v=!1,w=i.find("body");b.addClass("dropdown"),this.init=function(){if(c.isOpen&&(m=d(c.isOpen),r=m.assign,a.$watch(m,function(a){o.isOpen=!!a})),angular.isDefined(c.dropdownAppendTo)){var e=d(c.dropdownAppendTo)(o);e&&(u=angular.element(e))}t=angular.isDefined(c.dropdownAppendToBody),v=angular.isDefined(c.keyboardNav),t&&!u&&(u=w),u&&n.dropdownMenu&&(u.append(n.dropdownMenu),b.on("$destroy",function(){n.dropdownMenu.remove()}))},this.toggle=function(a){return o.isOpen=arguments.length?!!a:!o.isOpen},this.isOpen=function(){return o.isOpen},o.getToggleElement=function(){return n.toggleElement},o.getAutoClose=function(){return c.autoClose||"always"},o.getElement=function(){return b},o.isKeynavEnabled=function(){return v},o.focusDropdownEntry=function(a){var c=n.dropdownMenu?angular.element(n.dropdownMenu).find("a"):b.find("ul").eq(0).find("a");switch(a){case 40:angular.isNumber(n.selectedOption)?n.selectedOption=n.selectedOption===c.length-1?n.selectedOption:n.selectedOption+1:n.selectedOption=0;break;case 38:angular.isNumber(n.selectedOption)?n.selectedOption=0===n.selectedOption?0:n.selectedOption-1:n.selectedOption=c.length-1}c[n.selectedOption].focus()},o.getDropdownElement=function(){return n.dropdownMenu},o.focusToggleElement=function(){n.toggleElement&&n.toggleElement[0].focus()},o.$watch("isOpen",function(c,d){if(u&&n.dropdownMenu){var e,i,m=h.positionElements(b,n.dropdownMenu,"bottom-left",!0);if(e={top:m.top+"px",display:c?"block":"none"},i=n.dropdownMenu.hasClass("dropdown-menu-right"),i?(e.left="auto",e.right=window.innerWidth-(m.left+b.prop("offsetWidth"))+"px"):(e.left=m.left+"px",e.right="auto"),!t){var v=h.offset(u);e.top=m.top-v.top+"px",i?e.right=window.innerWidth-(m.left-v.left+b.prop("offsetWidth"))+"px":e.left=m.left-v.left+"px"}n.dropdownMenu.css(e)}var w=u?u:b;if(g[c?"addClass":"removeClass"](w,u?p:q).then(function(){angular.isDefined(c)&&c!==d&&s(a,{open:!!c})}),c)n.dropdownMenuTemplateUrl&&k(n.dropdownMenuTemplateUrl).then(function(a){l=o.$new(),j(a.trim())(l,function(a){var b=a;n.dropdownMenu.replaceWith(b),n.dropdownMenu=b})}),o.focusToggleElement(),f.open(o);else{if(n.dropdownMenuTemplateUrl){l&&l.$destroy();var x=angular.element('<ul class="dropdown-menu"></ul>');n.dropdownMenu.replaceWith(x),n.dropdownMenu=x}f.close(o),n.selectedOption=null}angular.isFunction(r)&&r(a,c)}),a.$on("$locationChangeSuccess",function(){"disabled"!==o.getAutoClose()&&(o.isOpen=!1)})}]).directive("uibDropdown",function(){return{controller:"UibDropdownController",link:function(a,b,c,d){d.init()}}}).directive("uibDropdownMenu",function(){return{restrict:"A",require:"?^uibDropdown",link:function(a,b,c,d){if(d&&!angular.isDefined(c.dropdownNested)){b.addClass("dropdown-menu");var e=c.templateUrl;e&&(d.dropdownMenuTemplateUrl=e),d.dropdownMenu||(d.dropdownMenu=b)}}}}).directive("uibDropdownToggle",function(){return{require:"?^uibDropdown",link:function(a,b,c,d){if(d){b.addClass("dropdown-toggle"),d.toggleElement=b;var e=function(e){e.preventDefault(),b.hasClass("disabled")||c.disabled||a.$apply(function(){d.toggle()})};b.bind("click",e),b.attr({"aria-haspopup":!0,"aria-expanded":!1}),a.$watch(d.isOpen,function(a){b.attr("aria-expanded",!!a)}),a.$on("$destroy",function(){b.unbind("click",e)})}}}}),angular.module("ui.bootstrap.stackedMap",[]).factory("$$stackedMap",function(){return{createNew:function(){var a=[];return{add:function(b,c){a.push({key:b,value:c})},get:function(b){for(var c=0;c<a.length;c++)if(b===a[c].key)return a[c]},keys:function(){for(var b=[],c=0;c<a.length;c++)b.push(a[c].key);return b},top:function(){return a[a.length-1]},remove:function(b){for(var c=-1,d=0;d<a.length;d++)if(b===a[d].key){c=d;break}return a.splice(c,1)[0]},removeTop:function(){return a.splice(a.length-1,1)[0]},length:function(){return a.length}}}}}),angular.module("ui.bootstrap.modal",["ui.bootstrap.stackedMap"]).factory("$$multiMap",function(){return{createNew:function(){var a={};return{entries:function(){return Object.keys(a).map(function(b){return{key:b,value:a[b]}})},get:function(b){return a[b]},hasKey:function(b){return!!a[b]},keys:function(){return Object.keys(a)},put:function(b,c){a[b]||(a[b]=[]),a[b].push(c)},remove:function(b,c){var d=a[b];if(d){var e=d.indexOf(c);-1!==e&&d.splice(e,1),d.length||delete a[b]}}}}}}).provider("$uibResolve",function(){var a=this;this.resolver=null,this.setResolver=function(a){this.resolver=a},this.$get=["$injector","$q",function(b,c){var d=a.resolver?b.get(a.resolver):null;return{resolve:function(a,e,f,g){if(d)return d.resolve(a,e,f,g);var h=[];return angular.forEach(a,function(a){angular.isFunction(a)||angular.isArray(a)?h.push(c.resolve(b.invoke(a))):angular.isString(a)?h.push(c.resolve(b.get(a))):h.push(c.resolve(a))}),c.all(h).then(function(b){var c={},d=0;return angular.forEach(a,function(a,e){c[e]=b[d++]}),c})}}}]}).directive("uibModalBackdrop",["$animateCss","$injector","$uibModalStack",function(a,b,c){function d(b,d,e){e.modalInClass&&(a(d,{addClass:e.modalInClass}).start(),b.$on(c.NOW_CLOSING_EVENT,function(c,f){var g=f();b.modalOptions.animation?a(d,{removeClass:e.modalInClass}).start().then(g):g()}))}return{replace:!0,templateUrl:"uib/template/modal/backdrop.html",compile:function(a,b){return a.addClass(b.backdropClass),d}}}]).directive("uibModalWindow",["$uibModalStack","$q","$animate","$animateCss","$document",function(a,b,c,d,e){return{scope:{index:"@"},replace:!0,transclude:!0,templateUrl:function(a,b){return b.templateUrl||"uib/template/modal/window.html"},link:function(f,g,h){g.addClass(h.windowClass||""),g.addClass(h.windowTopClass||""),f.size=h.size,f.close=function(b){var c=a.getTop();c&&c.value.backdrop&&"static"!==c.value.backdrop&&b.target===b.currentTarget&&(b.preventDefault(),b.stopPropagation(),a.dismiss(c.key,"backdrop click"))},g.on("click",f.close),f.$isRendered=!0;var i=b.defer();h.$observe("modalRender",function(a){"true"===a&&i.resolve()}),i.promise.then(function(){var i=null;h.modalInClass&&(i=d(g,{addClass:h.modalInClass}).start(),f.$on(a.NOW_CLOSING_EVENT,function(a,b){var e=b();d?d(g,{removeClass:h.modalInClass}).start().then(e):c.removeClass(g,h.modalInClass).then(e)})),b.when(i).then(function(){if(!e[0].activeElement||!g[0].contains(e[0].activeElement)){var a=g[0].querySelector("[autofocus]");a?a.focus():g[0].focus()}});var j=a.getTop();j&&a.modalRendered(j.key)})}}}]).directive("uibModalAnimationClass",function(){return{compile:function(a,b){b.modalAnimation&&a.addClass(b.uibModalAnimationClass)}}}).directive("uibModalTransclude",function(){return{link:function(a,b,c,d,e){e(a.$parent,function(a){b.empty(),b.append(a)})}}}).factory("$uibModalStack",["$animate","$animateCss","$document","$compile","$rootScope","$q","$$multiMap","$$stackedMap",function(a,b,c,d,e,f,g,h){function i(){for(var a=-1,b=t.keys(),c=0;c<b.length;c++)t.get(b[c]).value.backdrop&&(a=c);return a}function j(a,b){var c=t.get(a).value,d=c.appendTo;t.remove(a),m(c.modalDomEl,c.modalScope,function(){var b=c.openedClass||s;u.remove(b,a),d.toggleClass(b,u.hasKey(b)),k(!0)}),l(),b&&b.focus?b.focus():d.focus&&d.focus()}function k(a){var b;t.length()>0&&(b=t.top().value,b.modalDomEl.toggleClass(b.windowTopClass||"",a))}function l(){if(p&&-1===i()){var a=q;m(p,q,function(){a=null}),p=void 0,q=void 0}}function m(a,c,d,e){function g(){g.done||(g.done=!0,b(a,{event:"leave"}).start().then(function(){a.remove(),e&&e.resolve()}),c.$destroy(),d&&d())}var h,i=null,j=function(){return h||(h=f.defer(),i=h.promise),function(){h.resolve()}};return c.$broadcast(v.NOW_CLOSING_EVENT,j),f.when(i).then(g)}function n(a){if(a.isDefaultPrevented())return a;var b=t.top();if(b)switch(a.which){case 27:b.value.keyboard&&(a.preventDefault(),e.$apply(function(){v.dismiss(b.key,"escape key press")}));break;case 9:v.loadFocusElementList(b);var c=!1;a.shiftKey?v.isFocusInFirstItem(a)&&(c=v.focusLastFocusableElement()):v.isFocusInLastItem(a)&&(c=v.focusFirstFocusableElement()),c&&(a.preventDefault(),a.stopPropagation())}}function o(a,b,c){return!a.value.modalScope.$broadcast("modal.closing",b,c).defaultPrevented}var p,q,r,s="modal-open",t=h.createNew(),u=g.createNew(),v={NOW_CLOSING_EVENT:"modal.stack.now-closing"},w=0,x="a[href], area[href], input:not([disabled]), button:not([disabled]),select:not([disabled]), textarea:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable=true]";return e.$watch(i,function(a){q&&(q.index=a)}),c.on("keydown",n),e.$on("$destroy",function(){c.off("keydown",n)}),v.open=function(b,f){var g=c[0].activeElement,h=f.openedClass||s;k(!1),t.add(b,{deferred:f.deferred,renderDeferred:f.renderDeferred,closedDeferred:f.closedDeferred,modalScope:f.scope,backdrop:f.backdrop,keyboard:f.keyboard,openedClass:f.openedClass,windowTopClass:f.windowTopClass,animation:f.animation,appendTo:f.appendTo}),u.put(h,b);var j=f.appendTo,l=i();if(!j.length)throw new Error("appendTo element not found. Make sure that the element passed is in DOM.");l>=0&&!p&&(q=e.$new(!0),q.modalOptions=f,q.index=l,p=angular.element('<div uib-modal-backdrop="modal-backdrop"></div>'),p.attr("backdrop-class",f.backdropClass),f.animation&&p.attr("modal-animation","true"),d(p)(q),a.enter(p,j));var m=angular.element('<div uib-modal-window="modal-window"></div>');m.attr({"template-url":f.windowTemplateUrl,"window-class":f.windowClass,"window-top-class":f.windowTopClass,size:f.size,index:t.length()-1,animate:"animate"}).html(f.content),f.animation&&m.attr("modal-animation","true"),a.enter(d(m)(f.scope),j).then(function(){a.addClass(j,h)}),t.top().value.modalDomEl=m,t.top().value.modalOpener=g,v.clearFocusListCache()},v.close=function(a,b){var c=t.get(a);return c&&o(c,b,!0)?(c.value.modalScope.$$uibDestructionScheduled=!0,c.value.deferred.resolve(b),j(a,c.value.modalOpener),!0):!c},v.dismiss=function(a,b){var c=t.get(a);return c&&o(c,b,!1)?(c.value.modalScope.$$uibDestructionScheduled=!0,c.value.deferred.reject(b),j(a,c.value.modalOpener),!0):!c},v.dismissAll=function(a){for(var b=this.getTop();b&&this.dismiss(b.key,a);)b=this.getTop()},v.getTop=function(){return t.top()},v.modalRendered=function(a){var b=t.get(a);b&&b.value.renderDeferred.resolve()},v.focusFirstFocusableElement=function(){return r.length>0?(r[0].focus(),!0):!1},v.focusLastFocusableElement=function(){return r.length>0?(r[r.length-1].focus(),!0):!1},v.isFocusInFirstItem=function(a){return r.length>0?(a.target||a.srcElement)===r[0]:!1},v.isFocusInLastItem=function(a){return r.length>0?(a.target||a.srcElement)===r[r.length-1]:!1},v.clearFocusListCache=function(){r=[],w=0},v.loadFocusElementList=function(a){if((void 0===r||!r.length)&&a){var b=a.value.modalDomEl;b&&b.length&&(r=b[0].querySelectorAll(x))}},v}]).provider("$uibModal",function(){var a={options:{animation:!0,backdrop:!0,keyboard:!0},$get:["$rootScope","$q","$document","$templateRequest","$controller","$uibResolve","$uibModalStack",function(b,c,d,e,f,g,h){function i(a){return a.template?c.when(a.template):e(angular.isFunction(a.templateUrl)?a.templateUrl():a.templateUrl)}var j={},k=null;return j.getPromiseChain=function(){return k},j.open=function(e){function j(){return r}var l=c.defer(),m=c.defer(),n=c.defer(),o=c.defer(),p={result:l.promise,opened:m.promise,closed:n.promise,rendered:o.promise,close:function(a){return h.close(p,a)},dismiss:function(a){return h.dismiss(p,a)}};if(e=angular.extend({},a.options,e),e.resolve=e.resolve||{},e.appendTo=e.appendTo||d.find("body").eq(0),!e.template&&!e.templateUrl)throw new Error("One of template or templateUrl options is required.");var q,r=c.all([i(e),g.resolve(e.resolve,{},null,null)]);return q=k=c.all([k]).then(j,j).then(function(a){var c=e.scope||b,d=c.$new();d.$close=p.close,d.$dismiss=p.dismiss,d.$on("$destroy",function(){d.$$uibDestructionScheduled||d.$dismiss("$uibUnscheduledDestruction")});var g,i={};e.controller&&(i.$scope=d,i.$uibModalInstance=p,angular.forEach(a[1],function(a,b){i[b]=a}),g=f(e.controller,i),e.controllerAs&&(e.bindToController&&(g.$close=d.$close,g.$dismiss=d.$dismiss,angular.extend(g,c)),d[e.controllerAs]=g)),h.open(p,{scope:d,deferred:l,renderDeferred:o,closedDeferred:n,content:a[0],animation:e.animation,backdrop:e.backdrop,keyboard:e.keyboard,backdropClass:e.backdropClass,windowTopClass:e.windowTopClass,windowClass:e.windowClass,windowTemplateUrl:e.windowTemplateUrl,size:e.size,openedClass:e.openedClass,appendTo:e.appendTo}),m.resolve(!0)},function(a){m.reject(a),l.reject(a)})["finally"](function(){k===q&&(k=null)}),p},j}]};return a}),angular.module("ui.bootstrap.paging",[]).factory("uibPaging",["$parse",function(a){return{create:function(b,c,d){b.setNumPages=d.numPages?a(d.numPages).assign:angular.noop,b.ngModelCtrl={$setViewValue:angular.noop},b._watchers=[],b.init=function(e,f){b.ngModelCtrl=e,b.config=f,e.$render=function(){b.render()},d.itemsPerPage?b._watchers.push(c.$parent.$watch(a(d.itemsPerPage),function(a){b.itemsPerPage=parseInt(a,10),c.totalPages=b.calculateTotalPages(),b.updatePage()})):b.itemsPerPage=f.itemsPerPage,c.$watch("totalItems",function(a,d){(angular.isDefined(a)||a!==d)&&(c.totalPages=b.calculateTotalPages(),b.updatePage())})},b.calculateTotalPages=function(){var a=b.itemsPerPage<1?1:Math.ceil(c.totalItems/b.itemsPerPage);return Math.max(a||0,1)},b.render=function(){c.page=parseInt(b.ngModelCtrl.$viewValue,10)||1},c.selectPage=function(a,d){d&&d.preventDefault();var e=!c.ngDisabled||!d;e&&c.page!==a&&a>0&&a<=c.totalPages&&(d&&d.target&&d.target.blur(),b.ngModelCtrl.$setViewValue(a),b.ngModelCtrl.$render())},c.getText=function(a){return c[a+"Text"]||b.config[a+"Text"]},c.noPrevious=function(){return 1===c.page},c.noNext=function(){return c.page===c.totalPages},b.updatePage=function(){b.setNumPages(c.$parent,c.totalPages),c.page>c.totalPages?c.selectPage(c.totalPages):b.ngModelCtrl.$render()},c.$on("$destroy",function(){for(;b._watchers.length;)b._watchers.shift()()})}}}]),angular.module("ui.bootstrap.pager",["ui.bootstrap.paging"]).controller("UibPagerController",["$scope","$attrs","uibPaging","uibPagerConfig",function(a,b,c,d){a.align=angular.isDefined(b.align)?a.$parent.$eval(b.align):d.align,c.create(this,a,b)}]).constant("uibPagerConfig",{itemsPerPage:10,previousText:" Previous",nextText:"Next ",align:!0}).directive("uibPager",["uibPagerConfig",function(a){return{scope:{totalItems:"=",previousText:"@",nextText:"@",ngDisabled:"="},require:["uibPager","?ngModel"],controller:"UibPagerController",controllerAs:"pager",templateUrl:function(a,b){return b.templateUrl||"uib/template/pager/pager.html"},replace:!0,link:function(b,c,d,e){var f=e[0],g=e[1];g&&f.init(g,a)}}}]),angular.module("ui.bootstrap.pagination",["ui.bootstrap.paging"]).controller("UibPaginationController",["$scope","$attrs","$parse","uibPaging","uibPaginationConfig",function(a,b,c,d,e){function f(a,b,c){return{number:a,text:b,active:c}}function g(a,b){var c=[],d=1,e=b,g=angular.isDefined(i)&&b>i;g&&(j?(d=Math.max(a-Math.floor(i/2),1),e=d+i-1,e>b&&(e=b,d=e-i+1)):(d=(Math.ceil(a/i)-1)*i+1,e=Math.min(d+i-1,b)));for(var h=d;e>=h;h++){var m=f(h,h,h===a);c.push(m)}if(g&&i>0&&(!j||k||l)){if(d>1){if(!l||d>3){var n=f(d-1,"...",!1);c.unshift(n)}if(l){if(3===d){var o=f(2,"2",!1);c.unshift(o)}var p=f(1,"1",!1);c.unshift(p)}}if(b>e){if(!l||b-2>e){var q=f(e+1,"...",!1);c.push(q)}if(l){if(e===b-2){var r=f(b-1,b-1,!1);c.push(r)}var s=f(b,b,!1);c.push(s)}}}return c}var h=this,i=angular.isDefined(b.maxSize)?a.$parent.$eval(b.maxSize):e.maxSize,j=angular.isDefined(b.rotate)?a.$parent.$eval(b.rotate):e.rotate,k=angular.isDefined(b.forceEllipses)?a.$parent.$eval(b.forceEllipses):e.forceEllipses,l=angular.isDefined(b.boundaryLinkNumbers)?a.$parent.$eval(b.boundaryLinkNumbers):e.boundaryLinkNumbers;a.boundaryLinks=angular.isDefined(b.boundaryLinks)?a.$parent.$eval(b.boundaryLinks):e.boundaryLinks,a.directionLinks=angular.isDefined(b.directionLinks)?a.$parent.$eval(b.directionLinks):e.directionLinks,d.create(this,a,b),b.maxSize&&h._watchers.push(a.$parent.$watch(c(b.maxSize),function(a){i=parseInt(a,10),h.render()}));var m=this.render;this.render=function(){m(),a.page>0&&a.page<=a.totalPages&&(a.pages=g(a.page,a.totalPages))}}]).constant("uibPaginationConfig",{itemsPerPage:10,boundaryLinks:!1,boundaryLinkNumbers:!1,directionLinks:!0,firstText:"First",previousText:"Previous",nextText:"Next",lastText:"Last",rotate:!0,forceEllipses:!1}).directive("uibPagination",["$parse","uibPaginationConfig",function(a,b){return{scope:{totalItems:"=",firstText:"@",previousText:"@",nextText:"@",lastText:"@",ngDisabled:"="},require:["uibPagination","?ngModel"],controller:"UibPaginationController",controllerAs:"pagination",templateUrl:function(a,b){return b.templateUrl||"uib/template/pagination/pagination.html"},replace:!0,link:function(a,c,d,e){var f=e[0],g=e[1];g&&f.init(g,b)}}}]),angular.module("ui.bootstrap.tooltip",["ui.bootstrap.position","ui.bootstrap.stackedMap"]).provider("$uibTooltip",function(){function a(a){var b=/[A-Z]/g,c="-";return a.replace(b,function(a,b){return(b?c:"")+a.toLowerCase()})}var b={placement:"top",placementClassPrefix:"",animation:!0,popupDelay:0,popupCloseDelay:0,useContentExp:!1},c={mouseenter:"mouseleave",click:"click",outsideClick:"outsideClick",focus:"blur",none:""},d={};this.options=function(a){angular.extend(d,a)},this.setTriggers=function(a){angular.extend(c,a)},this.$get=["$window","$compile","$timeout","$document","$uibPosition","$interpolate","$rootScope","$parse","$$stackedMap",function(e,f,g,h,i,j,k,l,m){function n(a){if(27===a.which){var b=o.top();b&&(b.value.close(),o.removeTop(),b=null)}}var o=m.createNew();return h.on("keypress",n),k.$on("$destroy",function(){h.off("keypress",n)}),function(e,k,m,n){function p(a){var b=(a||n.trigger||m).split(" "),d=b.map(function(a){return c[a]||a});return{show:b,hide:d}}n=angular.extend({},b,d,n);var q=a(e),r=j.startSymbol(),s=j.endSymbol(),t="<div "+q+'-popup title="'+r+"title"+s+'" '+(n.useContentExp?'content-exp="contentExp()" ':'content="'+r+"content"+s+'" ')+'placement="'+r+"placement"+s+'" popup-class="'+r+"popupClass"+s+'" animation="animation" is-open="isOpen"origin-scope="origScope" style="visibility: hidden; display: block; top: -9999px; left: -9999px;"></div>';return{compile:function(a,b){var c=f(t);return function(a,b,d,f){function j(){M.isOpen?q():m()}function m(){(!L||a.$eval(d[k+"Enable"]))&&(u(),x(),M.popupDelay?G||(G=g(r,M.popupDelay,!1)):r())}function q(){s(),M.popupCloseDelay?H||(H=g(t,M.popupCloseDelay,!1)):t()}function r(){return s(),u(),M.content?(v(),void M.$evalAsync(function(){M.isOpen=!0,y(!0),R()})):angular.noop}function s(){G&&(g.cancel(G),G=null),I&&(g.cancel(I),I=null)}function t(){M&&M.$evalAsync(function(){M&&(M.isOpen=!1,y(!1),M.animation?F||(F=g(w,150,!1)):w())})}function u(){H&&(g.cancel(H),H=null),F&&(g.cancel(F),F=null)}function v(){D||(E=M.$new(),D=c(E,function(a){J?h.find("body").append(a):b.after(a)}),z())}function w(){s(),u(),A(),D&&(D.remove(),D=null),E&&(E.$destroy(),E=null)}function x(){M.title=d[k+"Title"],P?M.content=P(a):M.content=d[e],M.popupClass=d[k+"Class"],M.placement=angular.isDefined(d[k+"Placement"])?d[k+"Placement"]:n.placement;var b=parseInt(d[k+"PopupDelay"],10),c=parseInt(d[k+"PopupCloseDelay"],10);M.popupDelay=isNaN(b)?n.popupDelay:b,M.popupCloseDelay=isNaN(c)?n.popupCloseDelay:c}function y(b){O&&angular.isFunction(O.assign)&&O.assign(a,b)}function z(){Q.length=0,P?(Q.push(a.$watch(P,function(a){M.content=a,!a&&M.isOpen&&t()})),Q.push(E.$watch(function(){N||(N=!0,E.$$postDigest(function(){N=!1,M&&M.isOpen&&R()}))}))):Q.push(d.$observe(e,function(a){M.content=a,!a&&M.isOpen?t():R()})),Q.push(d.$observe(k+"Title",function(a){M.title=a,M.isOpen&&R()})),Q.push(d.$observe(k+"Placement",function(a){M.placement=a?a:n.placement,M.isOpen&&R()}))}function A(){Q.length&&(angular.forEach(Q,function(a){a()}),Q.length=0)}function B(a){M&&M.isOpen&&D&&(b[0].contains(a.target)||D[0].contains(a.target)||q())}function C(){var a=d[k+"Trigger"];S(),K=p(a),"none"!==K.show&&K.show.forEach(function(a,c){"outsideClick"===a?(b.on("click",j),h.on("click",B)):a===K.hide[c]?b.on(a,j):a&&(b.on(a,m),b.on(K.hide[c],q)),b.on("keypress",function(a){27===a.which&&q()})})}var D,E,F,G,H,I,J=angular.isDefined(n.appendToBody)?n.appendToBody:!1,K=p(void 0),L=angular.isDefined(d[k+"Enable"]),M=a.$new(!0),N=!1,O=angular.isDefined(d[k+"IsOpen"])?l(d[k+"IsOpen"]):!1,P=n.useContentExp?l(d[e]):!1,Q=[],R=function(){D&&D.html()&&(I||(I=g(function(){D.css({top:0,left:0});var a=i.positionElements(b,D,M.placement,J);D.css({top:a.top+"px",left:a.left+"px",visibility:"visible"}),n.placementClassPrefix&&D.removeClass("top bottom left right"),D.removeClass(n.placementClassPrefix+"top "+n.placementClassPrefix+"top-left "+n.placementClassPrefix+"top-right "+n.placementClassPrefix+"bottom "+n.placementClassPrefix+"bottom-left "+n.placementClassPrefix+"bottom-right "+n.placementClassPrefix+"left "+n.placementClassPrefix+"left-top "+n.placementClassPrefix+"left-bottom "+n.placementClassPrefix+"right "+n.placementClassPrefix+"right-top "+n.placementClassPrefix+"right-bottom");var c=a.placement.split("-");D.addClass(c[0]+" "+n.placementClassPrefix+a.placement),i.positionArrow(D,a.placement),I=null},0,!1)))};M.origScope=a,M.isOpen=!1,o.add(M,{close:t}),M.contentExp=function(){return M.content},d.$observe("disabled",function(a){a&&s(),a&&M.isOpen&&t()}),O&&a.$watch(O,function(a){M&&!a===M.isOpen&&j()});var S=function(){K.show.forEach(function(a){"outsideClick"===a?b.off("click",j):(b.off(a,m),b.off(a,j))}),K.hide.forEach(function(a){"outsideClick"===a?h.off("click",B):b.off(a,q)})};C();var T=a.$eval(d[k+"Animation"]);M.animation=angular.isDefined(T)?!!T:n.animation;var U,V=k+"AppendToBody";U=V in d&&void 0===d[V]?!0:a.$eval(d[V]),J=angular.isDefined(U)?U:J,J&&a.$on("$locationChangeSuccess",function(){M.isOpen&&t()}),a.$on("$destroy",function(){S(),w(),o.remove(M),M=null})}}}}}]}).directive("uibTooltipTemplateTransclude",["$animate","$sce","$compile","$templateRequest",function(a,b,c,d){return{link:function(e,f,g){var h,i,j,k=e.$eval(g.tooltipTemplateTranscludeScope),l=0,m=function(){i&&(i.remove(),i=null),h&&(h.$destroy(),h=null),j&&(a.leave(j).then(function(){i=null}),i=j,j=null)};e.$watch(b.parseAsResourceUrl(g.uibTooltipTemplateTransclude),function(b){var g=++l;b?(d(b,!0).then(function(d){if(g===l){var e=k.$new(),i=d,n=c(i)(e,function(b){m(),a.enter(b,f)});h=e,j=n,h.$emit("$includeContentLoaded",b)}},function(){g===l&&(m(),e.$emit("$includeContentError",b))}),e.$emit("$includeContentRequested",b)):m()}),e.$on("$destroy",m)}}}]).directive("uibTooltipClasses",["$uibPosition",function(a){return{restrict:"A",link:function(b,c,d){if(b.placement){var e=a.parsePlacement(b.placement);c.addClass(e[0])}else c.addClass("top");b.popupClass&&c.addClass(b.popupClass),b.animation()&&c.addClass(d.tooltipAnimationClass)}}}]).directive("uibTooltipPopup",function(){return{replace:!0,scope:{content:"@",placement:"@",popupClass:"@",animation:"&",isOpen:"&"},
templateUrl:"uib/template/tooltip/tooltip-popup.html"}}).directive("uibTooltip",["$uibTooltip",function(a){return a("uibTooltip","tooltip","mouseenter")}]).directive("uibTooltipTemplatePopup",function(){return{replace:!0,scope:{contentExp:"&",placement:"@",popupClass:"@",animation:"&",isOpen:"&",originScope:"&"},templateUrl:"uib/template/tooltip/tooltip-template-popup.html"}}).directive("uibTooltipTemplate",["$uibTooltip",function(a){return a("uibTooltipTemplate","tooltip","mouseenter",{useContentExp:!0})}]).directive("uibTooltipHtmlPopup",function(){return{replace:!0,scope:{contentExp:"&",placement:"@",popupClass:"@",animation:"&",isOpen:"&"},templateUrl:"uib/template/tooltip/tooltip-html-popup.html"}}).directive("uibTooltipHtml",["$uibTooltip",function(a){return a("uibTooltipHtml","tooltip","mouseenter",{useContentExp:!0})}]),angular.module("ui.bootstrap.popover",["ui.bootstrap.tooltip"]).directive("uibPopoverTemplatePopup",function(){return{replace:!0,scope:{title:"@",contentExp:"&",placement:"@",popupClass:"@",animation:"&",isOpen:"&",originScope:"&"},templateUrl:"uib/template/popover/popover-template.html"}}).directive("uibPopoverTemplate",["$uibTooltip",function(a){return a("uibPopoverTemplate","popover","click",{useContentExp:!0})}]).directive("uibPopoverHtmlPopup",function(){return{replace:!0,scope:{contentExp:"&",title:"@",placement:"@",popupClass:"@",animation:"&",isOpen:"&"},templateUrl:"uib/template/popover/popover-html.html"}}).directive("uibPopoverHtml",["$uibTooltip",function(a){return a("uibPopoverHtml","popover","click",{useContentExp:!0})}]).directive("uibPopoverPopup",function(){return{replace:!0,scope:{title:"@",content:"@",placement:"@",popupClass:"@",animation:"&",isOpen:"&"},templateUrl:"uib/template/popover/popover.html"}}).directive("uibPopover",["$uibTooltip",function(a){return a("uibPopover","popover","click")}]),angular.module("ui.bootstrap.progressbar",[]).constant("uibProgressConfig",{animate:!0,max:100}).controller("UibProgressController",["$scope","$attrs","uibProgressConfig",function(a,b,c){var d=this,e=angular.isDefined(b.animate)?a.$parent.$eval(b.animate):c.animate;this.bars=[],a.max=angular.isDefined(a.max)?a.max:c.max,this.addBar=function(b,c,f){e||c.css({transition:"none"}),this.bars.push(b),b.max=a.max,b.title=f&&angular.isDefined(f.title)?f.title:"progressbar",b.$watch("value",function(a){b.recalculatePercentage()}),b.recalculatePercentage=function(){var a=d.bars.reduce(function(a,b){return b.percent=+(100*b.value/b.max).toFixed(2),a+b.percent},0);a>100&&(b.percent-=a-100)},b.$on("$destroy",function(){c=null,d.removeBar(b)})},this.removeBar=function(a){this.bars.splice(this.bars.indexOf(a),1),this.bars.forEach(function(a){a.recalculatePercentage()})},a.$watch("max",function(b){d.bars.forEach(function(b){b.max=a.max,b.recalculatePercentage()})})}]).directive("uibProgress",function(){return{replace:!0,transclude:!0,controller:"UibProgressController",require:"uibProgress",scope:{max:"=?"},templateUrl:"uib/template/progressbar/progress.html"}}).directive("uibBar",function(){return{replace:!0,transclude:!0,require:"^uibProgress",scope:{value:"=",type:"@"},templateUrl:"uib/template/progressbar/bar.html",link:function(a,b,c,d){d.addBar(a,b,c)}}}).directive("uibProgressbar",function(){return{replace:!0,transclude:!0,controller:"UibProgressController",scope:{value:"=",max:"=?",type:"@"},templateUrl:"uib/template/progressbar/progressbar.html",link:function(a,b,c,d){d.addBar(a,angular.element(b.children()[0]),{title:c.title})}}}),angular.module("ui.bootstrap.rating",[]).constant("uibRatingConfig",{max:5,stateOn:null,stateOff:null,titles:["one","two","three","four","five"]}).controller("UibRatingController",["$scope","$attrs","uibRatingConfig",function(a,b,c){var d={$setViewValue:angular.noop};this.init=function(e){d=e,d.$render=this.render,d.$formatters.push(function(a){return angular.isNumber(a)&&a<<0!==a&&(a=Math.round(a)),a}),this.stateOn=angular.isDefined(b.stateOn)?a.$parent.$eval(b.stateOn):c.stateOn,this.stateOff=angular.isDefined(b.stateOff)?a.$parent.$eval(b.stateOff):c.stateOff;var f=angular.isDefined(b.titles)?a.$parent.$eval(b.titles):c.titles;this.titles=angular.isArray(f)&&f.length>0?f:c.titles;var g=angular.isDefined(b.ratingStates)?a.$parent.$eval(b.ratingStates):new Array(angular.isDefined(b.max)?a.$parent.$eval(b.max):c.max);a.range=this.buildTemplateObjects(g)},this.buildTemplateObjects=function(a){for(var b=0,c=a.length;c>b;b++)a[b]=angular.extend({index:b},{stateOn:this.stateOn,stateOff:this.stateOff,title:this.getTitle(b)},a[b]);return a},this.getTitle=function(a){return a>=this.titles.length?a+1:this.titles[a]},a.rate=function(b){!a.readonly&&b>=0&&b<=a.range.length&&(d.$setViewValue(d.$viewValue===b?0:b),d.$render())},a.enter=function(b){a.readonly||(a.value=b),a.onHover({value:b})},a.reset=function(){a.value=d.$viewValue,a.onLeave()},a.onKeydown=function(b){/(37|38|39|40)/.test(b.which)&&(b.preventDefault(),b.stopPropagation(),a.rate(a.value+(38===b.which||39===b.which?1:-1)))},this.render=function(){a.value=d.$viewValue}}]).directive("uibRating",function(){return{require:["uibRating","ngModel"],scope:{readonly:"=?",onHover:"&",onLeave:"&"},controller:"UibRatingController",templateUrl:"uib/template/rating/rating.html",replace:!0,link:function(a,b,c,d){var e=d[0],f=d[1];e.init(f)}}}),angular.module("ui.bootstrap.tabs",[]).controller("UibTabsetController",["$scope",function(a){var b=this,c=b.tabs=a.tabs=[];b.select=function(a){angular.forEach(c,function(b){b.active&&b!==a&&(b.active=!1,b.onDeselect(),a.selectCalled=!1)}),a.active=!0,a.selectCalled||(a.onSelect(),a.selectCalled=!0)},b.addTab=function(a){c.push(a),1===c.length&&a.active!==!1?a.active=!0:a.active?b.select(a):a.active=!1},b.removeTab=function(a){var e=c.indexOf(a);if(a.active&&c.length>1&&!d){var f=e===c.length-1?e-1:e+1;b.select(c[f])}c.splice(e,1)};var d;a.$on("$destroy",function(){d=!0})}]).directive("uibTabset",function(){return{transclude:!0,replace:!0,scope:{type:"@"},controller:"UibTabsetController",templateUrl:"uib/template/tabs/tabset.html",link:function(a,b,c){a.vertical=angular.isDefined(c.vertical)?a.$parent.$eval(c.vertical):!1,a.justified=angular.isDefined(c.justified)?a.$parent.$eval(c.justified):!1}}}).directive("uibTab",["$parse",function(a){return{require:"^uibTabset",replace:!0,templateUrl:"uib/template/tabs/tab.html",transclude:!0,scope:{active:"=?",heading:"@",onSelect:"&select",onDeselect:"&deselect"},controller:function(){},controllerAs:"tab",link:function(b,c,d,e,f){b.$watch("active",function(a){a&&e.select(b)}),b.disabled=!1,d.disable&&b.$parent.$watch(a(d.disable),function(a){b.disabled=!!a}),b.select=function(){b.disabled||(b.active=!0)},e.addTab(b),b.$on("$destroy",function(){e.removeTab(b)}),b.$transcludeFn=f}}}]).directive("uibTabHeadingTransclude",function(){return{restrict:"A",require:"^uibTab",link:function(a,b){a.$watch("headingElement",function(a){a&&(b.html(""),b.append(a))})}}}).directive("uibTabContentTransclude",function(){function a(a){return a.tagName&&(a.hasAttribute("uib-tab-heading")||a.hasAttribute("data-uib-tab-heading")||a.hasAttribute("x-uib-tab-heading")||"uib-tab-heading"===a.tagName.toLowerCase()||"data-uib-tab-heading"===a.tagName.toLowerCase()||"x-uib-tab-heading"===a.tagName.toLowerCase())}return{restrict:"A",require:"^uibTabset",link:function(b,c,d){var e=b.$eval(d.uibTabContentTransclude);e.$transcludeFn(e.$parent,function(b){angular.forEach(b,function(b){a(b)?e.headingElement=b:c.append(b)})})}}}),angular.module("ui.bootstrap.timepicker",[]).constant("uibTimepickerConfig",{hourStep:1,minuteStep:1,secondStep:1,showMeridian:!0,showSeconds:!1,meridians:null,readonlyInput:!1,mousewheel:!0,arrowkeys:!0,showSpinners:!0,templateUrl:"uib/template/timepicker/timepicker.html"}).controller("UibTimepickerController",["$scope","$element","$attrs","$parse","$log","$locale","uibTimepickerConfig",function(a,b,c,d,e,f,g){function h(){var b=+a.hours,c=a.showMeridian?b>0&&13>b:b>=0&&24>b;return c?(a.showMeridian&&(12===b&&(b=0),a.meridian===u[1]&&(b+=12)),b):void 0}function i(){var b=+a.minutes;return b>=0&&60>b?b:void 0}function j(){var b=+a.seconds;return b>=0&&60>b?b:void 0}function k(a){return null===a?"":angular.isDefined(a)&&a.toString().length<2?"0"+a:a.toString()}function l(a){m(),t.$setViewValue(new Date(r)),n(a)}function m(){t.$setValidity("time",!0),a.invalidHours=!1,a.invalidMinutes=!1,a.invalidSeconds=!1}function n(b){if(t.$modelValue){var c=r.getHours(),d=r.getMinutes(),e=r.getSeconds();a.showMeridian&&(c=0===c||12===c?12:c%12),a.hours="h"===b?c:k(c),"m"!==b&&(a.minutes=k(d)),a.meridian=r.getHours()<12?u[0]:u[1],"s"!==b&&(a.seconds=k(e)),a.meridian=r.getHours()<12?u[0]:u[1]}else a.hours=null,a.minutes=null,a.seconds=null,a.meridian=u[0]}function o(a){r=q(r,a),l()}function p(a,b){return q(a,60*b)}function q(a,b){var c=new Date(a.getTime()+1e3*b),d=new Date(a);return d.setHours(c.getHours(),c.getMinutes(),c.getSeconds()),d}var r=new Date,s=[],t={$setViewValue:angular.noop},u=angular.isDefined(c.meridians)?a.$parent.$eval(c.meridians):g.meridians||f.DATETIME_FORMATS.AMPMS;a.tabindex=angular.isDefined(c.tabindex)?c.tabindex:0,b.removeAttr("tabindex"),this.init=function(b,d){t=b,t.$render=this.render,t.$formatters.unshift(function(a){return a?new Date(a):null});var e=d.eq(0),f=d.eq(1),h=d.eq(2),i=angular.isDefined(c.mousewheel)?a.$parent.$eval(c.mousewheel):g.mousewheel;i&&this.setupMousewheelEvents(e,f,h);var j=angular.isDefined(c.arrowkeys)?a.$parent.$eval(c.arrowkeys):g.arrowkeys;j&&this.setupArrowkeyEvents(e,f,h),a.readonlyInput=angular.isDefined(c.readonlyInput)?a.$parent.$eval(c.readonlyInput):g.readonlyInput,this.setupInputEvents(e,f,h)};var v=g.hourStep;c.hourStep&&s.push(a.$parent.$watch(d(c.hourStep),function(a){v=+a}));var w=g.minuteStep;c.minuteStep&&s.push(a.$parent.$watch(d(c.minuteStep),function(a){w=+a}));var x;s.push(a.$parent.$watch(d(c.min),function(a){var b=new Date(a);x=isNaN(b)?void 0:b}));var y;s.push(a.$parent.$watch(d(c.max),function(a){var b=new Date(a);y=isNaN(b)?void 0:b}));var z=!1;c.ngDisabled&&s.push(a.$parent.$watch(d(c.ngDisabled),function(a){z=a})),a.noIncrementHours=function(){var a=p(r,60*v);return z||a>y||r>a&&x>a},a.noDecrementHours=function(){var a=p(r,60*-v);return z||x>a||a>r&&a>y},a.noIncrementMinutes=function(){var a=p(r,w);return z||a>y||r>a&&x>a},a.noDecrementMinutes=function(){var a=p(r,-w);return z||x>a||a>r&&a>y},a.noIncrementSeconds=function(){var a=q(r,A);return z||a>y||r>a&&x>a},a.noDecrementSeconds=function(){var a=q(r,-A);return z||x>a||a>r&&a>y},a.noToggleMeridian=function(){return r.getHours()<12?z||p(r,720)>y:z||p(r,-720)<x};var A=g.secondStep;c.secondStep&&s.push(a.$parent.$watch(d(c.secondStep),function(a){A=+a})),a.showSeconds=g.showSeconds,c.showSeconds&&s.push(a.$parent.$watch(d(c.showSeconds),function(b){a.showSeconds=!!b})),a.showMeridian=g.showMeridian,c.showMeridian&&s.push(a.$parent.$watch(d(c.showMeridian),function(b){if(a.showMeridian=!!b,t.$error.time){var c=h(),d=i();angular.isDefined(c)&&angular.isDefined(d)&&(r.setHours(c),l())}else n()})),this.setupMousewheelEvents=function(b,c,d){var e=function(a){a.originalEvent&&(a=a.originalEvent);var b=a.wheelDelta?a.wheelDelta:-a.deltaY;return a.detail||b>0};b.bind("mousewheel wheel",function(b){z||a.$apply(e(b)?a.incrementHours():a.decrementHours()),b.preventDefault()}),c.bind("mousewheel wheel",function(b){z||a.$apply(e(b)?a.incrementMinutes():a.decrementMinutes()),b.preventDefault()}),d.bind("mousewheel wheel",function(b){z||a.$apply(e(b)?a.incrementSeconds():a.decrementSeconds()),b.preventDefault()})},this.setupArrowkeyEvents=function(b,c,d){b.bind("keydown",function(b){z||(38===b.which?(b.preventDefault(),a.incrementHours(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementHours(),a.$apply()))}),c.bind("keydown",function(b){z||(38===b.which?(b.preventDefault(),a.incrementMinutes(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementMinutes(),a.$apply()))}),d.bind("keydown",function(b){z||(38===b.which?(b.preventDefault(),a.incrementSeconds(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementSeconds(),a.$apply()))})},this.setupInputEvents=function(b,c,d){if(a.readonlyInput)return a.updateHours=angular.noop,a.updateMinutes=angular.noop,void(a.updateSeconds=angular.noop);var e=function(b,c,d){t.$setViewValue(null),t.$setValidity("time",!1),angular.isDefined(b)&&(a.invalidHours=b),angular.isDefined(c)&&(a.invalidMinutes=c),angular.isDefined(d)&&(a.invalidSeconds=d)};a.updateHours=function(){var a=h(),b=i();t.$setDirty(),angular.isDefined(a)&&angular.isDefined(b)?(r.setHours(a),r.setMinutes(b),x>r||r>y?e(!0):l("h")):e(!0)},b.bind("blur",function(b){t.$setTouched(),null===a.hours||""===a.hours?e(!0):!a.invalidHours&&a.hours<10&&a.$apply(function(){a.hours=k(a.hours)})}),a.updateMinutes=function(){var a=i(),b=h();t.$setDirty(),angular.isDefined(a)&&angular.isDefined(b)?(r.setHours(b),r.setMinutes(a),x>r||r>y?e(void 0,!0):l("m")):e(void 0,!0)},c.bind("blur",function(b){t.$setTouched(),null===a.minutes?e(void 0,!0):!a.invalidMinutes&&a.minutes<10&&a.$apply(function(){a.minutes=k(a.minutes)})}),a.updateSeconds=function(){var a=j();t.$setDirty(),angular.isDefined(a)?(r.setSeconds(a),l("s")):e(void 0,void 0,!0)},d.bind("blur",function(b){!a.invalidSeconds&&a.seconds<10&&a.$apply(function(){a.seconds=k(a.seconds)})})},this.render=function(){var b=t.$viewValue;isNaN(b)?(t.$setValidity("time",!1),e.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')):(b&&(r=b),x>r||r>y?(t.$setValidity("time",!1),a.invalidHours=!0,a.invalidMinutes=!0):m(),n())},a.showSpinners=angular.isDefined(c.showSpinners)?a.$parent.$eval(c.showSpinners):g.showSpinners,a.incrementHours=function(){a.noIncrementHours()||o(60*v*60)},a.decrementHours=function(){a.noDecrementHours()||o(60*-v*60)},a.incrementMinutes=function(){a.noIncrementMinutes()||o(60*w)},a.decrementMinutes=function(){a.noDecrementMinutes()||o(60*-w)},a.incrementSeconds=function(){a.noIncrementSeconds()||o(A)},a.decrementSeconds=function(){a.noDecrementSeconds()||o(-A)},a.toggleMeridian=function(){var b=i(),c=h();a.noToggleMeridian()||(angular.isDefined(b)&&angular.isDefined(c)?o(720*(r.getHours()<12?60:-60)):a.meridian=a.meridian===u[0]?u[1]:u[0])},a.blur=function(){t.$setTouched()},a.$on("$destroy",function(){for(;s.length;)s.shift()()})}]).directive("uibTimepicker",["uibTimepickerConfig",function(a){return{require:["uibTimepicker","?^ngModel"],controller:"UibTimepickerController",controllerAs:"timepicker",replace:!0,scope:{},templateUrl:function(b,c){return c.templateUrl||a.templateUrl},link:function(a,b,c,d){var e=d[0],f=d[1];f&&e.init(f,b.find("input"))}}}]),angular.module("ui.bootstrap.typeahead",["ui.bootstrap.debounce","ui.bootstrap.position"]).factory("uibTypeaheadParser",["$parse",function(a){var b=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;return{parse:function(c){var d=c.match(b);if(!d)throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "'+c+'".');return{itemName:d[3],source:a(d[4]),viewMapper:a(d[2]||d[1]),modelMapper:a(d[1])}}}}]).controller("UibTypeaheadController",["$scope","$element","$attrs","$compile","$parse","$q","$timeout","$document","$window","$rootScope","$$debounce","$uibPosition","uibTypeaheadParser",function(a,b,c,d,e,f,g,h,i,j,k,l,m){function n(){N.moveInProgress||(N.moveInProgress=!0,N.$digest()),Y()}function o(){N.position=D?l.offset(b):l.position(b),N.position.top+=b.prop("offsetHeight")}var p,q,r=[9,13,27,38,40],s=200,t=a.$eval(c.typeaheadMinLength);t||0===t||(t=1);var u=a.$eval(c.typeaheadWaitMs)||0,v=a.$eval(c.typeaheadEditable)!==!1;a.$watch(c.typeaheadEditable,function(a){v=a!==!1});var w,x,y=e(c.typeaheadLoading).assign||angular.noop,z=e(c.typeaheadOnSelect),A=angular.isDefined(c.typeaheadSelectOnBlur)?a.$eval(c.typeaheadSelectOnBlur):!1,B=e(c.typeaheadNoResults).assign||angular.noop,C=c.typeaheadInputFormatter?e(c.typeaheadInputFormatter):void 0,D=c.typeaheadAppendToBody?a.$eval(c.typeaheadAppendToBody):!1,E=c.typeaheadAppendTo?a.$eval(c.typeaheadAppendTo):null,F=a.$eval(c.typeaheadFocusFirst)!==!1,G=c.typeaheadSelectOnExact?a.$eval(c.typeaheadSelectOnExact):!1,H=e(c.typeaheadIsOpen).assign||angular.noop,I=a.$eval(c.typeaheadShowHint)||!1,J=e(c.ngModel),K=e(c.ngModel+"($$$p)"),L=function(b,c){return angular.isFunction(J(a))&&q&&q.$options&&q.$options.getterSetter?K(b,{$$$p:c}):J.assign(b,c)},M=m.parse(c.uibTypeahead),N=a.$new(),O=a.$on("$destroy",function(){N.$destroy()});N.$on("$destroy",O);var P="typeahead-"+N.$id+"-"+Math.floor(1e4*Math.random());b.attr({"aria-autocomplete":"list","aria-expanded":!1,"aria-owns":P});var Q,R;I&&(Q=angular.element("<div></div>"),Q.css("position","relative"),b.after(Q),R=b.clone(),R.attr("placeholder",""),R.val(""),R.css({position:"absolute",top:"0px",left:"0px","border-color":"transparent","box-shadow":"none",opacity:1,background:"none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)",color:"#999"}),b.css({position:"relative","vertical-align":"top","background-color":"transparent"}),Q.append(R),R.after(b));var S=angular.element("<div uib-typeahead-popup></div>");S.attr({id:P,matches:"matches",active:"activeIdx",select:"select(activeIdx, evt)","move-in-progress":"moveInProgress",query:"query",position:"position","assign-is-open":"assignIsOpen(isOpen)",debounce:"debounceUpdate"}),angular.isDefined(c.typeaheadTemplateUrl)&&S.attr("template-url",c.typeaheadTemplateUrl),angular.isDefined(c.typeaheadPopupTemplateUrl)&&S.attr("popup-template-url",c.typeaheadPopupTemplateUrl);var T=function(){I&&R.val("")},U=function(){N.matches=[],N.activeIdx=-1,b.attr("aria-expanded",!1),T()},V=function(a){return P+"-option-"+a};N.$watch("activeIdx",function(a){0>a?b.removeAttr("aria-activedescendant"):b.attr("aria-activedescendant",V(a))});var W=function(a,b){return N.matches.length>b&&a?a.toUpperCase()===N.matches[b].label.toUpperCase():!1},X=function(c,d){var e={$viewValue:c};y(a,!0),B(a,!1),f.when(M.source(a,e)).then(function(f){var g=c===p.$viewValue;if(g&&w)if(f&&f.length>0){N.activeIdx=F?0:-1,B(a,!1),N.matches.length=0;for(var h=0;h<f.length;h++)e[M.itemName]=f[h],N.matches.push({id:V(h),label:M.viewMapper(N,e),model:f[h]});if(N.query=c,o(),b.attr("aria-expanded",!0),G&&1===N.matches.length&&W(c,0)&&(angular.isNumber(N.debounceUpdate)||angular.isObject(N.debounceUpdate)?k(function(){N.select(0,d)},angular.isNumber(N.debounceUpdate)?N.debounceUpdate:N.debounceUpdate["default"]):N.select(0,d)),I){var i=N.matches[0].label;c.length>0&&i.slice(0,c.length).toUpperCase()===c.toUpperCase()?R.val(c+i.slice(c.length)):R.val("")}}else U(),B(a,!0);g&&y(a,!1)},function(){U(),y(a,!1),B(a,!0)})};D&&(angular.element(i).on("resize",n),h.find("body").on("scroll",n));var Y=k(function(){N.matches.length&&o(),N.moveInProgress=!1},s);N.moveInProgress=!1,N.query=void 0;var Z,$=function(a){Z=g(function(){X(a)},u)},_=function(){Z&&g.cancel(Z)};U(),N.assignIsOpen=function(b){H(a,b)},N.select=function(d,e){var f,h,i={};x=!0,i[M.itemName]=h=N.matches[d].model,f=M.modelMapper(a,i),L(a,f),p.$setValidity("editable",!0),p.$setValidity("parse",!0),z(a,{$item:h,$model:f,$label:M.viewMapper(a,i),$event:e}),U(),N.$eval(c.typeaheadFocusOnSelect)!==!1&&g(function(){b[0].focus()},0,!1)},b.on("keydown",function(a){if(0!==N.matches.length&&-1!==r.indexOf(a.which)){if(-1===N.activeIdx&&(9===a.which||13===a.which))return U(),void N.$digest();a.preventDefault();var b;switch(a.which){case 9:case 13:N.$apply(function(){angular.isNumber(N.debounceUpdate)||angular.isObject(N.debounceUpdate)?k(function(){N.select(N.activeIdx,a)},angular.isNumber(N.debounceUpdate)?N.debounceUpdate:N.debounceUpdate["default"]):N.select(N.activeIdx,a)});break;case 27:a.stopPropagation(),U(),N.$digest();break;case 38:N.activeIdx=(N.activeIdx>0?N.activeIdx:N.matches.length)-1,N.$digest(),b=S.find("li")[N.activeIdx],b.parentNode.scrollTop=b.offsetTop;break;case 40:N.activeIdx=(N.activeIdx+1)%N.matches.length,N.$digest(),b=S.find("li")[N.activeIdx],b.parentNode.scrollTop=b.offsetTop}}}),b.bind("focus",function(a){w=!0,0!==t||p.$viewValue||g(function(){X(p.$viewValue,a)},0)}),b.bind("blur",function(a){A&&N.matches.length&&-1!==N.activeIdx&&!x&&(x=!0,N.$apply(function(){angular.isObject(N.debounceUpdate)&&angular.isNumber(N.debounceUpdate.blur)?k(function(){N.select(N.activeIdx,a)},N.debounceUpdate.blur):N.select(N.activeIdx,a)})),!v&&p.$error.editable&&(p.$viewValue="",b.val("")),w=!1,x=!1});var aa=function(a){b[0]!==a.target&&3!==a.which&&0!==N.matches.length&&(U(),j.$$phase||N.$digest())};h.on("click",aa),a.$on("$destroy",function(){h.off("click",aa),(D||E)&&ba.remove(),D&&(angular.element(i).off("resize",n),h.find("body").off("scroll",n)),S.remove(),I&&Q.remove()});var ba=d(S)(N);D?h.find("body").append(ba):E?angular.element(E).eq(0).append(ba):b.after(ba),this.init=function(b,c){p=b,q=c,N.debounceUpdate=p.$options&&e(p.$options.debounce)(a),p.$parsers.unshift(function(b){return w=!0,0===t||b&&b.length>=t?u>0?(_(),$(b)):X(b):(y(a,!1),_(),U()),v?b:b?void p.$setValidity("editable",!1):(p.$setValidity("editable",!0),null)}),p.$formatters.push(function(b){var c,d,e={};return v||p.$setValidity("editable",!0),C?(e.$model=b,C(a,e)):(e[M.itemName]=b,c=M.viewMapper(a,e),e[M.itemName]=void 0,d=M.viewMapper(a,e),c!==d?c:b)})}}]).directive("uibTypeahead",function(){return{controller:"UibTypeaheadController",require:["ngModel","^?ngModelOptions","uibTypeahead"],link:function(a,b,c,d){d[2].init(d[0],d[1])}}}).directive("uibTypeaheadPopup",["$$debounce",function(a){return{scope:{matches:"=",query:"=",active:"=",position:"&",moveInProgress:"=",select:"&",assignIsOpen:"&",debounce:"&"},replace:!0,templateUrl:function(a,b){return b.popupTemplateUrl||"uib/template/typeahead/typeahead-popup.html"},link:function(b,c,d){b.templateUrl=d.templateUrl,b.isOpen=function(){var a=b.matches.length>0;return b.assignIsOpen({isOpen:a}),a},b.isActive=function(a){return b.active===a},b.selectActive=function(a){b.active=a},b.selectMatch=function(c,d){var e=b.debounce();angular.isNumber(e)||angular.isObject(e)?a(function(){b.select({activeIdx:c,evt:d})},angular.isNumber(e)?e:e["default"]):b.select({activeIdx:c,evt:d})}}}}]).directive("uibTypeaheadMatch",["$templateRequest","$compile","$parse",function(a,b,c){return{scope:{index:"=",match:"=",query:"="},link:function(d,e,f){var g=c(f.templateUrl)(d.$parent)||"uib/template/typeahead/typeahead-match.html";a(g).then(function(a){var c=angular.element(a.trim());e.replaceWith(c),b(c)(d)})}}}]).filter("uibTypeaheadHighlight",["$sce","$injector","$log",function(a,b,c){function d(a){return a.replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")}function e(a){return/<.*>/g.test(a)}var f;return f=b.has("$sanitize"),function(b,g){return!f&&e(b)&&c.warn("Unsafe use of typeahead please use ngSanitize"),b=g?(""+b).replace(new RegExp(d(g),"gi"),"<strong>$&</strong>"):b,f||(b=a.trustAsHtml(b)),b}}]),angular.module("uib/template/accordion/accordion-group.html",[]).run(["$templateCache",function(a){a.put("uib/template/accordion/accordion-group.html",'<div class="panel" ng-class="panelClass || \'panel-default\'">\n  <div class="panel-heading" ng-keypress="toggleOpen($event)">\n    <h4 class="panel-title">\n      <a href tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" uib-accordion-transclude="heading"><span ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n    </h4>\n  </div>\n  <div class="panel-collapse collapse" uib-collapse="!isOpen">\n	  <div class="panel-body" ng-transclude></div>\n  </div>\n</div>\n')}]),angular.module("uib/template/accordion/accordion.html",[]).run(["$templateCache",function(a){a.put("uib/template/accordion/accordion.html",'<div class="panel-group" ng-transclude></div>')}]),angular.module("uib/template/alert/alert.html",[]).run(["$templateCache",function(a){a.put("uib/template/alert/alert.html",'<div class="alert" ng-class="[\'alert-\' + (type || \'warning\'), closeable ? \'alert-dismissible\' : null]" role="alert">\n    <button ng-show="closeable" type="button" class="close" ng-click="close({$event: $event})">\n        <span aria-hidden="true">&times;</span>\n        <span class="sr-only">Close</span>\n    </button>\n    <div ng-transclude></div>\n</div>\n')}]),angular.module("uib/template/carousel/carousel.html",[]).run(["$templateCache",function(a){a.put("uib/template/carousel/carousel.html",'<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel" ng-swipe-right="prev()" ng-swipe-left="next()">\n  <div class="carousel-inner" ng-transclude></div>\n  <a role="button" href class="left carousel-control" ng-click="prev()" ng-show="slides.length > 1">\n    <span aria-hidden="true" class="glyphicon glyphicon-chevron-left"></span>\n    <span class="sr-only">previous</span>\n  </a>\n  <a role="button" href class="right carousel-control" ng-click="next()" ng-show="slides.length > 1">\n    <span aria-hidden="true" class="glyphicon glyphicon-chevron-right"></span>\n    <span class="sr-only">next</span>\n  </a>\n  <ol class="carousel-indicators" ng-show="slides.length > 1">\n    <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{ active: isActive(slide) }" ng-click="select(slide)">\n      <span class="sr-only">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if="isActive(slide)">, currently active</span></span>\n    </li>\n  </ol>\n</div>')}]),angular.module("uib/template/carousel/slide.html",[]).run(["$templateCache",function(a){a.put("uib/template/carousel/slide.html",'<div ng-class="{\n    \'active\': active\n  }" class="item text-center" ng-transclude></div>\n')}]),angular.module("uib/template/datepicker/datepicker.html",[]).run(["$templateCache",function(a){a.put("uib/template/datepicker/datepicker.html",'<div class="uib-datepicker" ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">\n  <uib-daypicker ng-switch-when="day" tabindex="0"></uib-daypicker>\n  <uib-monthpicker ng-switch-when="month" tabindex="0"></uib-monthpicker>\n  <uib-yearpicker ng-switch-when="year" tabindex="0"></uib-yearpicker>\n</div>')}]),angular.module("uib/template/datepicker/day.html",[]).run(["$templateCache",function(a){a.put("uib/template/datepicker/day.html",'<table class="uib-daypicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n    <tr>\n      <th ng-if="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-weeks" ng-repeat="row in rows track by $index">\n      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row" class="uib-day text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default btn-sm"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n')}]),angular.module("uib/template/datepicker/month.html",[]).run(["$templateCache",function(a){a.put("uib/template/datepicker/month.html",'<table class="uib-monthpicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-months" ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row" class="uib-month text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n')}]),angular.module("uib/template/datepicker/popup.html",[]).run(["$templateCache",function(a){a.put("uib/template/datepicker/popup.html",'<div>\n  <ul class="uib-datepicker-popup dropdown-menu" dropdown-nested ng-if="isOpen" ng-style="{top: position.top+\'px\', left: position.left+\'px\'}" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n    <li ng-transclude></li>\n    <li ng-if="showButtonBar" class="uib-button-bar">\n    <span class="btn-group pull-left">\n      <button type="button" class="btn btn-sm btn-info uib-datepicker-current" ng-click="select(\'today\')" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n      <button type="button" class="btn btn-sm btn-danger uib-clear" ng-click="select(null)">{{ getText(\'clear\') }}</button>\n    </span>\n      <button type="button" class="btn btn-sm btn-success pull-right uib-close" ng-click="close()">{{ getText(\'close\') }}</button>\n    </li>\n  </ul>\n</div>\n')}]),angular.module("uib/template/datepicker/year.html",[]).run(["$templateCache",function(a){a.put("uib/template/datepicker/year.html",'<table class="uib-yearpicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{::columns - 2}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-years" ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row" class="uib-year text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
}]),angular.module("uib/template/modal/backdrop.html",[]).run(["$templateCache",function(a){a.put("uib/template/modal/backdrop.html",'<div class="modal-backdrop"\n     uib-modal-animation-class="fade"\n     modal-in-class="in"\n     ng-style="{\'z-index\': 1040 + (index && 1 || 0) + index*10}"\n></div>\n')}]),angular.module("uib/template/modal/window.html",[]).run(["$templateCache",function(a){a.put("uib/template/modal/window.html",'<div modal-render="{{$isRendered}}" tabindex="-1" role="dialog" class="modal"\n    uib-modal-animation-class="fade"\n    modal-in-class="in"\n    ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}">\n    <div class="modal-dialog {{size ? \'modal-\' + size : \'\'}}"><div class="modal-content" uib-modal-transclude></div></div>\n</div>\n')}]),angular.module("uib/template/pager/pager.html",[]).run(["$templateCache",function(a){a.put("uib/template/pager/pager.html",'<ul class="pager">\n  <li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n  <li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n</ul>\n')}]),angular.module("uib/template/pagination/pagination.html",[]).run(["$templateCache",function(a){a.put("uib/template/pagination/pagination.html",'<ul class="pagination">\n  <li ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)">{{::getText(\'first\')}}</a></li>\n  <li ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)">{{page.text}}</a></li>\n  <li ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n  <li ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)">{{::getText(\'last\')}}</a></li>\n</ul>\n')}]),angular.module("uib/template/tooltip/tooltip-html-popup.html",[]).run(["$templateCache",function(a){a.put("uib/template/tooltip/tooltip-html-popup.html",'<div class="tooltip"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n</div>\n')}]),angular.module("template/tooltip/tooltip-html-unsafe-popup.html",[]).run(["$templateCache",function(a){a.put("template/tooltip/tooltip-html-unsafe-popup.html",'<div class="tooltip"\n  tooltip-animation-class="fade"\n  tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n</div>\n')}]),angular.module("uib/template/tooltip/tooltip-popup.html",[]).run(["$templateCache",function(a){a.put("uib/template/tooltip/tooltip-popup.html",'<div class="tooltip"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind="content"></div>\n</div>\n')}]),angular.module("uib/template/tooltip/tooltip-template-popup.html",[]).run(["$templateCache",function(a){a.put("uib/template/tooltip/tooltip-template-popup.html",'<div class="tooltip"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner"\n    uib-tooltip-template-transclude="contentExp()"\n    tooltip-template-transclude-scope="originScope()"></div>\n</div>\n')}]),angular.module("uib/template/popover/popover-html.html",[]).run(["$templateCache",function(a){a.put("uib/template/popover/popover-html.html",'<div class="popover"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content" ng-bind-html="contentExp()"></div>\n  </div>\n</div>\n')}]),angular.module("uib/template/popover/popover-template.html",[]).run(["$templateCache",function(a){a.put("uib/template/popover/popover-template.html",'<div class="popover"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content"\n        uib-tooltip-template-transclude="contentExp()"\n        tooltip-template-transclude-scope="originScope()"></div>\n  </div>\n</div>\n')}]),angular.module("uib/template/popover/popover.html",[]).run(["$templateCache",function(a){a.put("uib/template/popover/popover.html",'<div class="popover"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content" ng-bind="content"></div>\n  </div>\n</div>\n')}]),angular.module("uib/template/progressbar/bar.html",[]).run(["$templateCache",function(a){a.put("uib/template/progressbar/bar.html",'<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n')}]),angular.module("uib/template/progressbar/progress.html",[]).run(["$templateCache",function(a){a.put("uib/template/progressbar/progress.html",'<div class="progress" ng-transclude aria-labelledby="{{::title}}"></div>')}]),angular.module("uib/template/progressbar/progressbar.html",[]).run(["$templateCache",function(a){a.put("uib/template/progressbar/progressbar.html",'<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n</div>\n')}]),angular.module("uib/template/rating/rating.html",[]).run(["$templateCache",function(a){a.put("uib/template/rating/rating.html",'<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}">\n    <span ng-repeat-start="r in range track by $index" class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}" aria-valuetext="{{r.title}}"></i>\n</span>\n')}]),angular.module("uib/template/tabs/tab.html",[]).run(["$templateCache",function(a){a.put("uib/template/tabs/tab.html",'<li ng-class="{active: active, disabled: disabled}" class="uib-tab">\n  <a href ng-click="select()" uib-tab-heading-transclude>{{heading}}</a>\n</li>\n')}]),angular.module("uib/template/tabs/tabset.html",[]).run(["$templateCache",function(a){a.put("uib/template/tabs/tabset.html",'<div>\n  <ul class="nav nav-{{type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane" \n         ng-repeat="tab in tabs" \n         ng-class="{active: tab.active}"\n         uib-tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n')}]),angular.module("uib/template/timepicker/timepicker.html",[]).run(["$templateCache",function(a){a.put("uib/template/timepicker/timepicker.html",'<table class="uib-timepicker">\n  <tbody>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-increment hours"><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link" ng-disabled="noIncrementHours()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-increment minutes"><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link" ng-disabled="noIncrementMinutes()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-increment seconds"><a ng-click="incrementSeconds()" ng-class="{disabled: noIncrementSeconds()}" class="btn btn-link" ng-disabled="noIncrementSeconds()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n    <tr>\n      <td class="form-group uib-time hours" ng-class="{\'has-error\': invalidHours}">\n        <input style="width:50px;" type="text" placeholder="HH" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementHours()" ng-blur="blur()">\n      </td>\n      <td class="uib-separator">:</td>\n      <td class="form-group uib-time minutes" ng-class="{\'has-error\': invalidMinutes}">\n        <input style="width:50px;" type="text" placeholder="MM" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementMinutes()" ng-blur="blur()">\n      </td>\n      <td ng-show="showSeconds" class="uib-separator">:</td>\n      <td class="form-group uib-time seconds" ng-class="{\'has-error\': invalidSeconds}" ng-show="showSeconds">\n        <input style="width:50px;" type="text" placeholder="SS" ng-model="seconds" ng-change="updateSeconds()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementSeconds()" ng-blur="blur()">\n      </td>\n      <td ng-show="showMeridian" class="uib-time am-pm"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()" ng-disabled="noToggleMeridian()" tabindex="{{::tabindex}}">{{meridian}}</button></td>\n    </tr>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-decrement hours"><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link" ng-disabled="noDecrementHours()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-decrement minutes"><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link" ng-disabled="noDecrementMinutes()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-decrement seconds"><a ng-click="decrementSeconds()" ng-class="{disabled: noDecrementSeconds()}" class="btn btn-link" ng-disabled="noDecrementSeconds()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n  </tbody>\n</table>\n')}]),angular.module("uib/template/typeahead/typeahead-match.html",[]).run(["$templateCache",function(a){a.put("uib/template/typeahead/typeahead-match.html",'<a href\n   tabindex="-1"\n   ng-bind-html="match.label | uibTypeaheadHighlight:query"\n   ng-attr-title="{{match.label}}"></a>\n')}]),angular.module("uib/template/typeahead/typeahead-popup.html",[]).run(["$templateCache",function(a){a.put("uib/template/typeahead/typeahead-popup.html",'<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index, $event)" role="option" id="{{::match.id}}">\n        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n')}]),angular.module("ui.bootstrap.carousel").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find("head").prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>')}),angular.module("ui.bootstrap.datepicker").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find("head").prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;}.uib-button-bar{padding:10px 9px 2px;}</style>')}),angular.module("ui.bootstrap.timepicker").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find("head").prepend('<style type="text/css">.uib-time input{width:50px;}</style>')}),angular.module("ui.bootstrap.typeahead").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find("head").prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>')});